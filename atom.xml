<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aturx.github.io/</id>
    <title>链 求 君</title>
    <updated>2020-05-20T07:10:30.356Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aturx.github.io/"/>
    <link rel="self" href="https://aturx.github.io/atom.xml"/>
    <subtitle>AturX  的个人网站</subtitle>
    <logo>https://aturx.github.io/images/avatar.png</logo>
    <icon>https://aturx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 链 求 君</rights>
    <entry>
        <title type="html"><![CDATA[比特币如何运作]]></title>
        <id>https://aturx.github.io/post/bi-te-bi-ru-he-yun-zuo</id>
        <link href="https://aturx.github.io/post/bi-te-bi-ru-he-yun-zuo">
        </link>
        <updated>2020-05-20T07:04:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="比特币如何运作">比特币如何运作?</h1>
<p>如何对比特币进行准确的分类尚有争议。</p>
<p>它是一种货币，一种价值存储物，一种支付网络工具还是一种虚拟资产？</p>
<p>幸运的是，对比特币的定义相对更容易。 它是由软件程序构成，并非像金光闪闪的硬币图片所描绘的实物。</p>
<p>比特币是一串纯粹的数字所组成的，是一组协议或者说是算法的计算结果。</p>
<p>历史上数百次通过使用密码学（制作和破解密码的科学技术）创建虚拟货币的尝试中，它并非最早的一个，但却是最成功的。</p>
<p>比特币之后，已经启发了数千种数字货币的创造，但就市值而言，它仍然是最大的加密货币，这使得它在其十多年历史中一直保持主导地位。</p>
<p>（补充说明：根据比特币基金会的说法，“比特币-Bitcoin”一词在将加密货币称为实体时被大写，而在指代某种货币或单位本身时被称为“比特币-bitcoin”。比特币也缩写为“<br>
BTC”。）</p>
<ul>
<li>重要要点</li>
</ul>
<pre><code>1. 比特币是一种数字货币，是一种去中心化系统，可在被称为区块链的分布式账本中记录交易。

2. 比特币矿工使用复杂的计算机硬件来解决复杂的数学难题，以确认一个区块中的所有交易的有效性。完成
后，这些区块将被添加到区块链记录中，并向该矿工奖励少量的比特币，这个过程被称为“挖矿”。

3. 挖矿并不是获得比特币的唯一方式，比特币市场的其他参与者可以通过加密货币交易所或点对点方式买卖比特币。

4. 比特币分布式账本通过无信任系统得到保护，以防欺诈行为。即便比特币交易所在进行高度安全防范的条件下，依然有潜在的盗窃行为，而备受瞩目的盗窃案已经发生数次。
</code></pre>
<h2 id="1-诞生">1. 诞生</h2>
<p>比特币最早由自称中本聪的人在2008年的论文中首先提出，论文描述了区块链和比特币，有一段时间这两个术语几乎都是同义词。<br>
自那以来，区块链已经发展成为一个独立的概念，并且人们随后使用类似的加密技术，创建数千个区块链。<br>
因此此历史可能会使术语混淆，区块链有时是指原始的比特币区块链。<br>
在其他时候，它通常是指区块链技术或任何其他特定的区块链技术，例如为以太坊提供底层的区块链技术。</p>
<p>区块链技术的基础原理非常简单。<br>
任何给定的区块链均由按时间顺序排列的离散信息块的单链组成。<br>
原则上，此信息可以是1和0的任何字符串，这意味着它可以包括电子邮件，合同，土地所有权，结婚证书或债券交易。<br>
从理论上讲，只要双方都同意合同，就可以在区块链上建立两方之间的任何类型的合同。<br>
这消除了第三方参与任何合同的任何需要。<br>
这就开辟了无限的可能性，其中包括点对点金融产品，例如贷款或分散式储蓄和支票账户，而与银行或任何中介机构无关。</p>
<h2 id="2-后继者">2. 后继者</h2>
<p>比特币的当前目标是价值存储和支付系统。<br>
以太坊项目的主要目标是建立一个平台或者说世界计算机，在这个平台上可以执行“智能合约”，从而创建了一个去中心的金融基础设施，而没有任何中间商，但是随之而来的是存在费用和潜在的数据泄露风险。</p>
<p>这种多样性的发展，成功的引起了政府和私人公司的注意。<br>
实际上，一些分析人士认为，区块链技术最终将成为加密货币热潮中最具影响力的技术。<br>
但是，就比特币而言，区块链上的信息主要是交易。<br>
比特币实际上只是一个列表。A人向B人发送X比特币，B人向C人发送Y比特币，等等。<br>
通过加密计算这些交易，使得分布式网络的每个人都知道并确认交易的准确性。<br>
重要的是要注意，这些交易不一定是在人与人之间进行，可以是不同机构之间，不同系统之间，实现价值互通。</p>
<p>任何人都可以访问和使用比特币网络，而你的种族，性别，宗教，物种或政治倾向完全不相关。<br>
这为物联网创造了巨大的可能性。未来，我们会看到无人驾驶出租车或超大型汽车拥有自己的区块链钱包的系统。<br>
该车将从乘客那里收到加密货币，并且直到收到资金后才可以行驶。<br>
车辆将能够评估何时需要加油，并会自动使用钱包余额更方便的加油。</p>
<h2 id="3-使命">3. 使命</h2>
<p>尽管绝对公开，或者正因为如此，比特币极难篡改。比特币没有物理存在，因此你不能通过将其锁定在保险箱中或将其埋在树林中来保护它。</p>
<p>从理论上讲，小偷要想从你手中夺走它，所需要做的就是在分布式账本上添加一行，以表示“你付给了他，你所拥有的一切”。</p>
<p>一个令人担忧的是双重支付，即“双花问题”。如果一个有意破坏者想要花费一些比特币在两个或多个不同的地方，那么货币的价值信任将受到质疑。</p>
<p>对货币价值的信心就会迅速消失。为了实现双花，恶意攻击者将需要至少占用特币采矿能力的51％。所以，比特币网络越大，现实就越不现实，因为所需的计算能力将是天文数字，而且非常昂贵。</p>
<p>为了进一步防止任何一种情况的发生，您需要高度安全的信任机制。在这种情况下，使用传统货币的常规解决方案是通过中央，中立的仲裁员（例如银行）进行交易。比特币让这一过程变得不必要。（中本聪 最初的描述发表于2008年10月，这并非巧合，当时人们对银行的信任处于几代人的低谷。而当今的冠状病毒环境和政府债务不断增加的情况下，这显然又是一个反复出现的主题。）</p>
<p>与其拥有可靠的权威来保持总账本一致，不如使得网络去中心化，将比特币网络分散。每个人都能够关注其他所有人的账本，没有人特别需要认识或信任任何人就能使系统正常运行，一切基于程序算法实现共识。</p>
<p>假设一切都按预期进行，则加密协议可确保写在最长、时间最久的一条公开透明的区块链上的区块的可靠性是得到整个网络所认可的。</p>
<h2 id="4-技术与安全">4. 技术与安全</h2>
<ul>
<li>矿业</li>
</ul>
<p>网络中的节点维护这个去中心的公共账本正常运作并获得比特币奖励的过程称为采矿。参与的节点被称为矿工，矿工网络建立在比特币用户网络的基础上，这些网络将这些用户的交易记录在区块链上。</p>
<p>记录一串交易对于现代计算机而言是微不足道的，但是由于比特币的软件使该过程人为地耗时，因此挖矿过程是困难的。<br>
如果没有额外的难道，人们就可以轻易伪造交易来欺骗他人。他们可以将欺诈交易记录在区块链中，并在此基础上增加更多的虚假交易，以至于让网络中的其他节点无法分辨是欺诈行为还是真实交易。</p>
<p>同样，如果很容易就能创建欺诈交易并插入到区块中。那么网络将会变得非常庞大，充满了恶意制造的垃圾交易，而比特币将一文不值。</p>
<p>比特币采用一种巧妙的算法来解决这个问题，将“工作量证明”与其他加密技术相结合就是“中本聪”的突破。<br>
比特币的软件程序会调整矿工的工作难度，以便每10分钟左右网络会出一个1兆字节大小的交易块。<br>
这样，这段时间内的交易量就可以被打包到块中。整个网络有时间审查新的区块和它之前的公共账本，并且每个人都可以就现状达成共识。<br>
矿工希望看到比特币网络平稳运行，通过向分布式分类账中添加区块来验证交易。<br>
他们的工作也将得到奖励。我们将在下面仔细研究采矿奖励。</p>
<ul>
<li>减半</li>
</ul>
<p>如前所述，矿工因验证交易区块而获得比特币奖励。每开采210,000个区块，或每四年大约减少一半的奖励。此事件称为“比特币减半”。比特币系统是作为通货紧缩系统设计的，新的比特币被释放到流通系统中。</p>
<p>此过程对比特币采矿的奖励理论会持续到2140年左右。一旦从代码中开采了所有比特币并且完成了一半的交易，矿工将继续向网络用户收取交易打包费用作为激励。<br>
希望那时候，健康的网络竞争能够使比特币网络的手续费能保持在较低水平。</p>
<p>该系统提高了比特币的稀有率，并降低了通货膨胀率，直到最终为零。在2020年5月11日进行第三次减半之后，比特币开采每个区块的奖励是6.25比特币。</p>
<ul>
<li>哈希</li>
</ul>
<p>这是有关挖矿工作原理的一些技术性描述。遍布全球且不受个人或组织约束的矿工网络在接收到最新一批交易数据后，他们通过一种加密算法来运行数据，该算法最终生成一个“哈希值”，即一串数字和字母组成的，用于验证信息的有效性，但不会泄露信息本身。<br>
（实际上，这种分散式挖矿的理想愿景不再是个人可行的了，工业规模的挖矿矿场的出现和强大的矿池构已经成了寡头垄断。）</p>
<p>光有一个哈希值<br>
<code>000000000000000000c2c4d562224f272bd33d64e2a7d2f2feb67c15e826118f</code>，<br>
你是将无法知道相关区块（如＃1234）包含哪些事务或交易的。<br>
但是，你可以通过验证一堆数据的最终哈希值是否与该哈希值相同，从而辨别是否这是相同的数据。并确保它（#1234）未被篡改。如果一个数字不对应，那么不管数据多么少，数据都会生成完全不同的哈希串。<br>
例如，如果您通过哈希函数运行字符串“hello”，则可能会得到<code>2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</code>。<br>
但是，删除“o”字母后，“hell”的哈希值将是<code>0ebdc3317b75839f643387d783535adc360ca01f33c75f7c1e7373adcd675c0b</code>。<br>
尽管你只更改了原始文本中的一个字母，但得到的是完全不同的哈希。</p>
<p>哈希技术使比特币网络能够立即检查区块的有效性，可防止篡改。</p>
<p>为了保证新的区块得到之前区块的确认，前一个块的哈希将会作为一部分被写入新块内。如果在上一个块中的详细信息被篡改了，则该新的区块哈希也将被更改。即该区块的哈希值会引发一系列新的哈希值的变化，所以在比特币网络中进行历史数据的篡改几乎是无法实现的。</p>
<p>但是，只是把数据生成哈希值只能防止篡改，并不能真正保证比特币交易的可靠性。<br>
这个过程是如此简单快捷，以至于恶意破坏者仍然可以伪造哈希向网络发送垃圾信息，并且也许，如果有足够的计算能力，就可以将欺诈性交易写到之前的几个区块中，实现交易回滚。<br>
因此，比特币协议的“工作量证明”是十分必要的机制。<br>
通过向矿工指定一个非常苛刻满足条件，来达到这一效果，即他们的哈希值必须低于某个目标。</p>
<pre><code>一串随机的哈希值如 ‘2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824’ 非常容易获得
一串符合‘0000’ 开头的哈希值就没那么容易得到了。‘00004dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824’
这需要大量的计算获得，相对如果条件是‘00000000’开头，那么找到这样一个哈希值的难度就变得更高了。

'00000000111' &lt; '00001111111' 这就是“哈希值必须低于某个目标”的意义，“0”越多，值越小。
</code></pre>
<p>这就是块<code>＃1234</code> 的哈希值以一长串零开始的原因。由于每个数据字符串都将生成一个且仅一个哈希，因此，寻求足够小的哈希需要在数据末尾添加随机数。</p>
<p>开采的区块将被广播到网络让其他节点接收确认，确认过程需要花费一个小时左右的时间，尽管有时需要更长的时间。<br>
（同样，此描述也得到了简化。不对块进行整体哈希处理，而是将其分解为更有效的结构，称为Merkle树。）</p>
<ul>
<li>挖矿难度</li>
</ul>
<p>根据网络接收的流量大小，比特币的协议判断需要更长或更短的零开头字符串，从而调整至每10分钟达到一个新区块速率的难度。<br>
截至2019年10月，当前的难度约为6.379万亿，高于2009年的1。这表明，自从十年前推出这种加密货币以来，算力的提升和难度的提升，开采比特币变得更加困难。</p>
<p>挖矿是计算密集型的操作，需要大型，昂贵的计算设备和大量的电力来为其供电，而且需要更加高效的竞争力。<br>
尚不清楚哪种随机数将会起作用，因此唯一目标就是尽可能多的进行尝试计算不同的哈希，直到找到符合条件的。</p>
<p>早期，矿工们意识到，可以通过将多个计算设备合并成矿池，共享计算能力，最终将奖励分配给彼此来提高成功的机会。<br>
即使多个挖矿者共同分配了这些奖励，但仍然有足够的动力促使矿工进行比特币挖矿。</p>
<ul>
<li>奖励减半</li>
</ul>
<p>每次开采新区块时，成功的矿工都会收到一笔奖励的比特币交易。<br>
最初是50个，但后来减半到25个，之后是12.5个，截止2020年5月完成减半后仅为6.25个。<br>
每210,000个区块（或大约每四年）会发生一次减半，直到达到零。届时，所有2100万个比特币将被开采完成，而矿工将仅依靠打包交易服务费用来维护网络。</p>
<ul>
<li>51% 攻击</li>
</ul>
<p>当比特币推出时，计划该加密货币的总供应量将是2100万个。<br>
矿工们聚集起来挖矿的事实令人有些担忧，如果池超过网络挖掘能力的50％，则其参与者可能会有机会实现“双花”交易。<br>
他们还可能会阻止他人的交易。简而言之，这批矿工将有能力改变系统的分布式特性，并凭借其拥有的多数权力来操作交易的验证。</p>
<p>这可能意味着比特币的终结，但即使是所谓的51％攻击也可能无法使恶意攻击者撤消旧的交易，因为工作量证明要求使该过程非常耗费人力。<br>
要回滚并更改区块链，池将需要控制网络的大部分，以至于可能毫无意义。<br>
当你控制整个货币时，那你可以与谁进行交易呢？</p>
<p>从矿工的角度来看，51％的攻击是一种经济自杀命题。当采矿池Ghash.io在2014年达到网络计算能力的51％时，它自愿承诺不超过比特币哈希率的39.99％，以保持对加密货币价值的信心。<br>
与矿工有关的另一个令人担忧的问题是，实际趋势是他们集中在世界上电力价格相对便宜的部分地区，例如中国。</p>
<ul>
<li>比特币交易所</li>
</ul>
<p>对于大多数参与比特币网络的个人来说，区块链的来龙去脉，哈希率和挖掘并不是特别重要。<br>
在采矿社区之外，比特币所有者通常通过比特币交易所购买其供应的加密货币。这些在线平台可以促进比特币和其他数字货币的交易。</p>
<p>像Coinbase、币安、火币这样的比特币交易所汇聚了来自世界各地的市场参与者，进行买卖加密货币。<br>
这些交易所不仅越来越受欢迎（近年来比特币的知名度不断提高），而且还面临监管，法律和安全方面的挑战。<br>
随着世界各国政府以不同方式（以货币，资产类别或任何其他其他类别）审查加密货币，监管比特币买卖的法规非常复杂且不断变化。</p>
<p>对于比特币交易所的参与者来说，也许比改变监管监督的威胁更为重要的是盗窃和其他犯罪活动。<br>
尽管比特币网络本身在其整个发展历史上一直是安全的，但各个交易所不一定是安全的。<br>
许多盗窃都针对知名度较高的加密货币交易下手，常常导致价值数百万美元的代币损失。</p>
<p>最著名的交易所盗窃案，可能是2014年之前一直主导着比特币交易领域的Mt.Gox交易所被盗事件。<br>
当时该平台宣布可能盗窃了大约850,000个BTC，当时价值近4.5亿美元。随后Mt.Gox交易所申请破产并关门。<br>
直到今天，大部分被盗的赏金（现在价值约80亿美元）尚未被追回。</p>
<ul>
<li>私钥和钱包</li>
</ul>
<p>由于以上种种原因，理所当然的，比特币交易者和所有者将希望采取任何可能的安全措施来保护其资产。<br>
为此，他们选择使用私钥和钱包。<br>
比特币的所有权本质上可以归结为两个部分，即公共密钥和私有密钥。粗略的类比是用户名（公钥）和密码（私钥）。<br>
公钥的哈希（称为地址）是在区块链上显示的哈希，使用哈希可提供一定的安全性。</p>
<p>要接收比特币，发件人只需知道你的地址即可。公钥是从私钥派生的，你需要通过该私钥进行签名验证身份后，才能发送交易到另一个地址。</p>
<p>要访问比特币，请使用一个钱包，钱包可以采用不同的形式，从提供保险和借记卡的第三方Web应用程序到打印在纸上的QR码。<br>
最重要的区别是在“热”钱包和“冷”钱包之间的区别，“热”钱包已连接到Internet，因此容易受到黑客攻击，而“冷”钱包没有连接到Internet。</p>
<p>在Mt.Gox交易所被盗案中，据信大部分被盗的BTC都是从热钱包里拿走的。<br>
尽管如此，许多用户还是将自己的私钥委托给了加密货币交易所，这实际上是在押注，认为交易所将会比自己的计算机发生盗窃可能性更小，或者说交易所的安全性更高。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python面向对象编程：实现IoC控制反转]]></title>
        <id>https://aturx.github.io/post/python-mian-xiang-dui-xiang-bian-cheng-shi-xian-ioc-kong-zhi-fan-zhuan</id>
        <link href="https://aturx.github.io/post/python-mian-xiang-dui-xiang-bian-cheng-shi-xian-ioc-kong-zhi-fan-zhuan">
        </link>
        <updated>2020-05-18T08:48:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-面向对象基础知识">一、面向对象基础知识</h2>
<ol>
<li>
<p><code>type()</code> 判断数据类型</p>
</li>
<li>
<p><code>isinstance(a,b)</code> 判断class继承关系</p>
</li>
<li>
<p><code>dir()</code> 获取相关属性</p>
</li>
<li>
<p><code>__slots__</code><br>
限制属性添加,class类可以任意添加属性，<code>__slots__</code>用于限制添加的属性</p>
</li>
<li>
<p><code>@property</code> 和 <code>@x.setter</code> 装饰器，主要功能是：把一个方法变成属性调用<br>
解决的问题是，对于数据的检验，类似Java中的get<br>
set方法，但是可以对属性进行必要的检验，而对外暴露的依然是对属性的操作</p>
<pre><code>class Student(object):

 @property
 def score(self):
     return self._score

 @score.setter
 def score(self, value):
     if not isinstance(value, int):
         raise ValueError('score must be an integer!')
     if value &lt; 0 or value &gt; 100:
         raise ValueError('score must between 0 ~ 100!')
     self._score = value
     
使用：

 &gt;&gt;&gt; s = Student()
 &gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
 &gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
 60
 &gt;&gt;&gt; s.score = 9999
 Traceback (most recent call last):
   ...
 ValueError: score must between 0 ~ 100!
</code></pre>
</li>
<li>
<p>枚举类型:<br>
枚举类型可以当普通常量来使用，而且这些常量属同一类，比如星期，月份，错误编码，控制代码等。</p>
<pre><code>from enum import Enum
# 固定 定值 采用枚举
 class MaxCent(Enum):
     People = 30
     Air = 30
     Place = 20
     Other = 20

 print(MaxCent[&quot;People&quot;])
</code></pre>
</li>
</ol>
<h2 id="二-面向对象编程实践">二、面向对象编程实践</h2>
<p>IoC 解决的核心问题是：</p>
<ul>
<li>谁负责创建组件？</li>
<li>谁负责根据依赖关系组装组件？</li>
<li>销毁时，如何按依赖顺序正确销毁？</li>
</ul>
<hr>
<ol>
<li>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制</li>
</ol>
<p>例：</p>
<pre><code>class DB():	
    def __init__(self, config):	
        print(&quot;使用{}进行数据库连接操作&quot;.format(config))

	def query(self, data):
		print(&quot;查询: {}&quot;.format(data))

	def delete(self, data):
		print(&quot;删除： {}&quot;.format(data))
		
class Config():
    def __init__(self):
        print(&quot;配置信息&quot;)

class QueryService():
    def __init__(self):
        print(&quot;控制程序，顺序执行，创建对象&quot;)
        config = Config()
        db = DB(config)
    
        db.query(&quot;test query&quot;)

class DeleteService():
    def __init__(self):
        print(&quot;同上, Config 和 DB 再次被实例化&quot;)
        config = Config()
        db = DB(config)
        db.delete(&quot;test delete&quot;)


QueryService()
DeleteService()
</code></pre>
<ol start="2">
<li>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责<br>
，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制<br>
比如，上方： DB 将不再由 QueryService， DeleteService<br>
自己创建，而是等待外部，通过“方法”注入 比如交由一个 setDB()</li>
</ol>
<p>例：</p>
<pre><code>class QueryServiceIoC():

	def __init__(self):
		self.db = None
	# 依赖注入（DI：Dependency Injection）
	def setDB(self, db):
		self.db = db

	def query(self):
		print(&quot;通过注入查询&quot;)
		self.db.query(&quot;test IoC Query&quot;)

class DeleteServiceIoC():

	def __init__(self):
		self.db = None

	def setDB(self, db):
		self.db = db

	def delete(self):
		self.db.delete(&quot;test IoC Delete&quot;)
</code></pre>
<p>IoC又称为依赖注入（DI：Dependency<br>
Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。<br>
(参考 Java Spring)因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。<br>
一种最简单的配置是通过XML文件来实现</p>
<pre><code> &lt;beans&gt; &lt;bean id=&quot;DB&quot; class=&quot;DB&quot; /&gt;
    
    &lt;bean id=&quot;QueryServiceIoC&quot; class=&quot;QueryServiceIoC&quot;&gt;
        &lt;property name=&quot;DB&quot; ref=&quot;DB&quot; /&gt;
    &lt;/bean&gt;
    
    &lt;bean id=&quot;DeleteServiceIoC&quot; class=&quot;DeleteServiceIoC&quot;&gt;
        &lt;property name=&quot;DB&quot; ref=&quot;DB&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
分别三个 Bean 组件， DB 被分别注入到  QueryServiceIoC 和 DeleteServiceIoC 中
</code></pre>
<p>除了 set() 方法可以注入，还可以直接构造方法/初始化注入</p>
<pre><code>class QueryServiceIoCNew():	
    # 依赖注入（DI：Dependency Injection）	
    def __init__(self, db):	self.db = db

    def query(self):
        print(&quot;通过注入查询&quot;)
        self.db.query(&quot;test IoC Query&quot;)
</code></pre>
<p>Java Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用</p>
<p>Python 实现 IoC 思路， 由于Spring 使用 XML 存储 Bean 组件的依赖关系，在Python中实现则用一个BeanFactory替代，<br>
context: 存储Bean的名字和对应的类或者值的字典<br>
allowRepalce: 是否允许替换已经注入的Bean</p>
<pre><code># 依赖管理
class BeanFactory():
	def __init__(self,allowReplace=False):
		&quot;&quot;&quot;构造函数 allowReplace:是否允许替换已经注入的bean &quot;&quot;&quot;
		self.context = {}
		self.allowReplace = allowReplace

	def setBean(self, beanName, resource, *args, **kwargs):
		if not self.allowReplace:
			assert not beanName in self.context, &quot;该BeanFactory不允许重复注入%r,请修改beanName&quot; % beanName

		# 闭包函数
		def call():
			&quot;&quot;&quot;定义一个函数闭包,如果注入的resource是可调用类型,
			就将*args和**kwargs传入并调用该函数,然后将返回值返回
			如果是一个不可调用对象,就直接返回 &quot;&quot;&quot;
			if callable(resource):
				return resource(*args, **kwargs)
			else:
				return resource

		# 将call闭包与beanName建立映射
		self.context[beanName] = call


	def __getitem__(self, beanName):
		&quot;&quot;&quot;重载__getitem__方法,使得BeanFactory支持使用[]获取beanName对应的注册的资源 &quot;&quot;&quot;
		try:
			# 从context字典中取出beanName对应的资源
			resource = self.context[beanName]
		except KeyError:
			raise KeyError(&quot;%r 未注册&quot; % beanName)
		# 返回闭包函数调用后的结果
		return resource()

SpringIoCFactory = BeanFactory()



def HasMethods(*methods):
	def test(obj):
		for each in methods:
			try:
				attr = getattr(obj, each)
			except AttributeError:
				return False
			if not callable(attr): return False
		return True
	return test

def NoAssertion(obj): return True
class RequiredResource(object):
	def __init__(self, beanName, assertion=NoAssertion):
		self.beanName = beanName
		self.assertion = assertion
	def __get__(self, obj, T):#每次访问descriptor时都会调用__get__方法
		return self.result # &lt;-- .操作符会自动调用__getattr__
	def __getattr__(self, name):
		assert name == 'result', &quot;Unexpected attribute request other then 'result'&quot;
		self.result = self.Request()
		return self.result
	def Request(self):
		obj = SpringIoCFactory[self.beanName]
		assert self.assertion(obj), \
			&quot;The value %r of %r does not match the specified criteria&quot; \
			% (obj, self.feature)
		return obj



class TestIoCService():
	# 依赖注入（DI：Dependency Injection）
	db = RequiredResource('db')
	def __init__(self):
		self.s = &quot;初始化成功， 注入 db:  &quot;

	def print_db_info(self):
		self.db.query(&quot;通过依赖注入进行的查询！&quot;)


class DB_IoC():
	# 依赖注入（DI：Dependency Injection）
	config = RequiredResource('config')
	def __init__(self):
		print(&quot;使用{} 进行数据库连接操作&quot;.format(self.config))

	def query(self, data):
		print(&quot;查询: {}&quot;.format(data))

	def delete(self, data):
		print(&quot;删除： {}&quot;.format(data))


if __name__ == &quot;__main__&quot;:
	print(&quot;******* Test IoC Demo ********&quot;)
	SpringIoCFactory.setBean(&quot;db&quot;, DB_IoC)
	SpringIoCFactory.setBean(&quot;config&quot;, Config)

	# 测试
	tic = TestIoCService()
	tic.print_db_info()

	&quot;&quot;&quot;
	实现了 DB类 和Config 类 ，通过 IoC 方式进行依赖注入
	BeanFactory 是一个简易的IoC管理器，然后通过 RequiredResource 将需要实例化的类
	注入到使用的类中，完成“依赖注入”。
	而DB类 和Config类的实例化过程，并不是使用时才被实例化，而是提前被IoC容器创建，在使用的时候
	只是直接获取。从而实现“控制反转”
	&quot;&quot;&quot;
</code></pre>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208">面对对象高级编程</a></p>
</li>
<li>
<p><a href="http://www.voidcn.com/article/p-vxpqmayc-brn.html">Python IoC 实现</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 高阶函数及使用场景]]></title>
        <id>https://aturx.github.io/post/python-gao-jie-han-shu-ji-shi-yong-chang-jing</id>
        <link href="https://aturx.github.io/post/python-gao-jie-han-shu-ji-shi-yong-chang-jing">
        </link>
        <updated>2020-05-12T06:56:48.000Z</updated>
        <content type="html"><![CDATA[<p>Python有一些高阶函数，能够非常容易的解决一些比较特殊的场景问题。常用的几个函数如下所示。</p>
<h2 id="1-map">1. map</h2>
<p>场景一：</p>
<pre><code>有一批值或者数据，需要重复的执行同一个逻辑过程。用map函数把list中所有数字转为字符串：
&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']


实例场景：有一批用户名数据，现要求根据用户名，生成随机密码，给每个用户分配一个密码。
</code></pre>
<p>代码演示：</p>
<pre><code># user = [&quot;xxxx&quot;,&quot;&quot;]
def gen_password(user):
    from random import randint
    # 生成随机密码
    str_password = &quot;&quot;
    str_str = &quot;abcdefghij&quot;
    for i in range(8):
        num = randint(0, 9)
        str_password = str_password + str_str[num]

    password = str_password + user[0] + str_password    # 用用户名拼接一个密码
    user[1] = password
    print(&quot;用户生成的随机信息是: {}&quot;.format(user))
    return user

def demo1():
    # 场景一： 密码生成
    users_data = [
        [&quot;admin&quot;, &quot;&quot;],
        [&quot;userone&quot;, &quot;&quot;],
        [&quot;aturx&quot;, &quot;&quot;],
        [&quot;lisiyi&quot;, &quot;&quot;],
        [&quot;whoareyou&quot;, &quot;&quot;]
    ]

    result = map(gen_password, users_data)
    print(list(result))


demo1()
</code></pre>
<h2 id="2-reduce">2. reduce</h2>
<p>场景二：</p>
<pre><code>reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，
reduce把结果继续和序列的下一个元素做计算，其效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

实例场景：现有一个软件系统一年内每个月利润值，想要统计全年总利润。
</code></pre>
<p>代码演示：</p>
<pre><code>
def new_add_user(before, now):
    new_add = now + before
    return new_add


def demo2():
    # 场景二： 累计统计
    data = [
        1000, 1300, 1500, 4572,
        1976, 2230, 1212, 2222,
        1567, 2621, 3000, 2320
    ]
    from functools import reduce
    all = reduce(new_add_user, data)

    print(all)

demo2()
</code></pre>
<h2 id="3-filter">3. filter</h2>
<p>场景三：</p>
<pre><code>Python内建的filter()函数用于过滤序列。
和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。


实例场景：某系统有大量注册用户，先需要在一批注册用户中，找到年龄为40岁以上的男性用户。该场景非常适合使用过滤器。 
</code></pre>
<p>代码演示：</p>
<pre><code>
def is_man(user):
    # 过滤40岁以上男性
    if user[0] == &quot;man&quot; and user[1] &gt; 40:
        return True
    else:
        return False

def demo3():
    # 场景三： 过滤特定数据
    data = [
        [&quot;man&quot;, 30],
        [&quot;woman&quot;, 22],
        [&quot;woman&quot;, 22],
        [&quot;man&quot;, 42],
        [&quot;woman&quot;, 22],
        [&quot;man&quot;, 52],
        [&quot;woman&quot;, 22],
        [&quot;man&quot;, 12],
        [&quot;woman&quot;, 62],
        [&quot;man&quot;, 48],
        [&quot;man&quot;, 62],
        [&quot;woman&quot;, 22],
        [&quot;man&quot;, 39],
        [&quot;woman&quot;, 22],
    ]
    result_data = filter(is_man, data)
    print(list(result_data))

demo3()
</code></pre>
<h2 id="4-sorted">4. sorted</h2>
<p>场景四：</p>
<pre><code>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。

sorted()函数是一个高阶函数，它还可以接收一个key函数来实现自定义的排序。

实例场景： 现有一个班级学生的考试成绩单，先需要分别根据数学成绩排名（100分制）、英语成绩（ABCD制）排名。该场景适合自定义排序。
</code></pre>
<p>代码演示:</p>
<pre><code>def get_m_sort(student):
    # 返回数学分值
    return student[1]

def get_e_sort(student):
    # 返回英语分值
    return student[2]

def sorted_by_math(students):
    result = sorted(students, key=get_m_sort, reverse=True)  # 数字降序排列
    return result

def sorted_by_english(students):
    result = sorted(students, key=get_e_sort)
    return  result

def demo4():
    # 名字， 数学成绩， 英语成绩
    students = [
        [&quot;people1&quot;, 99, &quot;C&quot;],
        [&quot;people2&quot;, 78, &quot;B&quot;],
        [&quot;people3&quot;, 85, &quot;B&quot;],
        [&quot;people4&quot;, 63, &quot;F&quot;],
        [&quot;people5&quot;, 79, &quot;C&quot;],
        [&quot;people6&quot;, 68, &quot;D&quot;],
        [&quot;people7&quot;, 53, &quot;A&quot;],
    ]

    order_by_math = sorted_by_math(students)

    order_by_english = sorted_by_english(students)

    print(&quot;数学排名: &quot;, order_by_math)
    print(&quot;*&quot; * 10)
    print(&quot;英语排名: &quot;, order_by_english)

demo4()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比特币基础知识]]></title>
        <id>https://aturx.github.io/post/bi-te-bi-ji-chu-zhi-shi</id>
        <link href="https://aturx.github.io/post/bi-te-bi-ji-chu-zhi-shi">
        </link>
        <updated>2020-05-11T07:47:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是比特币">什么是比特币？</h1>
<p>比特币是2009年1月创建的一种数字货币。它实现了一位神秘人物中本聪（Satoshi Nakamoto）在白皮书中提出的想法，其真实身份尚未得到验证。比特币有望提供比传统在线支付机制更低的交易费用，并且与政府发行的货币不同，它由一个去中心的机制运行。</p>
<p>比特币并不是物理存在的，只是被保存在公共的分布式账本中，并且与所有比特币交易记录在一起，通过大量的计算进行验证。比特币不是由任何银行或政府发行或支持的，单个比特币也不是有价值的商品。尽管它不是法定货币，但比特币仍然受欢迎，并引发了数百种其他虚拟货币的发行，这些虚拟货币统称为“山寨币”。</p>
<pre><code>重要要点:

- 按市值计算，比特币于2009年推出，是世界上最大的加密货币。
- 与法定货币不同，比特币是通过使用称为区块链的去中心化分布式系统来创建，分配，交易和存储的。
- 比特币作为价值存储并不稳定，一直处于动荡不定的状态。2017年，加密货币的价格飙升至每枚硬币约20,000美元，但截至两年后，其货币交易量不到其中的一半。
- 作为最为广泛流行和成功的最早的加密货币，比特币启发了许多分支和模仿者。
</code></pre>
<h1 id="了解比特币">了解比特币</h1>
<p>比特币是一种加密货币。比特币数值的余额使用公共地址和私有“密钥”来保存，这是通过数学加密的长串数字和字母构成的。公钥（相当于银行帐号）用作发布给全世界的地址，其他人可以将他的比特币发送到该地址。私钥（与ATM PIN相对应）是受保护的密码，仅用于授权比特币传输。比特币密钥不应与比特币钱包混淆，后者是一种物理或数字设备，可促进比特币交易并允许用户跟踪硬币的所有权。术语“钱包”有点误导，因为比特币的去中心化性质意味着它永远不会存储在钱包中，而是分散地存储在区块链中。</p>
<p>风格注释：根据官方比特币基金会的说法，“比特币”一词在提及实体或概念时大写，而“比特币”在指代某种货币时用小写（例如，我购买了20个btc）或单位本身，比特币通常也缩写为“BTC”。</p>
<h1 id="比特币如何运作">比特币如何运作</h1>
<p>比特币是最早使用点对点技术促进即时付款的数字货币之一。拥有主导计算能力并参与比特币网络的独立个人和公司，也称为“矿工”，其主要动机是比特币奖励（释放新的比特币）和以比特币支付的交易费。这些矿工可以被视为强化比特币网络的信任机制。新的比特币将以固定的价格发布给矿工，但比特币的周期性奖励减半，使得比特币的总供应量接近2100万。目前，大约有300万比特币尚未开采。这样，比特币（以及通过类似过程生成的任何加密货币）的运行方式就不同于法定货币货币；在中心化的银行系统中，货币以与商品增长相匹配的速率释放，以维持价格稳定，而像比特币这样的去中心系统则根据算法预先设置释放率。</p>
<p>比特币挖矿是比特币发行流通的过程。通常，挖掘需要解决计算难题，以便发现新的区块，将其添加到区块链中。在为区块链做贡献的同时，挖矿还会在整个网络中添加和验证交易记录。如果成功向区块链中添加了新的区块，该矿工将会获得了一些比特币的奖励；每产生210,000个区块奖励会减少一半。在2009年，区块奖励是50个新的比特币，目前为12.5。随着越来越多的比特币被创建，挖掘过程的难度（即所涉及的计算能力）增加了。挖矿难度始于2009年比特币首次亮相时的1.0；到年底，只有1.18。截至2019年10月，采矿难度超过12万亿。曾经，一台普通的台式计算机足以满足采矿过程的需要；现在，为了克服难度，矿工必须使用昂贵的硬件，例如专用集成电路（ASIC）和更高级的处理单元，例如图形处理单元（GPU）。这些精心制作的挖矿处理器被称为“矿机”。</p>
<p>一个比特币可整除到小数点后八位（一个比特币的百万分之一），而这个最小的单位称为“聪”。如果有必要，并且如果参与的矿工接受更改，则最终可以将比特币整除为甚至更多的小数位。</p>
<h1 id="比特币的价格变化">比特币的价格变化</h1>
<p>仅在2017年，比特币的价格就从年初的不到1000美元上涨到接近19000美元，到年末上涨了1400％以上。最近，加密货币的价值已经下降并且或多或少处于稳定状态，除了一些相对较低的价格数据（2019年初，价格徘徊在3500美元左右）和相对较高的价格（2019年6月和7月），当时价格一度达到13,000美元以上的峰值）。截至2019年10月，比特币似乎稳定在了一个新的价格点，范围在8,000美元至9,000美元之间。</p>
<p>比特币的价格在很大程度上取决于其采矿网络的规模，因为网络规模越大，生产新比特币就越困难-因此成本也更高。结果，随着其生产成本的上升，比特币的价格也不得不上涨。比特币采矿网络的总处理能力称为“哈希率”，是指在将区块添加到区块链之前，网络每秒可以尝试完成必要的哈希难题的次数。截至2019年10月23日，该网络每秒达到114亿个哈希的创纪录新高。</p>
<h1 id="比特币的开端">比特币的开端</h1>
<ul>
<li>
<p>2008年8月18日：域名<code>bitcoin.org</code>已被注册。至少到今天，该域名的主人的身份仍不是公共信息。</p>
</li>
<li>
<p>2008年10月31日：有人使用中本聪（Satoshi Nakamoto）的名字在metzdowd.com上的“密码学邮件”列表中宣布：“我一直在研究一种完全对等，没有可信任第三方的新型电子现金系统该文件可从  http://www.bitcoin.org/bitcoin.pdf 获得。” 该链接指向在bitcoin.org上发布的著名白皮书，标题为“ Bitcoin：P2P电子现金系统”。本文将成为当今比特币运作方式的“大宪章”。</p>
</li>
<li>
<p>2009年1月3日：开采了第一个比特币区块，即区块0。这也被称为“创世区块”，其中包含以下文字：“泰晤士报2009年1月3日 总理正处于对银行的第二轮纾困之际”，这也许是为了作为该区块是在该日期被开采的证据，也可能单纯的政治评论。</p>
</li>
<li>
<p>2009年1月8日：加密邮件列表中宣布了比特币软件的第一个版本。</p>
</li>
<li>
<p>2009年1月9日：第1区块被开采，比特币正式的开采开始了。</p>
</li>
</ul>
<h1 id="谁发明了比特币">谁发明了比特币？</h1>
<p>没有人知道谁发明了比特币，或者至少不是结论性的。中本聪（Satoshi Nakamoto）是与在2008年发布原始比特币白皮书并致力于2009年发行的原始比特币软件的个人或组织相关的名称。比特币协议要求用户在注册时输入生日，我们知道中本聪（Satoshi Nakamoto）的个人注册并记下4月5日为生日。自那时以来的几年中，出现许多人冒充者，欺世盗名之徒，但截至2020年5月，中本聪背后的真实身份仍然被掩盖而无法确认。</p>
<h1 id="中本聪之前">中本聪之前</h1>
<p>尽管人们很容易相信媒体的说法，认为中本聪是一个孤独的天才，他凭空创造了比特币，但这种创新通常不会在真的凭空被创造。所有主要的科学发现，无论是多么原始的发现，都是建立在先前已有的研究之上。比特币的先驱是：亚当·巴克（Adam Back）于1997年发明的Hashcash，随后是戴维（Wei Dai）的b-money，尼克·萨博（Nick Szabo）的比特黄金和哈尔·芬尼（Hal Finney）的可重复使用工作量证明。比特币白皮书本身引用了Hashcash和b-money，以及涉及多个研究领域的其他各种著作。这不足为奇，上面提到的其他项目背后的许多人被推测也参与了比特币的创建。</p>
<h1 id="为什么中本聪要匿名">为什么中本聪要匿名？</h1>
<p>比特币发明人对其身份保持保密的主要动机有两个。</p>
<p>一种是隐私。随着比特币的流行（成为一种全球现象），中本聪（Satoshi Nakamoto）可能会引起媒体和政府的广泛关注。</p>
<p>另一个原因是安全性。仅2009年一年，就开采了32,489个区块。以当时每块50 BTC的回报率，2009年的总支出为1,624,500 BTC，截至2019年10月25日，价值为139亿美元。所以可能得出结论，到2009年，中本聪和其他一些早期参与者，他们拥有大量的BTC。拥有这么多比特币的人可能会成为犯罪分子的目标，尤其是因为比特币不像股票，而更像现金，可以打印出授权支出所需的私钥，并将其字面上保存在床垫下。虽然比特币的发明者可能会采取预防措施以使任何敲诈勒索引起的转移都可追溯，但保持匿名是中本聪限制暴露的好方法。</p>
<h1 id="谁是中本聪">谁是中本聪？</h1>
<p>主要媒体，加密货币专家和其他狂热者对中本聪（Satoshi Nakamoto）角色背后的个人或组织进行了猜测。2011年10月10日，《纽约客》 发表了一篇文章，推测中本聪可能是爱尔兰密码学学生迈克尔·克莱尔（Michael Clear）或经济社会学家维利·莱顿维尔塔（Vili Lehdonvirta）。<br>
Fast Company认为中本聪可能是由三个人组成的小组，小组成员是-Neal King，Vladimir Oksman和Charles Bry，他们一起出现在与<code>bitcoin.org</code>注册有关的安全通信相关专利中。2013年5月发表的一篇文章将更多嫌疑人添加到了名单中，其中包括比特币项目的主要开发人员Gavin Andresen；现已解散的比特币交易所Mt.的联合创始人Jed McCaleb x; 以及著名的日本数学家望月新一（Shinichi Mochizuki）。</p>
<p>2013年12月，Techcrunch发表了对研究员Skye Gray的采访，后者声称对发表的著作进行了文字分析，显示中本聪与比特现金的创作者Nick Szabo之间的联系。在2014年3月，《新闻周刊》刊登了一篇封面文章，声称中本聪实际上是一个名叫中本聪的人，中本聪是现居加利福尼亚的64岁的日裔美国工程师。之后，澳大利亚计算机科学家和加密货币支持者克雷格·赖特（Craig Wright）声称自己是中本聪（Satoshi Nakamoto），他也是后面官司不断的“澳本聪”。</p>
<p>在比特币十多年之后，世界仍然不知道谁是世界顶级数字货币的背后人物，而且这个谜团可能永远无法解决。</p>
<h1 id="可以证明中本聪的身份吗">可以证明中本聪的身份吗？</h1>
<p>似乎甚至早期的项目合作者都没有可验证“中本聪”真实身份的证明。为了最终确定中本聪是谁，需要在他/她与比特币的活动与他/她的身份之间建立明确的联系。这可以通过链接bitcoin.org的域名注册来追寻，中本聪使用的电子邮件和论坛帐户或使用拥有最早开采的比特币地址的所有权来证明。尽管“中本聪”拥有的比特币可以在区块链上追踪到，但他/她似乎还没有用以能揭示其身份的方式去兑现这些比特币。如果“中本聪”今天将其比特币转移到交易所，这一定会引起人们的注意，但是资金充裕且成功的交易所似乎不太可能出卖任何客户的隐私。</p>
<h1 id="用比特币作为付款方式">用比特币作为付款方式</h1>
<p>比特币可以作为销售产品或提供的服务的付款方式。如果您有一家实体店，只需显示一个标语“此处接受比特币”，您的许多客户很可能会被吸引过来；交易方式可以通过QR码（二维码）和触摸屏应用程序使用必要的硬件终端或钱包地址进行处理。只需将支付选项添加到它提供的其他选项（例如信用卡，支付宝、微信支付等）中，在线业务就可以轻松接受比特币。</p>
<h1 id="获得比特币报酬的工作">获得比特币报酬的工作</h1>
<p>那些自由职业者可以通过比特币作为工作报酬。有几个专门针对数字货币的网站：</p>
<ul>
<li><a href="https://www.cryptogrind.com/">Cryptogrind</a> 网站汇集了大量求职者和潜在雇主，支持通过比特币结算。</li>
<li><a href="https://freelanceforcoins.com/">freelanceforcoins</a> 用加密货币付费的自由职业 （比特币，以太坊等）</li>
<li><a href="https://ethlance.com">ethlance</a> Ethlance数据库分布在以太坊公共区块链上，源文件位于IPFS上。所有人都可以永远使用Ethlance，而没有任何中央机构对其进行控制。</li>
</ul>
<h1 id="投资比特币">投资比特币</h1>
<p>许多比特币支持者认为数字货币是未来。许多支持比特币的人认为，它为全球交易提供了更快，更免费的支付系统。尽管没有任何政府或中央银行的支持，但比特币可以兑换成传统货币。实际上，其兑美元的汇率吸引了对货币交易感兴趣的潜在投资者和交易员。确实，比特币等数字货币增长的主要原因之一是，它们可以替代国家法定货币和黄金等传统商品。</p>
<p>2014年3月，美国国税局指出，所有虚拟货币（包括比特币）都将作为财产而不是货币征税。作为资本持有的比特币的收益或损失将被实现为资本收益或损失，而作为库存持有的比特币将产生普通的收益或损失。您从另一方开采或购买的比特币的销售，或使用比特币支付商品或服务的费用，都是可以征税的交易案例。</p>
<p>像任何其他资产一样，低买高卖的原理也适用于比特币。积累货币的最流行方法是在比特币交易所购买，但是还有许多其他赚钱和拥有比特币的方法。</p>
<h1 id="比特币投资的风险">比特币投资的风险</h1>
<p>尽管比特币并非被设计为正常的股权投资（没有发行股票），但在2011年5月和2013年11月再次迅速升值后，一些投机者被数字货币吸引。因此，许多人购买比特币来获得其投资价值而不是作为交易的媒介。</p>
<p>但是，它缺乏稳定的价值保证，意味着购买和使用比特币存在若干固有风险。证券交易委员会（SEC），金融业监管局（FINRA），消费者金融保护局（CFPB）和其他机构已经发布了许多投资者警报。</p>
<p>虚拟货币的概念仍然很新颖，与传统投资相比，比特币没有太多的长期追踪记录或可信度的历史。随着比特币的日益普及，比特币每天都变得越来越缺乏实验性。十年后，它们（像所有数字货币一样）仍处于发展阶段，并且一直在不断发展。 建立和投资于比特币和区块链公司的数字货币集团首席执行官巴里·席尔伯特（Barry Silbert）说：“这几乎是您可能做出的最高风险，最高回报的投资。”</p>
<h1 id="比特币监管风险">比特币监管风险</h1>
<p>以多种形式向比特币投资并不是为了规避风险。比特币是政府货币的竞争对手，可用于黑市交易，洗钱，非法活动或逃税。结果，各国政府可能寻求规范，限制或禁止使用和出售比特币，有些已经这样做。其他人提出了各种规则。例如，在2015年，纽约州金融服务部最终确定了法规，该法规要求与比特币的购买，出售，转移或存储打交道的公司必须记录客户的身份，拥有合规官并保持资本储备。价值10,000美元或以上的交易必须进行记录和报告。</p>
<p>由于缺乏有关比特币（和其他虚拟货币）的统一法规，引发了人们对它们的寿命，流动性和普遍性的质疑。</p>
<h1 id="比特币的安全风险">比特币的安全风险</h1>
<p>拥有和使用比特币的大多数个人并非通过“挖矿”获得其代币。相反，他们在称为“比特币交易所”的许多流行在线市场中的任何一个上买卖比特币和其他数字货币。比特币交易所完全是数字化的，并且与任何虚拟系统一样，受到黑客，恶意软件和操作故障的威胁。如果小偷可以访问比特币所有者的计算机硬盘并窃取了他的私有加密密钥，则他可以将被盗的比特币转移到另一个帐户。（只有当比特币存储在未连接到互联网的计算机上，或者选择使用纸钱包时，用户才能阻止此操作–打印出比特币的私钥和地址，而根本解决方案就是不将其保存在计算机上。）黑客还可以将比特币交易作为目标，从而可以访问成千上万的帐户和存储比特币的数字钱包。2014年发生了一起特别臭名昭著的骇客事件，当时 Gox是日本的一家比特币交易所，在价值数百万美元的比特币被盗后，被迫关闭。</p>
<p>你需要记住所有比特币交易都是永久且不可逆的。这就像处理现金一样：使用比特币进行的任何交易只有在收到比特币的人退款后才能撤消。就像借记卡或信用卡一样，没有第三方或付款处理者，因此，如果有问题，就没有办法保护或追溯来源。</p>
<h1 id="保险风险">保险风险</h1>
<p>一些投资是通过证券投资者保护公司进行担保的。正常的银行帐户通过联邦存款保险公司（FDIC）进行最高限额的保险，具体取决于司法管辖区。一般来说，比特币交易所和比特币账户不受任何类型的联邦或政府计划的保险。在2019年，主要交易商和交易平台SFOX宣布将能够为比特币投资者提供FDIC保险，但仅适用于涉及现金的部分交易。</p>
<h1 id="比特币欺诈的风险">比特币欺诈的风险</h1>
<p>比特币使用私钥加密来验证所有者并注册交易，欺诈者和骗子可能会尝试出售虚假的比特币。例如，2013年7月，SEC对与比特币相关的庞氏骗局的运营商提起了法律诉讼。还记录了另一种常见欺诈形式的比特币价格操纵案件。</p>
<h1 id="市场风险">市场风险</h1>
<p>像任何投资一样，比特币价值可能会波动。确实，该货币的价值在其短暂存续期间已经出现了剧烈的价格波动。根据交易所的大量买卖，它对“新闻”具有很高的敏感性。根据CFPB，比特币的价格在2013年单日下跌了61％，而在2014年则是单日价格下跌的记录。高达80％</p>
<p>如果越来越少的人开始接受比特币作为货币，那么这些数字单位可能会失去价值，并变得一文不值。确实，有人猜测，当价格在2017年底和2018年初的加密货币高峰期间从历史最高点下跌时，“比特币泡沫”就破灭了。已经有足够的竞争，尽管比特币在比特币价格上有巨大的领先优势。得益于其品牌知名度和风险投资资金，数以百计的其他数字货币如雨后春笋般涌现，其他更好的虚拟硬币形式的技术突破始终是威胁。</p>
<h1 id="比特币的税收风险">比特币的税收风险</h1>
<p>由于比特币没有资格包含在任何税收优惠的退休账户中，因此没有很好的法律选择来保护投资免税。</p>
<h1 id="比特币的分叉">比特币的分叉</h1>
<p>自比特币推出以来，矿工与开发者之间的分歧引发了无数观点纠纷，引发了加密货币社区的大规模分裂。在某些情况下，一群比特币用户和矿工改变了比特币网络本身的协议。此过程称为“分叉”，通常会导致使用新名称创建新型比特币。这种拆分可能是“硬分叉”，其中新硬币与比特币共享交易历史，直到确定的拆分点为止，在该点上创建了新代币。由于硬分叉而创建的加密货币示例包括Bitcoin Cash（创建于2017年8月），Bitcoin Gold（创建于2017年10月）和Bitcoin SV（创建于2017年11月）。一个“软叉” 是对协议的更改，仍然与以前的系统规则兼容。例如，比特币软叉增加了块的总大小。</p>
<h1 id="相关内容">相关内容</h1>
<p><a href="https://learnblockchain.cn/article/854">什么是数字货币？</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 字符串与编码]]></title>
        <id>https://aturx.github.io/post/python-zi-fu-chuan-yu-bian-ma</id>
        <link href="https://aturx.github.io/post/python-zi-fu-chuan-yu-bian-ma">
        </link>
        <updated>2020-05-09T09:42:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="比特bit">比特（bit）</h1>
<p>计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理，bit是计算机的最小单位。</p>
<h1 id="字节byte">字节（byte）</h1>
<p>最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），一个字节能表示的最大的整数就是255（二进制11111111=十进制255）</p>
<h1 id="ascii-编码">ASCII 编码</h1>
<p>计算机最早发明，通用语言是英语，所以采用127个字符，表示大小写英文字母、数字和一些符号就足够了。这个编码表，就是<code>ASCII</code>编码，比如<code>A</code> 编码是<code>65</code>.<br>
用一个字节（<code>0~255</code>）就能够表示。</p>
<p>但是，对于其国家他语言来说，光常用的中文汉字就几千个，还有其他韩语、日语等等，一个字节（<code>0~255</code>）陷入是不够的，至少两个字节（<code>0~65535</code>），还不能和<code>ASCII</code>编码冲突，中国制定自己的<code>GB2312</code>编码,日文<code>Shift_JIS</code>,韩文<code>Euc-k</code>,各国各自的标准自然会出现冲突，所以多语言混合的内容中，经常会看到乱码出现。</p>
<p>为了解决这个问题，出现了Unicode（万国码）编码。</p>
<h1 id="unicode-编码">Unicode 编码</h1>
<p>Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。现代操作系统和大多数编程语言都直接支持Unicode。最常用的是用两个字节（<code>0~65535</code>）表示一个字符（如果要用到非常偏僻的字符，就需要4个字节(<code>0~4294967295</code>)）</p>
<p>乱码问题解决了，但是新的问题是，如果统一采用<code>Unicode</code>编码，存储将会是<code>ASCII</code>编码的至少两倍。</p>
<p>本着节约的精神，又出现了把<code>Unicode</code>编码转化为“可变长编码”的<code>UTF-8</code>编码。</p>
<h1 id="utf-8-编码">UTF-8 编码</h1>
<p>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。</p>
<p>实际使用时，根据场景决定使用Unicode 还是 UTF-8，计算机内存中，统一使用Unicode编码（统一编码），当需要保存到硬盘或者需要传输的时候（节约空间），就转换为UTF-8编码。</p>
<h1 id="python-字符串">Python 字符串</h1>
<p>在Python 3版本中，把'xxx'和u'xxx'统一成Unicode编码，即写不写前缀u都是一样的。</p>
<p>在Python 3版本中，所有的字符串都是使用Unicode编码的字符串序列。</p>
<p>Python 3最重要的新特性之一是对字符串和二进制数据流做了明确的区分。文本总是 Unicode，由 str 类型表示，二进制数据则由 bytes 类型表示。</p>
<p>Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p>
<p>Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p>
<pre><code>str 转换成 bytes：

&gt;&gt;&gt; 'ABC'.encode('ascii')
b'ABC'     # 3个字节
&gt;&gt;&gt; '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'  # 6个字节


# 1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。


bytes 转换成 str：

&gt;&gt;&gt; b'ABC'.decode('ascii')
'ABC'
&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文

#  在bytes中，无法显示为ASCII字符的字节，用\x##显示 （\x## 是一个字节）

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小的Flask Web应用]]></title>
        <id>https://aturx.github.io/post/zui-xiao-de-flask-web-ying-yong</id>
        <link href="https://aturx.github.io/post/zui-xiao-de-flask-web-ying-yong">
        </link>
        <updated>2020-05-09T07:09:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装-flask">安装 Flask</h1>
<pre><code>pip3 install flask

或者

pipenv install flask

或者 [PyPI 网站](https://pypi.org/project/Flask/#files)下载源码包安装：

pip3 install Flask-1.1.2-py2.py3-none-any.whl 
</code></pre>
<h1 id="编写代码">编写代码</h1>
<pre><code>from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!'

# 运行
app.run()
</code></pre>
<p>一些常用的配置：</p>
<ol>
<li>端口设定</li>
</ol>
<pre><code>app.run(port=&quot;5001&quot;)
</code></pre>
<ol start="2">
<li>Debug 模式开启</li>
</ol>
<pre><code>app.run(port=&quot;5001&quot;, debug=True)
</code></pre>
<ol start="3">
<li>静态资源路径配置</li>
</ol>
<pre><code># 默认不设置则为当前路径下 template 和 static
app = Flask(__name__,template_folder=&quot;F:\\templates&quot;, static_folder=&quot;F:\\static&quot;)


</code></pre>
<ol start="4">
<li>所有IP可以访问(否则只能本机访问)</li>
</ol>
<pre><code>app.run(port=&quot;5001&quot;, debug=True, host=&quot;0.0.0.0&quot;)
</code></pre>
<h1 id="参考内容">参考内容</h1>
<p><a href="http://docs.jinkan.org/docs/flask/">Flask文档</a></p>
<p><a href="https://www.w3cschool.cn/flask/flask_deployment.html">Flask教程</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Works Show - 作品集]]></title>
        <id>https://aturx.github.io/post/works-show-zuo-pin-ji-ye-mian</id>
        <link href="https://aturx.github.io/post/works-show-zuo-pin-ji-ye-mian">
        </link>
        <updated>2020-05-08T02:57:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="️-预览">❤️ 预览</h1>
<p>😎<a href="https://susuwataricoder.github.io/">在线地址</a></p>
<hr>
<h1 id="项目功能">✅ 项目功能</h1>
<p>完成一个作品集页面，一些练习代码，功能页面的展示。<br>
该页面是完成了FreeCodeCamp 中的一个项目练习。</p>
<hr>
<h1 id="️-使用技术">♻️ 使用技术</h1>
<p>HTML / CSS</p>
<p>部署在GitHub上的静态页面</p>
<hr>
<h1 id="参考资料">➿  参考资料</h1>
<p><a href="https://learn.freecodecamp.one/">FreeCodeCamp</a></p>
<p><a href="https://github.com/SusuwatariCoder">参考仓库</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python的多进程使用]]></title>
        <id>https://aturx.github.io/post/python-de-duo-jin-cheng-shi-yong</id>
        <link href="https://aturx.github.io/post/python-de-duo-jin-cheng-shi-yong">
        </link>
        <updated>2020-04-23T07:39:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="multiprocessing-模块">multiprocessing 模块</h1>
<p>multiprocessing模块就是跨平台版本的多进程模块</p>
<p>multiprocessing模块提供了一个Process类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>
<pre><code>import hashlib
from time import sleep

# TODO  多进程
from multiprocessing import Process
import os
# 演示函数 1 ： 工作量证明
def proof_fo_work():
	&quot;&quot;&quot;
	简单的工作量证明:
         - 查找一个 p' 使得 hash(pp') 以4个0开头
         - p 是上一个块的证明,  p' 是当前的证明
        :param last_proof: &lt;int&gt;
        :return: &lt;int&gt;
	:return:
	&quot;&quot;&quot;
	originHash = hashlib.sha256(&quot;lsy&quot;.encode()).hexdigest()
	print(&quot;Origin Hash：&quot;, originHash)
	proof = 0
	hard = &quot;0&quot;
	while True:
		guessStr = f&quot;{originHash}{proof}&quot;.encode()
		guessHash = hashlib.sha256(guessStr).hexdigest()
		if guessHash[:1] == hard:
			print(&quot;***符合要求***: &quot;, guessHash)
			print(&quot;***Proof***: &quot;, proof)
			sleep(6)
			hard = hard + &quot;0&quot;
		else:
			print(guessHash)
			proof = proof + 1

# 演示函数 2 ： 打印
def t(name):
	print(f&quot;子进程： {name}, {os.getpid()}&quot;)

# 进程的使用： 启动进程分别执行 函数1,2
def use_process():
	print(f&quot;主进程: {os.getpid()}&quot;)
	# 创建test进程
	p = Process(target=t, args=('testProcess',))
	# 创建proof_fo_work 进程
	p2 = Process(target=proof_fo_work)
	p2.start()
	#p2.join()   # 使用之后，p进程将等待p2结束才执行
	print(&quot;启动测试进程&quot;)
	p.start()


</code></pre>
<p>其中 <code>p.join()</code> 表示进程结束后，才会继续执行后续过程。如果该经常死循环了，那么后面的执行步骤将永远不会执行。</p>
<h2 id="创建多个进程-进程池-pool">创建多个进程： 进程池 Pool</h2>
<p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<pre><code>def t(name):
	sleep(1)
	print(f&quot;子进程： {name}, {os.getpid()}&quot;)
	
# 进程池的使用
def pool_process():
	from multiprocessing import Pool
	#如果要启动大量的子进程，可以用进程池的方式批量创建子进程：
	p = Pool(4)  # 4为 CPU 核心数， 四核CPU 最多执行4 ， 大于4 也只执行4个进程
	for i in range(5):
		p.apply_async(t, args=(i,))
	print(&quot;完成全部进程的创建启动&quot;)
	p.close()
	p.join()
</code></pre>
<h2 id="进程通信-生产者消费者queue">进程通信： 生产者+消费者+Queue</h2>
<pre><code># 进程的通信： 多线程 生成者+消费者 Queue 实现
def message_process():
	from multiprocessing import Queue

	q = Queue()

	pw = Process(target=producer, args=(q,))   # 生产进程
	pr = Process(target=consumer, args=(q, &quot;P1&quot;))   # 消费进程 1
	pr2 = Process(target=consumer, args=(q, &quot;P2&quot;))  # 消费进程 2
	pr3 = Process(target=consumer, args=(q, &quot;P3&quot;))  # 消费进程 3
	pr4 = Process(target=consumer, args=(q, &quot;P4&quot;))  # 消费进程 4
	pr5 = Process(target=consumer, args=(q, &quot;P5&quot;))  # 消费进程 5

	pw.start()
	pr.start()
	pr2.start()
	pr3.start()
	pr4.start()
	pr5.start()

	# 等待pw结束:
	pw.join()
	# 队列消费完成 结束进程
	while True:
		if q.qsize() == 0:
			# pr,pr2进程里是死循环，无法等待其结束，只能强行终止:
			pr.terminate()
			pr2.terminate()
			pr3.terminate()
			pr4.terminate()
			pr5.terminate()
			print(&quot;队列数据： &quot;, q.qsize())
			break

 
# 往队列里生产数据
def producer(q):
	import random, time
	print('Hash生成进程: %s' % os.getpid())
	# 生产 100个
	for i in range(100):
		num = random.randint(0, 1000)
		value_hash = hashlib.sha256(str(num).encode()).hexdigest()
		print('生成地址：[ %s ] to queue...' % value_hash)
		q.put(value_hash)  # 数据写入队列


# 消费队列里的数据
def consumer(q,name):
	import random, time
	print('获取地址消费: %s ' % os.getpid())
	while True:
		value = q.get(True)
		print(f'**{name}-读取地址: [ {value} ] from queue.')
		time.sleep(random.random())

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker实践01 -- 图形管理工具Portainer的使用]]></title>
        <id>https://aturx.github.io/post/docker-shi-jian-01-tu-xing-guan-li-gong-ju-portainer-de-shi-yong</id>
        <link href="https://aturx.github.io/post/docker-shi-jian-01-tu-xing-guan-li-gong-ju-portainer-de-shi-yong">
        </link>
        <updated>2020-03-06T08:52:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-解决问题">一、 解决问题？</h1>
<p>Docker 在使用过程中，要在命令行中查看各种信息，非常的不方便，而且管理的效率不高，采用Portainer用来管理Docker和运行的项目足够了。</p>
<h1 id="二-安装并运行-portainer">二、安装并运行 Portainer</h1>
<p>Portainer 不用特意去安装，直接用Docker一行命令去运行就可以了。</p>
<h2 id="dockerhub">DockerHub</h2>
<p><a href="https://hub.docker.com/r/portainer/portainer">DockerHub</a> 上有很多镜像包可以直接使用，也包括Portainer的镜像。</p>
<p>执行命令，先把镜像获取到本地：</p>
<pre><code>docker pull portainer/portainer
</code></pre>
<p>运行 Portainer：</p>
<pre><code>
$ docker volume create portainer_data

//创建一个portainer_data文件夹存储你容器的相关数据
//一般它的地址是在： /var/lib/docker/volumes

$ docker run -d -p 9000:9000 -p 8000:8000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer


//其他参数暂时不用修改，就按照官方命令进行启动就可以了

</code></pre>
<h1 id="三-在线演示">三、在线演示</h1>
<p>你可以在线查看效果</p>
<p>访问地址:  http://demo.portainer.io/</p>
<p>用户名：<code>admin</code><br>
密码  ：<code>tryportainer</code></p>
<h1 id="参考">参考</h1>
<p><a href="https://portainer.readthedocs.io/en/latest/deployment.html">更多部署信息</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网站流量统计功能添加]]></title>
        <id>https://aturx.github.io/post/wang-zhan-liu-liang-tong-ji-gong-neng-tian-jia</id>
        <link href="https://aturx.github.io/post/wang-zhan-liu-liang-tong-ji-gong-neng-tian-jia">
        </link>
        <updated>2020-03-04T06:26:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-站长统计的选择">😁一、站长统计的选择</h1>
<p>想要查看网站的访问量，可以给网站进行网站统计。先对网站统计的工具选择：因为网站是国内访问，选择百度统计比较合适。</p>
<p>访问地址：<a href="https://tongji.baidu.com">百度流量统计</a></p>
<p>还有另一个，网站直接统计的js脚本也可以使用，需要添加到网页中，好处是可以显示用户访问量在页面。</p>
<p>访问地址： <a href="https://busuanzi.ibruce.info/">不蒜子访问量展示</a></p>
<h1 id="二-添加网站统计">😁二、添加网站统计</h1>
<h2 id="百度统计方式">百度统计方式</h2>
<p>基本过程是：</p>
<ol>
<li>
<p>首页注册登录</p>
</li>
<li>
<p>添加自己的网站域名</p>
</li>
<li>
<p>复制生成好的js代码片段</p>
</li>
<li>
<p>将代码添加到自己的网站页面中</p>
</li>
<li>
<p>20分钟后可查看页面的流量统计</p>
</li>
</ol>
<p>web4web.top 统计代码添加 :</p>
<pre><code>&lt;script&gt;
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement(&quot;script&quot;);
  hm.src = &quot;https://hm.baidu.com/hm.js?13ea7e585ad4fa34100390e5a6862c52&quot;;
  var s = document.getElementsByTagName(&quot;script&quot;)[0]; 
  s.parentNode.insertBefore(hm, s);
})();
&lt;/script&gt;

</code></pre>
<p>lisiyi.top 统计代码添加 ：</p>
<pre><code>&lt;script&gt;
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement(&quot;script&quot;);
  hm.src = &quot;https://hm.baidu.com/hm.js?5f536360cba2bd2691929ab1dfc08c55&quot;;
  var s = document.getElementsByTagName(&quot;script&quot;)[0]; 
  s.parentNode.insertBefore(hm, s);
})();
&lt;/script&gt;
</code></pre>
<h2 id="不蒜子方式">不蒜子方式</h2>
<p>参考：<br>
<a href="https://liam.page/2017/04/29/busuanzi-offset-setting/">数值初始化</a></p>
<p>不蒜子 参考代码片段：</p>
<pre><code>  &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;
&lt;span id=&quot;busuanzi_container_site_uv&quot; style='display:none'&gt;
本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt;| 
    Powered by &lt;a href=&quot;https://github.com/aturX&quot; target=&quot;_blank&quot;&gt;AturX&lt;/a&gt; 
</code></pre>
]]></content>
    </entry>
</feed>