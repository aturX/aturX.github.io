<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lianqiujun.co</id>
    <title>链 求 君 | 区 块 链</title>
    <updated>2021-01-08T05:45:07.553Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lianqiujun.co"/>
    <link rel="self" href="https://lianqiujun.co/atom.xml"/>
    <subtitle>实践更多区块链项目，探索更多Web3可能性！</subtitle>
    <logo>https://lianqiujun.co/images/avatar.png</logo>
    <icon>https://lianqiujun.co/favicon.ico</icon>
    <rights>All rights reserved 2021, 链 求 君 | 区 块 链</rights>
    <entry>
        <title type="html"><![CDATA[刻意练习]]></title>
        <id>https://lianqiujun.co/post/ke-yi-lian-xi</id>
        <link href="https://lianqiujun.co/post/ke-yi-lian-xi">
        </link>
        <updated>2021-01-08T05:42:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="刻意练习">刻意练习</h1>
<p>在哪里用，就在那里学。</p>
<h2 id="1-有目的的练习">1.  有目的的练习</h2>
<p>第一步，有目的的练习具有定义明确的特定目标，明确的目标将会引导正确的练习。</p>
<p>第二步，分解目标，并设定具体的计划执行。搞懂要如何做，怎么样做，做什么才能实现具体目标。</p>
<p>第三步，必须有反馈，有目的的练习必须包含反馈，必须知道自己做的对还是不对。如果不对，到底是做错了什么？</p>
<p>第四步，保持动力。 一些保持动力的方法，能够让你坚持艰苦的练习。看到自己的进步、获得相应的奖励、外界对你的改观、自身的专注力等</p>
<h2 id="2-构建心理表征">2.  构建心理表征</h2>
<p>心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物相对应的心理结构，或具体或抽象。<br>
大多数的刻意练习包括创建更加有效的心理表征，不论你在练习什么，都可以使用这<br>
些心理表征。</p>
<p>第一步，为心理表征的概念创建心理表征，去接触、了解、感受它。</p>
<p>第二步，找到黄金标准。所有领域中，一些训练方式总会比另一些更有效。</p>
<p>有目的的练习：首先辨别杰出人物，然后推测是什么使他们变得如此杰出，接着再提出训练方法，这些方法使你也能像他们那样表现卓越。</p>
<p>牢牢记住所有这些，目的是使你知道有目的的练习，并且为你指出更有效的方向。如果你发现某种方法管用，继续做下去；如果不管用，马上停下来。你越是能够调整自己的练习方法，模仿所在行业或领域中最杰出的人物，那你的练习也可能越是有效。</p>
<h2 id="3-训练技能">3. 训练技能</h2>
<p>刻意练习的心态提供了截然不同的观察视角：任何人都可以进步，但需要正确的方法。如果你没有进步，并不是因为你缺少天赋，而是因为你没有用正确的方法练习。一旦你理解了这一点，进步就只取决于你想出什么是“正确的方式”了。<br>
与传统不同的是，刻意练习的关键在于你能做什么，而不是你知道什么。 这同样是技能和知识之间的区别，普通的学习方法过度重视知识的学习，而轻视技能的训练，但是即便具备了相当多的知识，依然需要投入大量训练从而掌握技能的。<br>
如果你想提高棋艺，只和别人下棋，无法提高；你要单独研究特级大师的棋局，才可能提高。如果你想提高掷飞镖的技能，到酒店里和朋友玩，然后让输了的一方掏钱，水平不会提高；你只有花些时间单独练习，致力于复制你投掷成绩最好的那些投掷动作，才能提高。你可以系统地改变瞄准的飞镖靶上的不同点来提高你的控制水平。如果你想提高自己的保龄球技能，每周星期二晚上和你的保龄球联盟球队在一起玩，对你没什么帮助。你需要花一些时间和高水平的队友在一起，理想的情况是，致力于做一些艰难的球形排列，以便能够准确地控制球的走位，才是关键。依此类推。</p>
<h2 id="4-自己设计练习方法">4. 自己设计练习方法</h2>
<p>没有导师的时候，有效练习某种技能，需要三步即：专注、反馈、纠正。（研究大师级的资料）<br>
将技能分解成一些组成部分，以便反复地练习，并且有效地分析、确定你的不足之处，然后想出各种办法来解决它们。<br>
跨越停滞阶段，当不再进步的时候，需要找到停滞的原因，分析并制定攻克特定弱点的练习计划，最后尝试执行。</p>
<h2 id="5-保持动机">5. 保持动机</h2>
<p>有两种角度，让自己保持动机。<br>
第一， 弱化停下脚步的理由。 通过预留固定的练习时间，让自己在特定的时间段可以专注的练习，提前减少其他事情的干扰。不然，总会陷入无尽繁琐事的泥潭中。</p>
<p>第二， 增强前行的动机。通过参与团体或组织中，实现共同激励的目的。外在因素是影响最大是一种原因，包括得到别人的认同，荣誉，赞扬，名气等等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 简单实现PoW、PoS、DPoS 算法]]></title>
        <id>https://lianqiujun.co/post/python-jian-dan-shi-xian-powposdpos-suan-fa</id>
        <link href="https://lianqiujun.co/post/python-jian-dan-shi-xian-powposdpos-suan-fa">
        </link>
        <updated>2021-01-06T08:33:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="pow-简介">PoW 简介</h1>
<p>共识机制： 工作量证明（PoW）</p>
<h1 id="pow-实现">PoW 实现</h1>
<pre><code>from datetime import datetime
import hashlib

# 简单实现 PoW共识算法

NodesCount = 7

class Blockchain(object):
	def __init__(self, nodeAddress):
		self.globalBlocks = []
		self.nextBlock = None
		self.difficulty = 1
		self.height = 0
		self.nodeAddress = nodeAddress

	def generateBlock(self):
		Timestamp = str(datetime.now())
		if self.globalBlocks &gt; 0:
			PrevHash = self.globalBlocks[-1].Hash
		else:
			self.generateFirstBlock()
			return
		Hash = hashlib.sha256((PrevHash + Timestamp).encode(&quot;utf-8&quot;)).hexdigest()
		NodeAddress = self.nodeAddress
		Data = &quot;new block&quot;
		self.nextBlock = Block(Timestamp, PrevHash, Hash, NodeAddress, Data)


	def generateFirstBlock(self):
		Timestamp = str(datetime.now())
		PrevHash = &quot;0x0&quot;
		Hash = hashlib.sha256((PrevHash + Timestamp).encode(&quot;utf-8&quot;)).hexdigest()
		NodeAddress = self.nodeAddress
		Data = &quot;Start PoW Blockchain&quot;
		self.globalBlocks.append(Block(Timestamp, PrevHash, Hash, NodeAddress, Data))

	def isBlockHashMatchDifficulty(self,hashStr, difficulty) -&gt; bool:
		prefix = difficulty * &quot;0&quot;
		return prefix == hashStr[:difficulty]

	def confirmed_next_block(self):
		if self.isBlockHashMatchDifficulty(self.nextBlock.Hash, self.difficulty):
			self.nextBlock.Confirmed = self.nextBlock.Confirmed + 1

	def pow_add_next_block(self, otherNodeBlockchain):
		if otherNodeBlockchain.nextBlock.Confirmed &gt; self.nextBlock.Confirmed:
			self.globalBlocks = otherNodeBlockchain.globalBlocks
			self.nextBlock = otherNodeBlockchain.nextBlock

		if self.nextBlock.Confirmed &gt; NodesCount / 2:
			# 半数节点确认通过
			self.globalBlocks.append(self.nextBlock)


class Block(object):
	def __init__(self, Timestamp, PrevHash, Hash, NodeAddress, Data):
		self.Timestamp = Timestamp
		self.PrevHash = PrevHash
		self.Hash = Hash
		self.NodeAddress = NodeAddress
		self.Data = Data
		self.Confirmed = 0

	def __str__(self):
		print(&quot;-&quot;*30)
		return f&quot;Timestamp = {self.Timestamp},\nPrevHash = {self.PrevHash},\nHash = {self.Hash},\nNodeAddress = {self.NodeAddress},\nData = {self.Data}&quot;



def test_isBlockHashMatchDifficulty():
	hashStr = 'a1534392279bddbf9d43dde8701cb5be14b82f76ec6607bf8d6ad557f60f304e'
	difficulty = 1

	print(Blockchain(0).isBlockHashMatchDifficulty(hashStr, difficulty))


def test_blockchain1():
	blockchain = Blockchain(0)

	blockchain.generateFirstBlock()

	print(blockchain.globalBlocks[0].__str__())

def test_blockchain2():
	blockchain = Blockchain(1)
	blockchain.generateFirstBlock()
	blockchain.generateBlock()


if __name__ == &quot;__main__&quot;:
	test_isBlockHashMatchDifficulty()
	test_blockchain1()
</code></pre>
<h1 id="pos-简介">PoS 简介</h1>
<h1 id="pos-实现">PoS 实现</h1>
<pre><code>import hashlib
from random import randint

# 简单实现PoS 共识算法

nextBlocks = ['1a6562590ef19d1045d06c4055742d38288e9e6dcd71ccde5cee80f1d5a774eb']

class Block(object):
	def __init__(self, Timestamp, PrevHash, Hash, NodeAddress, Data):
		self.Timestamp = Timestamp
		self.PrevHash = PrevHash
		self.Hash = Hash
		self.NodeAddress = NodeAddress
		self.Data = Data
		self.Confirmed = 0

	def __str__(self):
		print(&quot;-&quot;*30)
		return f&quot;Timestamp = {self.Timestamp},\nPrevHash = {self.PrevHash},\nHash = {self.Hash},\nNodeAddress = {self.NodeAddress},\nData = {self.Data}&quot;


def getCoinBalance(block, NodeAddress):
	# 随机返回一个值当余额， 只做演示
	return randint(0, 100)

def getNodeAddress():
	# 随机返回一个地址， 只做演示
	num = str(randint(0, 100))
	address = hashlib.sha256(num.encode(&quot;utf-8&quot;)).hexdigest()

	return address

stackRecord = []
def AddressNodeRun():
	NodeAddress = getNodeAddress()
	for block in nextBlocks:
		coinNum = getCoinBalance(block, NodeAddress)  # 币数量
		for i in range(coinNum):
			stackRecord.append(NodeAddress)
AddressNodeRun()  # 节点一
AddressNodeRun()  # 节点二
AddressNodeRun()  # 节点三
print(stackRecord)

# 然后 ，随机从 stackRecord 中 随机选一个地址，作为胜利者，币越多， 股权越大，被选中概率越大

winner = stackRecord[randint(0, len(stackRecord))]

print(winner)

</code></pre>
<h1 id="dpos-简介">DPoS 简介</h1>
<h1 id="dpos-实现">DPoS 实现</h1>
<pre><code># DPoS 共识算法 简单实现

# 引入 见证者 节点
import hashlib
from random import randint

# 见证人数量 N
N = 3

class WitnessNode(object):
	def __init__(self, NodeAddress):
		self.NodeAddress = NodeAddress


def getNodeAddress():
	# 随机返回一个地址， 只做演示
	num = str(randint(0, 100))
	address = hashlib.sha256(num.encode(&quot;utf-8&quot;)).hexdigest()
	return address

class Block(object):
	def __init__(self):
		self.Votes = randint(0, 100)
		self.Timestamp = None
		self.PrevHash = None
		self.Hash = None
		self.NodeAddress = getNodeAddress()
		self.Data = None


# 当前见证人列表
WitnessList = [
Block(),
Block(),
Block()
]

NodeLists = [
Block(),
Block(),
Block(),
Block(),
Block(),
Block(),
Block()
]

# 投票选选择见证者
def vote():
	for block in NodeLists:
		vote = randint(0, 100)
		block.Votes = vote

	# 根据 票数 排序 , 找到最多的一个点
	maxVote = 0
	nextWitness = NodeLists[0]
	for block in NodeLists:
		if block.Votes &gt; maxVote:
			maxVote = block.Votes
			nextWitness = block

	return nextWitness


# 增加新 见证者
def addNewWitness():
	nextWitness = vote()
	WitnessList.append(nextWitness)

	print(&quot;新投票选举后，见证人列表：&quot;)
	for one in WitnessList:
		print(one.NodeAddress, &quot;票数：&quot;, one.Votes)


# 踢出 见证者中坏节点
def removeBadWitness():

	if len(WitnessList) &gt; N:
		# 排序踢出最低点
		minVote = 100
		badWitnessIndex = 0
		for index, block in enumerate(WitnessList):
			if block.Votes &lt; minVote:
				minVote = block.Votes
				badWitnessIndex = index
		print(&quot;投票数最少：&quot;, minVote)
		WitnessList.pop(badWitnessIndex)

	print(&quot;新见证人列表： &quot;)
	for one in WitnessList:
		print(one.NodeAddress, &quot;票数：&quot;, one.Votes)



addNewWitness()
removeBadWitness()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用工具手册]]></title>
        <id>https://lianqiujun.co/post/chang-yong-gong-ju-shou-ce</id>
        <link href="https://lianqiujun.co/post/chang-yong-gong-ju-shou-ce">
        </link>
        <updated>2021-01-06T07:57:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="命令">命令</h1>
<ul>
<li>
<p><a href="https://lianqiujun.co/post/git%E5%91%BD%E4%BB%A4/">Git 命令</a></p>
</li>
<li>
<p><a href="https://lianqiujun.co/post/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/">IDEA 快捷键</a></p>
</li>
<li>
<p><a href="https://lianqiujun.co/post/Linux%E5%91%BD%E4%BB%A4/">Linux 命令</a></p>
</li>
<li>
<p><a href="https://lianqiujun.co/post/mac%E5%91%BD%E4%BB%A4/">Mac 命令</a></p>
</li>
<li>
<p><a href="https://lianqiujun.co/post/vim%E5%91%BD%E4%BB%A4/">Vim 命令</a></p>
</li>
<li>
<p><a href="https://lianqiujun.co/post/Markdown%E8%AF%AD%E6%B3%95/">Markdown 语法</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程要素：函数和数据]]></title>
        <id>https://lianqiujun.co/post/bian-cheng-yao-su-han-shu-he-shu-ju</id>
        <link href="https://lianqiujun.co/post/bian-cheng-yao-su-han-shu-he-shu-ju">
        </link>
        <updated>2021-01-06T07:13:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://docs.python.org/zh-cn/3.8/library/index.html">Python 官方文档</a><br>
| <a href="http://composingprograms.com/pages/12-elements-of-programming.html">教程文档</a></p>
<h2 id="函数和数据">函数和数据</h2>
<p>计算机编程语言的作用，除了让计算机执行一些任务以外。更大的作用是整理计算过程，并且表达出编程者思想以供其他人阅读。<br>
所以，<strong>程序主要是写给人看的，恰好还能够让机器执行。</strong></p>
<p>“将简单的想法，通过组合成更复杂的想法，是编程语言的核心”  --- 抽象</p>
<p>任何一门功能强大的编程语言，都具有以下三种机制：</p>
<ul>
<li>“基本表达式”和“语句”： 表示语言提供的最简单的语法</li>
<li>“组合”手段： 通过这些手段可以从简单的元素构建复合元素</li>
<li>“抽象”手段： 通过该手段可以将复合元素命名给变量并进行操作</li>
</ul>
<h3 id="11-什么是表达式">1.1 什么是&quot;表达式&quot;？</h3>
<p>每一门语言都有它最原始的表达式，比如数字。</p>
<pre><code># 数字
&gt;&gt;&gt; 42 
42

&gt;&gt;&gt; 1 + 1 
2 

# 运算符和标记符号 
+ - * / &gt; &lt;  
{} [] ''  &quot;&quot;
# 保留字
if  for  while 


</code></pre>
<h3 id="12-什么是调用表达式">1.2 什么是&quot;调用表达式&quot;?</h3>
<p>复合表达式中，最重要的一种是：调用表达式<br>
它将一个函数对某些参数进行一些特定的处理。</p>
<pre><code>a = max(4,5)  # a = 5
b = min(3,9)  # b = 3 
c = str(3)    # c = '3'
</code></pre>
<h3 id="13-库函数">1.3 库函数</h3>
<ul>
<li>库函数，就是许多函数被组合在各种模块中，然后这些模块共同构成了Python的库</li>
<li>Python标准库， 就是安装Python时一起被安装的库函数，可以直接import然后使用</li>
<li>第三方库， 根据需求不同，自行下载导入的第三方写好的库函数包。</li>
</ul>
<p>详细的内容可以参考：<br>
<a href="https://docs.python.org/zh-cn/3.8/library/index.html">Python 官方文档</a></p>
<h3 id="21-变量与环境">2.1 变量与环境</h3>
<p>编程语言中，如果要对一些值进行计算操作，会使用变量作为值的引用。给定一个值的变量名，就是将这个值绑定给这个变量了。</p>
<pre><code>&gt;&gt;&gt; radius = 10
&gt;&gt;&gt; radius
10

&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; pi * 71 / 223
1.0002380197528042
</code></pre>
<p>= ,即赋值号。是最简单的“抽象”方式，可以通过赋值号，将一系列复合运算的结果值与某个变量绑定，完成一次简化的过程。</p>
<p>通过上述的方式： 计算机完成将变量的值绑定在变量上，然后通过访问这些变量来获取其对应的值。<br>
这意味着，解释器/编译器必须维护某些内存，以保证维持“变量”与“值”直接这样的绑定关系，这就是程序的运行“环境”。</p>
<h3 id="22-解析表达式与表达树">2.2 解析表达式与表达树</h3>
<p>多个基础的表达式，通过嵌套组合成复杂表达式，再由复杂的表达式，逐层拆解为基础表达式，这个过程类似一颗倒立的树木。<br>
表达树：<br>
max(min(a,b), max(c,d))</p>
<p>↓</p>
<p>max() → min(a,b), max(c,d)</p>
<p>↓</p>
<p>min() → a,b 和 max() → c,d</p>
<p>↓</p>
<p>a,b,c,d</p>
<p>直到不可拆分，就达到了树的节点，也就是最基础的表达式了。</p>
<pre><code>x = 3

sum(x,1)
</code></pre>
<p>每一行代码，只会执行得的两种结局： 1.执行过程 2.解析表达式</p>
<pre><code>x = 3 # 此时单纯的“赋值” ， 对“环境” 中的值不做影响， 不产生任何新的结果

y = sum(x,1) # 表达式解析后，对“环境”中的“值”： x 对应的值3 进行 加法运算，加1后，新的结果值从函数中返回并绑定给变量名y
</code></pre>
<h3 id="23-纯功能函数">2.3 纯功能函数</h3>
<p>纯函数就是有一些输入值，经过函数处理后，返回一些输出值。而且使用同样的值调用同一个函数两次，返回的值都是相同的。<br>
纯函数更加容易测试，而且可以更加稳定的构建复合表达式。</p>
<h3 id="24-非纯功能函数">2.4 非纯功能函数</h3>
<p>非纯函数就是除了会返回值以外，还会有其他的行为，比如“打印”或者“文件生成”，总之可能会造成计算机状态发生变化的行为。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程要素：入门]]></title>
        <id>https://lianqiujun.co/post/bian-cheng-yao-su-ru-men</id>
        <link href="https://lianqiujun.co/post/bian-cheng-yao-su-ru-men">
        </link>
        <updated>2021-01-06T07:03:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://pythontutor.com/composingprograms.html#mode=edit">在线环境</a> |<br>
<a href="https://docs.python.org/zh-cn/3.8/">Python文档</a></p>
<h3 id="1-抽象是什么">1. 抽象是什么？</h3>
<p>抽象就是人对世间万物的一种感受，通过符号表达出来的过程。就像&quot;红色&quot;就是一个抽象的概念，你脑海中不存在&quot;色彩&quot;这种概念的时候，它就是一个很抽象的东西，当我们第一次接触&quot;红色&quot;这个词语时，并不清楚，&quot;红色&quot;是甜的，酸的，软的，硬的？还是说是一种&quot;颜色&quot;，这是通过我们在生活中不断的从周围的环境中慢慢感知出来的。</p>
<p><strong>简单来说，抽象就是将内心的感受使用一种特定的符号表示出来的”过程“。</strong></p>
<p><strong>数学</strong> 就是一门抽象的学科， 0,1,2,3,4,+,-,*,=,&gt;,&lt; 这些符号本身是没有意义的，他们是一种抽象的表现，就像我们前面提到的“红色”。 人有2只眼睛，1个嘴巴，这里的“数量” 是人类对生活的观察和感受，“2”，“1”则是人类对“数量”的抽象符号表示。</p>
<h3 id="2-数学为什么是抽象的">2. 数学为什么是抽象的？</h3>
<p>数学的发展史告诉我们，数学起源于“算”，即起源于物体个数、田亩面积、物体长度等的计算。要计算就要有计算方法，当各种计算方法积累到一定数量的时候，数学家就进行分类，抽象出某类问题的计算公式、法则、原理，统称为算法。所以数学的童年时期叫做算术，它表现为一种经验知识。</p>
<h3 id="3-计算机和编程与抽象的关系">3. 计算机和编程与抽象的关系</h3>
<p>通过理解了抽象是什么，应该明白：<strong>“编程语言”不应该是你要学习的东西，而是用来理解表达你经验知识的工具。</strong><br>
计算机，则是你掌握和控制这些抽象概念的一个机器。<br>
如果做比喻的话:</p>
<ul>
<li>“1,2,3,4” 经过人脑的转换，被理解成人脑海中所理解的“数量”</li>
<li>“编程语言” 经过计算机的转换，变成了计算机执行的一系列“操作”</li>
</ul>
<p>而“编程”就是，人类将自己对于世界的感受，用自己能够理解的方式整理之后（算法+数据结构），然后通过语言符号和基本规则（a,b,c,d,1,2,3,4，+，-，%）抽象成计算机能够理解和执行的程序代码。</p>
<h3 id="4-编程语言">4.  编程语言</h3>
<p>不同的编程语言，有着自己的规范或是规则。但是它们的本质是一样的，就是对数学计算的抽象。我们采用的编程语言Python，就是一种“简单”的编程语言，为什么说它简单，就是因为Python的抽象更加接近人类理解的语言“英语”。</p>
<ul>
<li>注意：人类的语言“汉语”，“英语”也是一种抽象的表现。</li>
</ul>
<p>“红” 和 “red” 只是两个不同的符号，但它们的意义是一样的。<br>
就像Java中的“true” 和 Python中的“True”，代表的意义没什么不同。</p>
<h3 id="5-实践">5. 实践</h3>
<pre><code>from urllib.request import urlopen    # (2)

# 计算机程序只干两件事：
# (1) 计算一些值    
# (2) 执行一些动作

# 后面用符号标记每行代码的功能： （1），（2）

tianqi = urlopen('http://t.weather.sojson.com/api/weather/city/101020100')  # (2)

# 一、 什么是函数（function） ？
# 函数就是将处理数据的过程封装起来，“抽象”成一个符号来代替这些过程。
# urlopen() 就是Python库中的一个函数，url网址是一条数据，返回的结果
# 是另外一条数据,也就获得了内容，简化： B = urlopen(A)  
# 这就用了简单的一句话完成了一些动作，而复杂的过程存在于函数中。
# 这里将这些复杂过程抽象成一个函数名“urlopen”

data = set(tianqi.read().decode().split(',')) # (1)

# 二、 什么是对象（object）？
# set() 函数中经过 read() decode() split() 等一系列函数的复杂计算
# 最终得到data （对象），将“数据”和“处理数据的逻辑”紧密的联系在一起
# 最终简化： C = set(B)    B是开始的数据，C是“抽象”处理后的数据。


result = [w for w in data if len(w) &gt; 0]    # (2)

# 三、 计算机如何理解程序？解释器 （Interpreters）
# 语法中的表达式： result是经过了语言特定的表达式，获得的数据。
# 而在不同的编程语言，可能会有着各自的语法规则（特色）
# 那么计算机是如何理解不同的编程语言的？ 解释器/编译器
# Python、Java、Go、C# 每种语言都有自己特定的解释器。


# 最后， 我们将发现所有这些核心概念都是紧密相关的：
# 函数就是对象，对象就是函数，解释器是两者的实现表达的过程。
# 这些概念的清晰理解对于掌握编程技术至关重要。

</code></pre>
<h3 id="6-学习">6. 学习</h3>
<ul>
<li>实例1  双指针法</li>
</ul>
<pre><code>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1:
给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。
示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}


class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        # 先排序
        nums.sort()
        i = 0
        while i &lt; len(nums) - 1:
            if nums[i] == nums[i + 1]:
                nums.remove(nums[i])
            else:
                i = i + 1
        return len(nums)


</code></pre>
<ul>
<li>实例2  哈希表遍历</li>
</ul>
<pre><code>&quot;&quot;&quot;
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum

&quot;&quot;&quot;

class Solution:
    def twoSum(self, nums: list, target: int) -&gt; list:
        nl = []
        k = {}
        if len(nums) &lt; 2:
            return []
        elif (len(nums) == 2) and (target == nums[0] + nums[1]):
            return [0, 1]

        for i in range(len(nums)):
            k[nums[i]] = i

        for i in range(len(nums)):
            c = target - nums[i]  # 差值
            if (c in nums) and (k[c] != i):
                # 添加下标
                nl.append(k[c])
                nl.append(i)
        nl = list(set(nl))
        return nl

nums = [3, 2, 3]
target = 6
# [0, 2]
r = Solution().twoSum(nums, target)
print(r)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 编程要素]]></title>
        <id>https://lianqiujun.co/post/python-bian-cheng-yao-su</id>
        <link href="https://lianqiujun.co/post/python-bian-cheng-yao-su">
        </link>
        <updated>2021-01-06T07:01:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目录">目录</h1>
<h2 id="1-入门">1. <a href="#">入门</a></h2>
<h2 id="2-函数和数据">2. <a href="#">函数和数据</a></h2>
<h2 id="3-定义新功能">3. <a href="#">定义新功能</a></h2>
<h2 id="4-设计功能">4. <a href="#">设计功能</a></h2>
<h2 id="5-控制">5. <a href="#">控制</a></h2>
<h2 id="6-高阶函数">6. <a href="#">高阶函数</a></h2>
<h2 id="7-递归函数">7. <a href="#">递归函数</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 快速上手]]></title>
        <id>https://lianqiujun.co/post/golang-kuai-su-shang-shou</id>
        <link href="https://lianqiujun.co/post/golang-kuai-su-shang-shou">
        </link>
        <updated>2021-01-06T06:41:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="参考">参考</h2>
<ul>
<li>
<p><a href="https://draveness.me/golang-101/">如何写出优雅的 Go 语言代码</a></p>
</li>
<li>
<p><a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">Go 语言设计与实现</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/go/go-tutorial.html">Go 语言教程</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 常见问题汇总]]></title>
        <id>https://lianqiujun.co/post/golang-chang-jian-wen-ti-hui-zong</id>
        <link href="https://lianqiujun.co/post/golang-chang-jian-wen-ti-hui-zong">
        </link>
        <updated>2021-01-06T06:37:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="语法问题">语法问题</h1>
<ol>
<li>变量定义简写</li>
</ol>
<p><code>:=</code> 只能在函数内部使用，如果声明全局变量需要使用<code>var</code>关键字,否则会出现报错，例如 <code>syntax error: non-declaration statement outside function bod</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开发利器：快速构建 Flow Dapp]]></title>
        <id>https://lianqiujun.co/post/kai-fa-li-qi-kuai-su-gou-jian-flow-dapp</id>
        <link href="https://lianqiujun.co/post/kai-fa-li-qi-kuai-su-gou-jian-flow-dapp">
        </link>
        <updated>2020-12-15T14:26:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="decentology介绍">Decentology介绍</h2>
<p>Decentology是一个帮助开发者快速进行Dapp构建的网站，可以在10分钟内构建一套全栈Dapp应用程序。</p>
<p>当我们开始学习一个新的，可扩展的应用程序时，都会想获得一些“快速可见的效果”。也就是说，我想进行一些细微的细微更改，以查看该应用程序是否正常运行，并且期望并查看我的操作是如何进行的。结果通常是需要花费不少时间，才能将应用程序正常的运行起来。但是，正确的学习方法，应该是尽可能的缩短反馈周期，进行一些小的更改并获得这些“快速的胜利”不可避免地会帮助我们学习并拥有更多的理解。</p>
<p>这正是我推荐的Decentology要尝试帮助我们做的事情：</p>
<ul>
<li><a href="https://dappstarter.decentology.com/">Decentology</a></li>
</ul>
<h2 id="flow-dapp-的快速构建">Flow Dapp 的快速构建</h2>
<p>该网站已经免费提供了基于Flow的项目生成，步骤十分简单：</p>
<ul>
<li>第1步，智能合约栈</li>
</ul>
<p>DappStarter是用于区块链的全栈开发环境。它支持您选择的区块链和区块链语言，并在您选择客户端框架时提供集成的前端用户体验。</p>
<figure data-type="image" tabindex="1"><img src="https://lianqiujun.co/post-images/1608042585291.jpg" alt="" loading="lazy"></figure>
<ul>
<li>第2步，智能合约功能</li>
</ul>
<p>您选择的功能将为您提供定制的智能合约，以获取应用程序所需的一切。</p>
<figure data-type="image" tabindex="2"><img src="https://lianqiujun.co/post-images/1608042597635.jpg" alt="" loading="lazy"></figure>
<ul>
<li>第3步，Dapp定制</li>
</ul>
<p>量身定制适合你业务的区块链应用</p>
<figure data-type="image" tabindex="3"><img src="https://lianqiujun.co/post-images/1608042610399.jpg" alt="" loading="lazy"></figure>
<ul>
<li>第4步，生成应用仓库</li>
</ul>
<p>最终全栈源码会被生成在Github 仓库， 开发者可以自行下载至本地，运行开发。</p>
<figure data-type="image" tabindex="4"><img src="https://lianqiujun.co/post-images/1608042677675.jpg" alt="" loading="lazy"></figure>
<p>项目仓库：<br>
<em>Github： https://github.com/DappStarter</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[译] 面向资源编程：更好的数字所有权模型]]></title>
        <id>https://lianqiujun.co/post/yi-mian-xiang-zi-yuan-bian-cheng-geng-hao-de-shu-zi-suo-you-quan-mo-xing</id>
        <link href="https://lianqiujun.co/post/yi-mian-xiang-zi-yuan-bian-cheng-geng-hao-de-shu-zi-suo-you-quan-mo-xing">
        </link>
        <updated>2020-12-15T13:48:03.000Z</updated>
        <content type="html"><![CDATA[<p>软件工程师们经常使用“所有权”一词，用来表示，某块代码负责管理某种数据结构或系统资源。这种隐喻在编程环境中最为普遍，在这种环境中，内存管理并非是从程序员那里抽象出来的，所谓的代码“拥有”一个对象，就是说代码有权管理并释放分配给该对象的内存。</p>
<p>但是，当我们在其他任何情况下谈论“所有权”时，通常是在谈论具有持久价值的资产，而不是短暂的数据结构。尽管可以使用现有的编程环境来跟踪资产的所有权，但是它们通常用于反映所有权，而不是直接定义资产的所有权。公链区块链的独特之处在于，它们明确设计用于管理真正稀缺和完全访问控制的数字资产所有权。诸如比特币或Flow之类的公链区块链上的数字资产应表现得像有形资产：不得复制或伪造，只能转让。</p>
<p>随着区块链的发展，代表所有权的机制也发生了变化。比特币是使用“未用交易输出”或称之为 UTXO 的所有权模型构建的。虽然 UTXO 模型非常高效，但它很复杂并且会创建一些异常的边缘情况，因此以太坊采用了更灵活的分类账模型。不幸的是，以太坊模型几乎没有针对编程出现的错误进行保护措施，导致程序的错误造成加密货币社区损失了超过1亿美元的资金。</p>
<p>理想情况下，旨在管理数字所有权的编程语言应包括数字资产的本身的表示形式，并具有防止破坏价值的错误的内置保护措施。</p>
<h2 id="cadence-介绍一种高级的面向资源的编程语言">Cadence 介绍，一种高级的面向资源的编程语言</h2>
<p>去年，在对更好的智能合约语言进行学术研究之后，Flow团队正在研究在区块链环境中使用线性类型。而几乎在同一时间，Libra 团队发布了最初的公告，其中包括MoveVM的技术细节。</p>
<p>Libra 团队基于线性类型的启发，构建了新所有权模型：<strong>资源（Resource）</strong>，为 Move 定义了新的编程模型。资源是一种直接用编程语言表示资产所有权和启用加密数字资产属性的新方法。</p>
<p>关于Move的简介：</p>
<p>Move 的主要功能是能够定义自定义资源类型。资源类型用于对具有丰富可编程性的安全数字资产进行编码。</p>
<p>资源导向编程的强大功能令我们震惊，它是 Cadence 的核心功能之一，而 Cadence 正是我们为 Flow 开发的智能合约编程语言。</p>
<p>作为第一种高级的面向资源的编程语言，Cadence 具有舒适的，符合人体工程学的语法，非常易于阅读。它使用强大的静态类型系统来最大程度地减少运行时错误，并允许所有方法，接口和事务包含前置条件和后置条件以强制执行预期的行为。我们认为，这将导致一种语言，比任何其他替代方法更易于学习，更易于审核，最终最终将提高生产力。</p>
<p>您可以在<a href="https://play.onflow.org/">Flow Playground</a> 上体验 Cadence。</p>
<h2 id="面向资源的编程如何工作">面向资源的编程如何工作？</h2>
<p>资源提供了比 EVM 或 WASM 更丰富的可组合性选项，并且非常适合数字资产。将某物标记为“资源”可以告诉编程环境，该数据结构代表某种有形的价值，并且与该数据结构交互的所有代码都需要遵循一系列特殊规则，以保持该数据结构的价值。</p>
<p>那么，这些规则是什么？</p>
<ul>
<li>
<p>每个资源在任何给定时间都恰好存在于一个地方。</p>
</li>
<li>
<p>不能通过编程错误或恶意代码来复制或意外删除资源。</p>
</li>
<li>
<p>资源的所有权由其存储位置定义。无需参考中央分布式帐本的方式来确定所有权。</p>
</li>
<li>
<p>对资源上方法的访问仅限于所有者。例如，只有CryptoKitty的所有者才能发起繁殖操作，从而导致新Kitty的诞生。</p>
</li>
<li>
<p>仅仅由编译器强制执行资源（Resource）对象的特殊状态是不够的。这些代码还必须在链上执行时强制执行。如果没有链上运行时的支持，攻击者很容易使用被篡改过的编译器绕过确保资源安全的规则。</p>
</li>
</ul>
<p>然而，如果确实的正确执行了这些规则，则可以确保将区块链网络中最重要的资产，安全地存储在由用户提交的代码控制的数据结构中。这样做的确很强！</p>
<h2 id="我们来看个例子">我们来看个例子！</h2>
<p>理解资源（Resource）的最简单方法是通过使用诸如谜恋猫（CryptoKitty） 之类的非同质化通证（NFT）作为示例思考。每个谜恋猫（CryptoKitty） 是不可分割的，不可复制的，并且可以有一个直接所有者，该所有者直接与 Resource 数据结构相匹配。</p>
<p>在以太坊等账本模型中，所有 CryptoKitties 都作为一个巨型列表存储在单个智能合约中。通过将每个所有者的帐户ID存储在中央区块链帐本中来跟踪每个Kitty的所有权，而更改 Kitty 所有权的唯一方法是发起调用合约请求，并要求其更新与该 Kitty 相关的帐户ID。</p>
<p>在资源模型中，Kitty 本身表示为一个Resource对象，它直接存储在拥有它的帐户中。就像在现实世界中一样，所有权是通过拥有它来表示的。您无需查看中央账本，即可查看您是否拥有某物，可以将其存储在帐户中，也可以不用。而且，如果您拥有它，则可以转移它或以其他方式对其进行控制，如果您没有，则无法捕获或更改它。</p>
<p><em>注意：为了专注于账本模型和资源模型之间的差异，以上两个示例都忽略了访问控制，定义每个变量以及实时代码需要担心的其他因素等问题。</em></p>
<h2 id="为什么资源很重要">为什么资源很重要</h2>
<p>资源可以便于管理所有权的抽象，并且防止错误的同时提高智能合约开发人员的生产力，但是使用资源还有一些其他的好处，每个好处本身都非常重要：</p>
<ul>
<li>费用管理</li>
</ul>
<p>可扩展的智能合约平台需要某种方式来收取“租金”，因为每一份计算资源的使用都需要支付费用，存储在区块链上的数据若不支付则会被删除。</p>
<p>使用账本模型，很难知道应该由谁支付租金。例如，CryptoKitties 合约代表着数以万计的玩家，拥有近200万只 Kitty 和超过 111MB 的链上数据。以太坊无法向所有 Kitty 所有者公平地收取租金。</p>
<p>使用通过资源类型的直接所有权模型，每只猫咪都将与该人的其他资产一起存储在其所有者的帐户内。谁需要为此存储付费，责任很明确。此外，单个用户（在其客户端软件的帮助下）可以归档未使用的资产，以降低成本并减少网络负载。</p>
<ul>
<li>灵活的所有权</li>
</ul>
<p>将账本模型用于所有权会限制所有者与其他拓展方案的兼容。例如，ERC-721为NFT定义了一种所有权模型，该模型假定只有以太坊地址才能拥有NFT。但是，资产本身拥有其他资产的想法（例如，拥有一副漂亮的太阳镜的CryptoKitty）在某些用例中非常有趣，并且需要创建新的规范（ERC-998）。ERC-998非常强大，但它也比ERC-721复杂得多。正确实施它非常困难，由于以太坊智能合约的不变性，将其功能追溯应用到现有ERC-721资产实际上是不可能的。</p>
<p>资源模型允许将使用“资源类型”建模的任何资产安全地存储在系统中的任何位置，包括在其他资产“内部”（如果适用）。所有安全性和价值保证都可以由运行时系统维护，同时为开发人员提供了创造性和灵活性，而又不会带来过多的复杂性。</p>
<ul>
<li>基于功能的安全性</li>
</ul>
<p>资源类型是提供了基于功能的安全模型，其中具备实现“功能”概念所需的所有保证。功能是定义安全系统的强大机制，可以遵守最小特权原则（安全系统中的一种常见最佳做法）更加容易，该原则要求安全系统的所有部分都没有绝对的特权。是他们完成工作所必需的）。<br>
基于功能的安全模型通常被认为更容易推理（增强了安全性），同时具有更大的灵活性。</p>
<ul>
<li>消除重入错误</li>
</ul>
<p>以太坊历史上最著名的智能合约错误是由于重入问题而引起的，Solidity开发人员需要时刻保持警惕，以防止引入容易受到重入攻击的逻辑流。<br>
幸运的是，在Resource对象上定义的方法不能成为任何可重入漏洞利用的受害者。<br>
这似乎是一个大胆的改变！遵循资源的定义方式：每个资源都有一个所有者，只有资源的所有者才能在其上调用方法。如果Resource方法是“堆栈上的”，则我们知道对该对象的单个所有权引用已经被明确分配；我们从该方法内部调用的任何代码（无论是间接调用）根本不可能再次获得对该对象的引用以进行可重入方法调用。</p>
<p>当然，直接使用全局共享状态（绕过Resource对象的使用）仍然可以创建易受重入错误影响的代码。这就是为什么惯用的Cadence 编程范式是对所有共享状态使用Resources的原因；精通面向资源编程的合约开发者，将无需再考虑可重入的bug！</p>
<hr>
<p><a href="https://medium.com/dapperlabs/resource-oriented-programming-bee4d69c8f8e">翻译自 Dieter Shirley 原文</a></p>
]]></content>
    </entry>
</feed>