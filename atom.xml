<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lianqiujun.co</id>
    <title>链 求 君 | 区 块 链</title>
    <updated>2021-02-28T06:08:22.256Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lianqiujun.co"/>
    <link rel="self" href="https://lianqiujun.co/atom.xml"/>
    <subtitle>实践更多区块链项目，探索更多Web3可能性！</subtitle>
    <logo>https://lianqiujun.co/images/avatar.png</logo>
    <icon>https://lianqiujun.co/favicon.ico</icon>
    <rights>All rights reserved 2021, 链 求 君 | 区 块 链</rights>
    <entry>
        <title type="html"><![CDATA[用Cadence迈出第一步]]></title>
        <id>https://lianqiujun.co/post/yong-cadence-mai-chu-di-yi-bu</id>
        <link href="https://lianqiujun.co/post/yong-cadence-mai-chu-di-yi-bu">
        </link>
        <updated>2021-02-28T05:58:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="用cadence迈出第一步">用Cadence迈出第一步</h1>
<p>作者： <code>Joshua Hannan</code></p>
<p>原文： <code>https://joshuahannan.medium.com/taking-your-first-steps-with-cadence-19dde86bbd0</code></p>
<p><img src="https://swarm-gateways.net/bzz:/b498be7eef3bdec489f8429a6d1ce06e01c12a0c443adc5921340099b29ced02/1_GcG84v5U97IebXhyMw65Nw%20(1).png" alt="" loading="lazy"><br>
<code>F 也代表 Fun</code></p>
<p>你好！我叫Josh Hannan，是Dapper Labs Flow团队的智能合约工程师。自2017年初以来，我一直在区块链领域，花了几年时间从事以太坊项目，并于2019年9月开始与Flow团队合作。在Dapper Labs，我编写Cadence智能合约和文档，并协助社区工作。</p>
<p>我每周会写一次短文（假设我能在最后期限完成）关于什么是Cadence，目前在我的博客顶部是关于Cadence的文章。我还将重点介绍我遇到的社区中有趣的项目！</p>
<p>Cadence是一门令人着迷的语言，我想尽我所能开始更多有关它的介绍。</p>
<h2 id="什么是-flow">什么是 Flow？</h2>
<p>Flow是为下一代应用程序，游戏以及为其提供动力的数字资产而构建的新区块链。Flow的独特架构使其无需分片即可进行扩展，同时仍提供每个人都希望从区块链获得的相同的去中心化和安全性。</p>
<p><img src="https://swarm-gateways.net/bzz:/5c2b16b4c7230d9d458d18e2cd55c1f7f8d7afd9bec50054c99a4e81b201fe3a/1_FUuphC1mmWrVXGUxa7dVww.gif" alt="" loading="lazy"><br>
<code>可以，您可以在这里花些时间。我第一次看这个架构就重复观看了大约10分钟。</code></p>
<hr>
<h2 id="从哪儿开始了解-flow">从哪儿开始了解 Flow？</h2>
<p>最近，人们对Flow产生了很多新的兴趣。也许每个人都制定了新年计划，以了解Flow？也许在Elon Musk 的Tweet™中也会提到了Flow？也许有一款基于Flow的NFT游戏正在迅速流行，并吸引了想要为其开发工具和其他类似体验的开发人员？这都是有可能的。😜</p>
<p>无论哪种方式，Flow 社区中都有很多新人，并且很多人想了解Cadence。虽然并不总是很清楚，但是从哪里开始，以及在学习了基础知识之后就应该去哪里。</p>
<p>首先，如果您是区块链的新手，我强烈建议您在继续Cadence之旅之前，先找到指南或在线课程，向您介绍分布式分类账技术的基础知识（超出本文范围）。</p>
<p>我还建议您阅读Flow Primer，以对Flow区块链的体系结构有一个基本的了解。</p>
<p><a href="https://zh.onflow.org/primer#primer-intro">Flow Primer： 开发世界的区块链</a></p>
<hr>
<h3 id="步骤1cadence简介">步骤1：Cadence简介</h3>
<p>在尝试学习语言之前，必须先理解, <a href="https://docs.onflow.org/cadence">Cadence语言</a>的创造做了哪些伟大的工作，理解Cadence背后的原理以及为什么采用这样重要的设计决策。</p>
<p>我还建议您查阅Dapper Labs首席技术官，Flow and Cadence的首席架构师之一Dete Shirley的<a href="https://medium.com/@dete73">博客文章</a>。他解释了为什么Cadence编程模型（面向资源的编程）是数字资产的理想模型。<br>
Decentology的另一篇博客文章介绍了Flow and Cadence账户模型：</p>
<p><a href="https://www.decentology.com/guides-and-tutorials/blockchain-accounts-flow-vs-ethereum">Flow 与以太坊 的账户模型有何不同？ </a></p>
<p>他们在概述Flow编程和独特的账户模型方面介绍得很好。</p>
<hr>
<h3 id="步骤2cadence教程">步骤2：Cadence教程</h3>
<p>接下来，您应该完成所有的Cadence教程，从“<a href="https://docs.onflow.org/cadence/tutorial/01-first-steps">第一步</a>”开始，到“<a href="https://docs.onflow.org/cadence/tutorial/08-voting/">投票合同</a>”结束。这些教程使用真实合约来逐步引导您了解Cadence的重要功能。</p>
<p>这些教程将帮助您熟悉Flow Playground，这是一个出色的工具，可以在浏览器中快速编写和手动测试智能合约！</p>
<p><img src="https://swarm-gateways.net/bzz:/1fea74a633929eb5ef9bad009d6a8ec9c39f78e4d7620cbf96206ffcf82e86c3/playground.png" alt="" loading="lazy"><br>
<code>playground 示例</code></p>
<p>还有一个Visual Studio代码插件您可以安装，具备语法高亮和VSCode内置Flow 区块链模拟器！很整洁吧？</p>
<hr>
<h3 id="步骤3标准实现">步骤3：标准实现</h3>
<p>正如您将在教程中了解的那样，即使实际上并不需要，许多区块链项目都使用同质化代币（fungible tokens），非同质化代币（non-fungible tokens）或同时使用这两种。</p>
<p>我们强烈建议您使用两种类型的标准接口，以便与其他智能合约互操作。它们各自位于单独的Github存储库中。</p>
<ul>
<li>
<p><a href="https://github.com/onflow/flow-ft">同质化代币（fungible tokens）标准</a></p>
</li>
<li>
<p><a href="https://github.com/onflow/flow-nft">非同质化代币（non-fungible tokens）标准</a></p>
</li>
</ul>
<hr>
<h3 id="步骤4cadence合约实践">步骤4：Cadence合约实践</h3>
<p>至此，我相信您已经完全被Cadence吸引了，并且正在跃跃欲试，所以请看看其他人使用这种令人难以置信的编程语言所构建的项目。</p>
<p>下面是我们在在测试网和/或主网上运行的Cadence智能合约的一些很好的例子。（我可能有一点偏见，因为我帮助写了一些。）</p>
<ul>
<li>
<p><a href="https://github.com/onflow/flow-core-contracts">Flow核心合约</a>： 此项目包含作为核心Flow协议一部分的智能合约和交易。他们包含Flow Token，交易，费用，抵押等等的行为。</p>
</li>
<li>
<p><a href="https://github.com/onflow/kitty-items">Kitty物品</a>： Flow和Cryptokitties团队最近构建的NFT游戏，该应用程序完成了令人惊叹的示例，该示例使用最新的Flow开发最佳实践在testnet上运行。让开发者可以通过完整应用程序作为参考进行Cadence和Flow开发！</p>
</li>
<li>
<p><a href="https://github.com/dapperlabs/nba-smart-contracts">NBA Top Shot</a>： 您可能已经听说过这一项目。自2020年6月以来，NBA Top Shot及其市场一直在Flow Mainnet上运行，并已变得极为流行。免责声明：Top Shot合同是很久以前写的，因此使用了一些过时的Cadence设计模式，不建议在以后的大多数NFT项目中使用。Kitty Items项目是Cadence最佳实践的一个更好的例子。</p>
</li>
</ul>
<hr>
<h2 id="结论">结论</h2>
<p>如果您学到了这里，恭喜！希望您现在应该拥有足够的工具和知识，以便在Cadence中编写自己的智能合约。</p>
<p>在整个过程中，您将拥有整个Flow团队和社区来为您提供支持！请不要犹豫，通过我们的Discord服务器，Flow论坛或Flow Github存储库中的问题与我们联系。</p>
<p>您是否还知道其他对新手有用的资源或有趣的项目？请随意评论您的想法，我可能会在以后的帖子中加入它们！</p>
<ul>
<li>Flow Discord: https://discord.gg/flow</li>
<li>Flow Forum: https://forum.onflow.org</li>
<li>Flow Github: https://github.com/onflow/flow</li>
</ul>
<p>下周见! 👋</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[注重实效的编程哲学]]></title>
        <id>https://lianqiujun.co/post/zhu-chong-shi-xiao-de-bian-cheng-zhe-xue</id>
        <link href="https://lianqiujun.co/post/zhu-chong-shi-xiao-de-bian-cheng-zhe-xue">
        </link>
        <updated>2021-01-21T02:03:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="注重实效的编程哲学">注重实效的编程哲学</h1>
<hr>
<p>1、关心你的技艺</p>
<p>Care About Your Craft</p>
<p>如果你不在乎能否漂亮地开发出软件，你又为何要耗费声明去开发软件呢？</p>
<hr>
<p>2、思考！你的工作</p>
<p>Think!About Your Work</p>
<p>关掉自动驾驶仪，接管操作。不断地批评和评估你的工作。</p>
<hr>
<p>3、提供各种选择，不要找蹩脚的借口</p>
<p>Provide Options,Don't Make Lame Exceuses</p>
<p>要提供各种选择，而不是找借口。不要说事情做不到；说明能够做什么。</p>
<hr>
<p>4、不要容忍破窗户</p>
<p>Don't Live with Broken Windows</p>
<p>当你看到糟糕的设计、错误的决策和糟糕的代码时，修正它们</p>
<hr>
<p>5、做变化的催化剂</p>
<p>Be  a Catalyst for Change</p>
<p>你不能强迫人们改变。想法，要向它们展示未来可能会怎样，并帮助它们参与对未来的创造。</p>
<hr>
<p>6、记住大图景</p>
<p>Remember the Big Picture</p>
<p>不要太过专注于细节，已致忘了查看你周围正在发生什么</p>
<hr>
<p>7、使质量成为需求问题</p>
<p>Make Quality a Requirements Issue</p>
<p>让你的用户参与确定项目真正的质量需求。</p>
<hr>
<p>8、定期为你的知识资产投资</p>
<p>Invest Regularly in Your Knowlege Portfolio</p>
<p>让学习成为习惯</p>
<hr>
<p>9、批判地分析你读到的和听到的</p>
<p>Critically  Analyze What You Read and Hear</p>
<p>不要被供应商、媒体炒作、或教条左右。要依照你自己的砍伐和你的项目情况去对信息进行分析。</p>
<hr>
<p>10、你说什么和你怎么说同样重要</p>
<p>It's Both What You Say and the Way You Say It</p>
<p>如果你不能有效地向他人传达你的了不起的想法，这些想法就毫无用处。</p>
<hr>
<p>11、不要重复你自己</p>
<p>DRY---Don't Repeat Yourself</p>
<p>代码模块的每一项只是都必须具有单一、无歧义、权威的表示</p>
<hr>
<p>12、让复用变得容易</p>
<p>Make It Easy to Reuse</p>
<p>如果复用很容易，人们就会去复用。创造一个支持复用的环境。</p>
<hr>
<p>13、消除无关事物之间的影响</p>
<p>Eliminate Effects Between Unrelated Things.</p>
<p>设计自足、独立、并具有单一、良好定义的目的的组件</p>
<hr>
<p>14、不存在最终决策</p>
<p>There Are No Final Decisions</p>
<p>没有决策是浇铸在石头上的。相反，要把每项决策都视为是写在沙滩上的，并为变化做好计划。</p>
<hr>
<p>15、用曳光弹找到目标</p>
<p>Use Tracer Bullets to Find the Target</p>
<p>曳光弹能通过实验各种事物并检查它们离目标有多远让你来追踪目标。</p>
<hr>
<p>16、为了学习而制作原型</p>
<p>Prototype to learn</p>
<p>原型制作是一种学习经验。其价值并不在于所产生的的代码，而在于所学到的经验教训</p>
<hr>
<p>17、靠近问题领域编程</p>
<p>Program Close to the Problem domain</p>
<p>用你的用户的语言进行设计和编码</p>
<hr>
<p>18、估算，以避免发生意外</p>
<p>Estimate to Avoid Surprises</p>
<p>在着手之前先进行估算。你将提前发现潜在的问题。</p>
<hr>
<p>19、通过代码对进度表进行迭代</p>
<p>Iterate the Schedule with the Code</p>
<p>用你在进行实现时获得的经验提炼项目的时间标度</p>
<hr>
<p>20、用纯文本保存知识</p>
<p>Keep Knowlege in Plain Text</p>
<p>纯文本不会过时。它能够帮助你有效地利用你的工作，并简化调试和测试</p>
<hr>
<p>21、利用命了Shell的力量</p>
<p>Use the Power of Command Shells</p>
<p>当图形用户界面无能为力时用shell</p>
<hr>
<p>22、用好一种编辑器</p>
<p>Use a Single Editor Well</p>
<p>编辑器应该是你手的延伸；确保你的编辑器是可配置、可扩展和可编程的</p>
<hr>
<p>23、总是使用源码控制</p>
<p>Always Use Source Code Control</p>
<p>源码控制是你的工作的时间机器---你能够回到过去</p>
<hr>
<p>24、要修正问题，而不是发出指责</p>
<p>FIx the Problem,Not the Blame</p>
<p>bug是你的过错还是别人的过错，并不是真的很有关系----它仍然是你的问题，它仍然需要修正</p>
<hr>
<p>25、不要恐慌</p>
<p>Don't Panic When Debuging</p>
<p>做一次深呼吸，思考什么是bug的原因</p>
<hr>
<p>26、“Select”没有问题</p>
<p>“Select” Isn't Broken</p>
<p>在OS或编译器、甚或是第三方产品或库中很少发现bug。bug很可能在应用中。</p>
<hr>
<p>27、不要假定，要证明</p>
<p>Don't Assume It -- Prove It</p>
<p>在实际环境中----使用真正的数据和边界条件-------证明你的假定</p>
<hr>
<p>29、学习一种文本操纵语言</p>
<p>Learn a Text Manipulation Language</p>
<p>你每天的很大一部分时间用来处理文本，为什么不让计算机替你完成部分工作呢？</p>
<hr>
<p>30、你不可能写出完美的软件</p>
<p>You Can't Write Perfect Software</p>
<p>软件不可能完美。保护你的代码和用户，是他们能免于能够遇见的错误</p>
<hr>
<p>31、通过合约进行设计</p>
<p>Design with Contracts</p>
<p>使用合约建立文档，并检验代码所做的事情正好是它声明要做的</p>
<hr>
<p>32、早崩溃</p>
<p>Crash Early</p>
<p>死程序造成的危害通常比有问题的程序要小得多</p>
<hr>
<p>33、用断言避免不可能发生的事情</p>
<p>Use Assertions to Prevent the</p>
<p>断言验证你的各种假定。在一个不确定的世界里，用断言保护你的代码</p>
<hr>
<p>34、将异常用于异常的问题</p>
<p>Use Exception for Exceptional Problems</p>
<p>异常可能会遭受经典的意大利面条式代码的所有可读性和可维护性问题的折磨。将异常保留给异常的事物</p>
<hr>
<p>35、要有始有终</p>
<p>Finish What You Start</p>
<p>只要可能，分配某资源的例程或对象也应该负责解除其分配</p>
<hr>
<p>36、使模块之间的耦合减至最少</p>
<p>Minimize Coupling Between Modules</p>
<p>通过编写“羞怯的”代码并应用德墨忒尔法则来避免耦合</p>
<hr>
<p>37、要配置，不要集成</p>
<p>Configure,Don't Integrage</p>
<p>要将应用的各种技术选择实现为配置选项，而不是通过集成或工程方法实现。</p>
<hr>
<p>38、将抽象放进代码，细节放进元数据</p>
<p>Put Abstractions in Code,Details in Metadata</p>
<p>为一般情况编程，将细节放在被便于的代码库之外</p>
<hr>
<p>39、分析工作流，以改善并发性</p>
<p>Analyze Workflow to Improve Concurrency</p>
<p>利用你的用户的工作流中的并发性</p>
<hr>
<p>40、用服务进行设计</p>
<p>Design Using Services</p>
<p>根据服务---独立的、在良好定义、一致的接口之后的并发对象---进行设计</p>
<hr>
<p>41、总是为并发进行设计</p>
<p>Always  Design for Concurrency</p>
<p>容许并发，你将会设计出更整洁、具有更少假定的接口</p>
<hr>
<p>42、使视图与模型分离</p>
<p>Separate Views from Models</p>
<p>要根据模型和视图设计你的应用，从而以低廉的代码获取灵活性</p>
<hr>
<p>43、用黑板协调工作流</p>
<p>Use Blackboards to Coordinate Workflow</p>
<p>用黑板协调完全不同的事实和因素，同时又使各参与方保持独立和隔离</p>
<hr>
<p>44、不要依靠巧合编程</p>
<p>Don't Program by Coincidence</p>
<p>只依靠可靠的事物。注意偶发的复杂性，不要把幸运的巧合与又目的的计划混为一谈</p>
<hr>
<p>45、估算你的算法的阶</p>
<p>Estimate the Order of Your Algorithms</p>
<p>在你编写代码之前，先大致估算事情需要多长时间</p>
<hr>
<p>46、测试你的估算</p>
<p>Test Your Estimates</p>
<p>对算法的数学分析并不会告诉你每一件事情。在你的代码的目标环境中测定它的速度</p>
<hr>
<p>47、早重构，常重构</p>
<p>Refactor Early,Refactor Often</p>
<p>就和你会在花园里除草、并重新布置一样，在需要时对代码进行重新、重做和重新架构。要铲除问题的根源</p>
<hr>
<p>48、未测试而设计</p>
<p>Design to Test</p>
<p>在你还没有编写代码时就开始思考测试问题</p>
<hr>
<p>49、测试你的软件，否则你的用户就得测试</p>
<p>Test Your Software,or Your Users Will</p>
<p>无情地测试。不要让你的用户未能查找bug</p>
<hr>
<p>50、不要使用你不理解的向导代码</p>
<p>Don't Use Wizard Code You Don't Understand</p>
<p>向导可以生成大量代码。在你把它们合并进你的项目之前，确保你理解全部这些代码。</p>
<hr>
<p>51、不要搜集需求---挖掘它们</p>
<p>Don't Gather Requirements --Dig for Them</p>
<p>需求很少存在在表面上。它们深深地埋藏在层层假定、误解和政治手段的下面。</p>
<hr>
<p>52、与用户一同工作，以像用户一样思考</p>
<p>Work wih a User to Think Like a User</p>
<p>要了解系统实际上将如何被使用，这是最好的方法。</p>
<hr>
<p>53、抽象比细节获得更长久</p>
<p>Abstractions Live Longer than Details</p>
<p>“投资”于抽象，而不是实现。抽象能在来自不同的实现和新技术的变化的“攻击”之下存活下去</p>
<hr>
<p>54、使用项目词汇表</p>
<p>Use a Project Glossary</p>
<p>创建并维护项目中使用的专用术语和词汇的单一信息源</p>
<hr>
<p>55、不要在盒子外面思考---要找到盒子</p>
<p>Don't Think Outside the Box--Find the Box</p>
<p>在遇到不可能解决的问题时，要确定真正的约束。问问你自己：“”它必须以这种方式完成吗？它真的必须完成吗？&quot;</p>
<hr>
<p>56、等你准备好再开始</p>
<p>Start When You're Ready</p>
<p>你的一生都在积累经验。不要忽视反复出现的疑虑</p>
<hr>
<p>57、对有些事情”做“胜于”描述“</p>
<p>Some Things Are Better Done than Described</p>
<p>不要掉进规范的螺旋----在某个时刻，你需要开始编码</p>
<hr>
<p>58、不要做形式方法的奴隶</p>
<p>Don't Be a Slave to Formal Methods</p>
<p>如果你没有把某项技术放进你的开发实践和能力的语境中，不要盲目地采用它。</p>
<hr>
<p>59、昂贵的工具不一定能制作出更好的设计</p>
<p>Costly Tools Don't Produce Better Designs</p>
<p>小心供应商的炒作，行业教条、以及价格标签的诱惑。要根据工具的价值判断它们</p>
<hr>
<p>60、围绕功能组织团队</p>
<p>Organize Teams Around Functionality</p>
<p>不要把设计师与编码员分开，也不要把测试员与数据建模员分开。按照你构建代码的方式构建团队。</p>
<hr>
<p>61、不要使用手工流程</p>
<p>Don't Use Manual Procedures</p>
<p>shell脚本或批文件会一次次地以同一顺序执行同样的指令。</p>
<hr>
<p>62、早测试，场测试，自动测试</p>
<p>Test Early,Test Often.Test Automatically</p>
<p>与呆着书架上的测试计划相比，每次构建时运行的测试要有效得多。</p>
<hr>
<p>63、要通过全部测试，编码才算完成</p>
<p>Coding Ain't Done &quot;Til All  the Tests Run</p>
<p>就是这样</p>
<hr>
<p>64、通过”蓄意破坏“测试你的测试</p>
<p>Use Saboteurs to Test Your Testing</p>
<p>在单独的软件副本上故意引入bug，以检验测试能够抓住它们</p>
<hr>
<p>65、测试状态覆盖，而不是代码覆盖</p>
<p>Test State Coverage,Not Code Coverage</p>
<p>确定并测试重要的程序状态。只是测试代码行是不够的</p>
<hr>
<p>66、一个bug只抓一次</p>
<p>Find Bugs Once</p>
<p>一旦测试员找到一个bug，这应该是测试员最后一次找到它。以后的自动测试应该对其进行检查</p>
<hr>
<p>67、英语就是一种编程</p>
<p>English is Just a Programming Language</p>
<p>像你写代码一样编写文档：遵守DRY原则、使用元数据、MVC、自动生成，等等</p>
<hr>
<p>68、把文档建在里面，不要拴在外面</p>
<p>Build Documentation In,Don't Bolt it On</p>
<p>与代码分类的 文档 不太可能被修正和更新</p>
<hr>
<p>69、温和地超出用户的期望</p>
<p>Gently Exceed Your Users' Expectations</p>
<p>要理解你的用户的期望，然后给他们的东西要多那么一点</p>
<hr>
<p>70、在你的作品上签名</p>
<p>Sign Your Work</p>
<p>过去时代的手艺人为能在他们的作品上签名而自豪。你也应该如此</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[读书&观影]]></title>
        <id>https://lianqiujun.co/post/du-shu-andguan-ying</id>
        <link href="https://lianqiujun.co/post/du-shu-andguan-ying">
        </link>
        <updated>2021-01-21T01:31:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="2021-年书单">2021 年书单</h1>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7528933"><label class="task-list-item-label" for="task-item-7528933"> 《程序员修炼之道:从小工到专家》</label></li>
</ul>
<p>[资源](https://swarm-gateways.net/bzz:/378fbce4da8c5914687b4e6f2df75c071dbc23b00548781c778baf4b74d5cbdb/程序员修炼之道 从小工到专家.pdf)</p>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1736910"><label class="task-list-item-label" for="task-item-1736910"> 《曾国藩传》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2250154"><label class="task-list-item-label" for="task-item-2250154"> 《精通以太坊（第二版）》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-999604"><label class="task-list-item-label" for="task-item-999604"> 《人类简史》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1541161"><label class="task-list-item-label" for="task-item-1541161"> 《我生活都种种模式》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1252943"><label class="task-list-item-label" for="task-item-1252943"> 《众病之王》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5152090"><label class="task-list-item-label" for="task-item-5152090"> 《程序是如何运行的》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-113408"><label class="task-list-item-label" for="task-item-113408"> 《编程语言实现模式》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-989356"><label class="task-list-item-label" for="task-item-989356"> 《区块链重塑经济与世界》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3299311"><label class="task-list-item-label" for="task-item-3299311"> 《精通比特币:第二版》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2208216"><label class="task-list-item-label" for="task-item-2208216"> 《剑指offer》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4319370"><label class="task-list-item-label" for="task-item-4319370"> 《充足理由率的四重根》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-906144"><label class="task-list-item-label" for="task-item-906144"> 《哥德尔、艾舍尔、巴赫》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3798213"><label class="task-list-item-label" for="task-item-3798213"> 《鸟哥Linux私房菜基础篇》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7029988"><label class="task-list-item-label" for="task-item-7029988"> 《区块链：定义金融格局》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9899119"><label class="task-list-item-label" for="task-item-9899119"> 《编码》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4414929"><label class="task-list-item-label" for="task-item-4414929"> 《像程序员一样思考》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2587331"><label class="task-list-item-label" for="task-item-2587331"> 《黑客与画家》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2166366"><label class="task-list-item-label" for="task-item-2166366"> 《人件》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-89704"><label class="task-list-item-label" for="task-item-89704"> 《深入理解计算机系统》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1075259"><label class="task-list-item-label" for="task-item-1075259"> 《区块链社会》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4339839"><label class="task-list-item-label" for="task-item-4339839"> 《人类群星闪耀时》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-647958"><label class="task-list-item-label" for="task-item-647958"> 《Python密码学编程》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-349137"><label class="task-list-item-label" for="task-item-349137"> 《计算机程序的构造和解释》</label></p>
</li>
</ul>
<h1 id="2020-年书单">2020 年书单</h1>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8116642"><label class="task-list-item-label" for="task-item-8116642"> 1. 《维特根斯坦传》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4096545"><label class="task-list-item-label" for="task-item-4096545"> 2. 《Python实现一条区块链》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3136256"><label class="task-list-item-label" for="task-item-3136256"> 3. 《爱因斯坦传》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2373356"><label class="task-list-item-label" for="task-item-2373356"> 4.  《精通比特币：第二版》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3952490"><label class="task-list-item-label" for="task-item-3952490"> 5. 《硅谷之火》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4103722"><label class="task-list-item-label" for="task-item-4103722"> 6. 《故事》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9064793"><label class="task-list-item-label" for="task-item-9064793"> 7. 《网络是怎样连接的》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2350785"><label class="task-list-item-label" for="task-item-2350785"> 8. 《刻意练习》</label></p>
</li>
</ul>
<h1 id="2018-年书单">2018 年书单</h1>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6553812"><label class="task-list-item-label" for="task-item-6553812"> 1. 《发现的乐趣》 理查德 费曼</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1334235"><label class="task-list-item-label" for="task-item-1334235"> 2. 《小程序开发》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5806224"><label class="task-list-item-label" for="task-item-5806224"> 3. 《你的灯亮着吗？》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3297971"><label class="task-list-item-label" for="task-item-3297971"> 4. 《计算中的上帝》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5268661"><label class="task-list-item-label" for="task-item-5268661"> 5. 《理解专业程序员》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4138068"><label class="task-list-item-label" for="task-item-4138068"> 6. 《小王子》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4997720"><label class="task-list-item-label" for="task-item-4997720"> 7. 《Head First HTML》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2093516"><label class="task-list-item-label" for="task-item-2093516"> 8. 《人生的智慧》  -- 叔本华</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2588908"><label class="task-list-item-label" for="task-item-2588908"> 9. 《乔布斯传》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2677841"><label class="task-list-item-label" for="task-item-2677841"> 10. 《数学是什么？》</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9131117"><label class="task-list-item-label" for="task-item-9131117"> 11. 《Django教程》</label></p>
</li>
</ul>
<h4 id="观影记录">观影记录</h4>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9593985"> <a href="https://movie.douban.com/subject/24696708/">《神奇的费曼先生》<label class="task-list-item-label" for="task-item-9593985"> [《神奇的费曼先生》](https://movie.douban.com/subject/24696708/)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8061278"> <a href="https://movie.douban.com/subject/27941811/">《区块链之新》<label class="task-list-item-label" for="task-item-8061278"> [《区块链之新》](https://movie.douban.com/subject/27941811/)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4630896"> <a href="#">《比特币：钱的终结》<label class="task-list-item-label" for="task-item-4630896"> [《比特币：钱的终结》](#)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1359688"> <a href="https://v.qq.com/x/page/f0380os1ryc.html">访谈纪录片：发现的乐趣<label class="task-list-item-label" for="task-item-1359688"> [访谈纪录片：发现的乐趣](https://v.qq.com/x/page/f0380os1ryc.html)</label></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是比特币（BTC）？]]></title>
        <id>https://lianqiujun.co/post/shi-me-shi-bi-te-bi-btc</id>
        <link href="https://lianqiujun.co/post/shi-me-shi-bi-te-bi-btc">
        </link>
        <updated>2021-01-13T12:55:57.000Z</updated>
        <content type="html"><![CDATA[<p>比特币是世界上第一个点对点的加密货币。它是由一位神秘的人物中本聪（Satoshi Nakamoto）于2009年发明的，被认为是解决双重支出问题的第一种数字货币。</p>
<p>比特币就是一切的开始。它是第一种破解创建数字货币的基本原理的数字货币，这种数字货币无法像普通文件一样被复制。但是谁发明了它，为什么它如此重要？我们将在下面进行探讨。</p>
<h1 id="什么是比特币">什么是比特币？</h1>
<p>比特币是一种点对点的加密货币。这意味着什么？这是一种新的商品和服务付款方式，以及货币价值的储值方式，这种方式不依赖中央银行，政府或信贷提供商。</p>
<p>比特币使用区块链技术构建，这是一种从互联网上传输数据和价值的全新方式，从三明治到房屋的等所有物品都可以使用比特币购买。</p>
<p>你知道吗？</p>
<p>2010年5月，首次使用比特币正式购买披萨。有人曾将10,000BTC兑换成了两份披萨。现在还有人将5月22日作为比特币披萨节进行庆祝。</p>
<h1 id="谁发明了比特币">谁发明了比特币？</h1>
<p>没有人真的知道。但最早的发明者，是一位称自己为中本聪（Satoshi Nakamoto）的神秘人物。</p>
<p>中本聪（Satoshi Nakamoto）的名字可能是一位或多位发明家共同命名的，许多人试图找到这一个或多个神秘人物，但没有真正的结果。</p>
<h1 id="简短的历史">简短的历史</h1>
<p>在2008年11月，一份名为 “比特币：点对点电子现金系统” 的论文被发布在一个小型的加密邮件论坛上。作者以中本聪（Satoshi Nakamoto）的名字命名，他/她/他们解释了这种货币将如何工作。</p>
<p>几个月后，即2009年1月，比特币的第一个版本发布了，随后不久又在网络上开采了第一个区块。这通常被称为Genesis块，即创世区块。</p>
<p>最早参与比特币交易的人是名为Hal Finney的程序员，他下载了运行该软件所需的软件并获得了10比特币，这是2009年1月12日进行的第一笔比特币交易。</p>
<p>当时，中本聪（Satoshi Nakamoto）和其他一些人共同维护了比特币稳定运行后，然后神秘地消失了，将控制权交给了另一个叫Gavin Andresen 的程序员。</p>
<h1 id="有什么特别之处">有什么特别之处？</h1>
<p>比特币做了一件以前没人能做到的事。它是：</p>
<p>权力下放 - 没有人或团体拥有或控制它。</p>
<p>无需信任（点对点） - 不需要第三方进行交易。</p>
<p>无国界 -<br>
无需交流即可轻松在全球范围内转移资金。</p>
<p>不变 - 与当今的金融系统不同，它永远不能改变或逆转。</p>
<p>防止双重支出 -  解决了许多数字货币之前尝试破解但未能做到的问题。</p>
<p>比特币是区块链运作的第一个成功案例。</p>
<p>所有比特币中约有25％已经丢失了。11月13日，一位IT顾问不小心将带有7500个比特币私钥的硬盘扔掉了。今天的损失价值在3亿美元。</p>
<h1 id="比特币是如何生产的">比特币是如何生产的？</h1>
<p>想象一下地下的黄金。我们知道它的存在，但是它的价值一直隐藏到矿工“挖掘”它为止。在比特币世界中，矿工通过创建网络中正在进行的所有交易的“块”来发现比特币，并将其添加到区块链中。</p>
<p>在中本聪（Satoshi Nakamoto）的白皮书中，他/她/他们指定只能存在2100万个比特币-但尚未全部挖掘出来。按照目前的采矿速度，所有这些都将在2140年的某个时候“挖出”。</p>
<h1 id="如何拥有比特币">如何拥有比特币？</h1>
<p>拥有它的方法主要有以下三种：</p>
<p>你可以用法定货币从一些知名的数字货币交易所购买他们。你将需要一个钱包和一组密钥来存储和交换它们。</p>
<p>你可以成为一名矿工，并尝试解决当前区块的密码学难题，你将会得到比特币奖励。</p>
<p>你可以赢得他们！各种具备比特币属性的交易网站如雨后春笋般出现，以帮助人们消费和赚取比特币。</p>
<p>你知道吗？</p>
<p>目前流通的所有比特币中，约有1000人拥有近40％的比特币。</p>
<h1 id="你可以用比特币做什么">你可以用比特币做什么？</h1>
<p>买东西 - 特斯拉，房屋，假期，游戏，教育甚至法律帮助中的一切都可以通过比特币使用支付。</p>
<p>数字版权管理 - 比特币协议基于区块链，可用于帮助音乐家和艺术家出售自己的作品。</p>
<p>身份 - 由于比特币钱包中使用了独特的双密钥系统，它可能成为您在线识别自己身份的主要方式。</p>
<p>你知道吗？</p>
<p>2013年，FBI通过出售使用该货币从犯罪分子手中没收的144,000比特币赚了4,800万美元。</p>
<h1 id="什么是比特币钱包">什么是比特币钱包？</h1>
<p>就像普通的钱包一样，它是存放贵重物品的地方。当涉及比特币时，这些贵重物品就是可存储在你手机上，网络或计算机上的软件上持有的密钥。</p>
<p>为了买卖比特币，你需要一个私钥（只能让你自己知道）和一个公钥。</p>
<p>一个公钥是要分享的内容与人进行交易了。</p>
<p>你的私钥是您自己保留的东西。当你进行交易时，某人将它的公钥发送给你让你发送比特币给他，而你的私钥则用于验证请求发送或接收比特币的人。</p>
<p>比特币消耗大量电力。非常之多，以至于一项交易消耗的能量几乎是处理信用卡交易时消耗的能量的4,000倍。</p>
<h1 id="未来发展">未来发展</h1>
<p>我们知道所有的比特币都将在2140年的某个时候开采。与此同时，比特币的未来及其价值尚不确定。</p>
<p>加密货币的局限性 - 导致创建了许多其他更专业的山寨币。</p>
<p>有些人认为它可能成为价值的存储，就像黄金在现实世界中一样。同时，其他人希望保留它作为购买商品，服务和开发人员的一种方式。</p>
<p>比特币的未来是不确定的。但是，区块链的潜力才刚刚开始。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刻意练习]]></title>
        <id>https://lianqiujun.co/post/ke-yi-lian-xi</id>
        <link href="https://lianqiujun.co/post/ke-yi-lian-xi">
        </link>
        <updated>2021-01-08T05:42:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="刻意练习">刻意练习</h1>
<p>在哪里用，就在那里学。</p>
<h2 id="1-有目的的练习">1.  有目的的练习</h2>
<p>第一步，有目的的练习具有定义明确的特定目标，明确的目标将会引导正确的练习。</p>
<p>第二步，分解目标，并设定具体的计划执行。搞懂要如何做，怎么样做，做什么才能实现具体目标。</p>
<p>第三步，必须有反馈，有目的的练习必须包含反馈，必须知道自己做的对还是不对。如果不对，到底是做错了什么？</p>
<p>第四步，保持动力。 一些保持动力的方法，能够让你坚持艰苦的练习。看到自己的进步、获得相应的奖励、外界对你的改观、自身的专注力等</p>
<h2 id="2-构建心理表征">2.  构建心理表征</h2>
<p>心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物相对应的心理结构，或具体或抽象。<br>
大多数的刻意练习包括创建更加有效的心理表征，不论你在练习什么，都可以使用这<br>
些心理表征。</p>
<p>第一步，为心理表征的概念创建心理表征，去接触、了解、感受它。</p>
<p>第二步，找到黄金标准。所有领域中，一些训练方式总会比另一些更有效。</p>
<p>有目的的练习：首先辨别杰出人物，然后推测是什么使他们变得如此杰出，接着再提出训练方法，这些方法使你也能像他们那样表现卓越。</p>
<p>牢牢记住所有这些，目的是使你知道有目的的练习，并且为你指出更有效的方向。如果你发现某种方法管用，继续做下去；如果不管用，马上停下来。你越是能够调整自己的练习方法，模仿所在行业或领域中最杰出的人物，那你的练习也可能越是有效。</p>
<h2 id="3-训练技能">3. 训练技能</h2>
<p>刻意练习的心态提供了截然不同的观察视角：任何人都可以进步，但需要正确的方法。如果你没有进步，并不是因为你缺少天赋，而是因为你没有用正确的方法练习。一旦你理解了这一点，进步就只取决于你想出什么是“正确的方式”了。<br>
与传统不同的是，刻意练习的关键在于你能做什么，而不是你知道什么。 这同样是技能和知识之间的区别，普通的学习方法过度重视知识的学习，而轻视技能的训练，但是即便具备了相当多的知识，依然需要投入大量训练从而掌握技能的。<br>
如果你想提高棋艺，只和别人下棋，无法提高；你要单独研究特级大师的棋局，才可能提高。如果你想提高掷飞镖的技能，到酒店里和朋友玩，然后让输了的一方掏钱，水平不会提高；你只有花些时间单独练习，致力于复制你投掷成绩最好的那些投掷动作，才能提高。你可以系统地改变瞄准的飞镖靶上的不同点来提高你的控制水平。如果你想提高自己的保龄球技能，每周星期二晚上和你的保龄球联盟球队在一起玩，对你没什么帮助。你需要花一些时间和高水平的队友在一起，理想的情况是，致力于做一些艰难的球形排列，以便能够准确地控制球的走位，才是关键。依此类推。</p>
<h2 id="4-自己设计练习方法">4. 自己设计练习方法</h2>
<p>没有导师的时候，有效练习某种技能，需要三步即：专注、反馈、纠正。（研究大师级的资料）<br>
将技能分解成一些组成部分，以便反复地练习，并且有效地分析、确定你的不足之处，然后想出各种办法来解决它们。<br>
跨越停滞阶段，当不再进步的时候，需要找到停滞的原因，分析并制定攻克特定弱点的练习计划，最后尝试执行。</p>
<h2 id="5-保持动机">5. 保持动机</h2>
<p>有两种角度，让自己保持动机。<br>
第一， 弱化停下脚步的理由。 通过预留固定的练习时间，让自己在特定的时间段可以专注的练习，提前减少其他事情的干扰。不然，总会陷入无尽繁琐事的泥潭中。</p>
<p>第二， 增强前行的动机。通过参与团体或组织中，实现共同激励的目的。外在因素是影响最大是一种原因，包括得到别人的认同，荣誉，赞扬，名气等等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 简单实现PoW、PoS、DPoS 算法]]></title>
        <id>https://lianqiujun.co/post/python-jian-dan-shi-xian-powposdpos-suan-fa</id>
        <link href="https://lianqiujun.co/post/python-jian-dan-shi-xian-powposdpos-suan-fa">
        </link>
        <updated>2021-01-06T08:33:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="pow-简介">PoW 简介</h1>
<p>共识机制： 工作量证明（PoW）</p>
<h1 id="pow-实现">PoW 实现</h1>
<pre><code>from datetime import datetime
import hashlib

# 简单实现 PoW共识算法

NodesCount = 7

class Blockchain(object):
	def __init__(self, nodeAddress):
		self.globalBlocks = []
		self.nextBlock = None
		self.difficulty = 1
		self.height = 0
		self.nodeAddress = nodeAddress

	def generateBlock(self):
		Timestamp = str(datetime.now())
		if self.globalBlocks &gt; 0:
			PrevHash = self.globalBlocks[-1].Hash
		else:
			self.generateFirstBlock()
			return
		Hash = hashlib.sha256((PrevHash + Timestamp).encode(&quot;utf-8&quot;)).hexdigest()
		NodeAddress = self.nodeAddress
		Data = &quot;new block&quot;
		self.nextBlock = Block(Timestamp, PrevHash, Hash, NodeAddress, Data)


	def generateFirstBlock(self):
		Timestamp = str(datetime.now())
		PrevHash = &quot;0x0&quot;
		Hash = hashlib.sha256((PrevHash + Timestamp).encode(&quot;utf-8&quot;)).hexdigest()
		NodeAddress = self.nodeAddress
		Data = &quot;Start PoW Blockchain&quot;
		self.globalBlocks.append(Block(Timestamp, PrevHash, Hash, NodeAddress, Data))

	def isBlockHashMatchDifficulty(self,hashStr, difficulty) -&gt; bool:
		prefix = difficulty * &quot;0&quot;
		return prefix == hashStr[:difficulty]

	def confirmed_next_block(self):
		if self.isBlockHashMatchDifficulty(self.nextBlock.Hash, self.difficulty):
			self.nextBlock.Confirmed = self.nextBlock.Confirmed + 1

	def pow_add_next_block(self, otherNodeBlockchain):
		if otherNodeBlockchain.nextBlock.Confirmed &gt; self.nextBlock.Confirmed:
			self.globalBlocks = otherNodeBlockchain.globalBlocks
			self.nextBlock = otherNodeBlockchain.nextBlock

		if self.nextBlock.Confirmed &gt; NodesCount / 2:
			# 半数节点确认通过
			self.globalBlocks.append(self.nextBlock)


class Block(object):
	def __init__(self, Timestamp, PrevHash, Hash, NodeAddress, Data):
		self.Timestamp = Timestamp
		self.PrevHash = PrevHash
		self.Hash = Hash
		self.NodeAddress = NodeAddress
		self.Data = Data
		self.Confirmed = 0

	def __str__(self):
		print(&quot;-&quot;*30)
		return f&quot;Timestamp = {self.Timestamp},\nPrevHash = {self.PrevHash},\nHash = {self.Hash},\nNodeAddress = {self.NodeAddress},\nData = {self.Data}&quot;



def test_isBlockHashMatchDifficulty():
	hashStr = 'a1534392279bddbf9d43dde8701cb5be14b82f76ec6607bf8d6ad557f60f304e'
	difficulty = 1

	print(Blockchain(0).isBlockHashMatchDifficulty(hashStr, difficulty))


def test_blockchain1():
	blockchain = Blockchain(0)

	blockchain.generateFirstBlock()

	print(blockchain.globalBlocks[0].__str__())

def test_blockchain2():
	blockchain = Blockchain(1)
	blockchain.generateFirstBlock()
	blockchain.generateBlock()


if __name__ == &quot;__main__&quot;:
	test_isBlockHashMatchDifficulty()
	test_blockchain1()
</code></pre>
<h1 id="pos-简介">PoS 简介</h1>
<h1 id="pos-实现">PoS 实现</h1>
<pre><code>import hashlib
from random import randint

# 简单实现PoS 共识算法

nextBlocks = ['1a6562590ef19d1045d06c4055742d38288e9e6dcd71ccde5cee80f1d5a774eb']

class Block(object):
	def __init__(self, Timestamp, PrevHash, Hash, NodeAddress, Data):
		self.Timestamp = Timestamp
		self.PrevHash = PrevHash
		self.Hash = Hash
		self.NodeAddress = NodeAddress
		self.Data = Data
		self.Confirmed = 0

	def __str__(self):
		print(&quot;-&quot;*30)
		return f&quot;Timestamp = {self.Timestamp},\nPrevHash = {self.PrevHash},\nHash = {self.Hash},\nNodeAddress = {self.NodeAddress},\nData = {self.Data}&quot;


def getCoinBalance(block, NodeAddress):
	# 随机返回一个值当余额， 只做演示
	return randint(0, 100)

def getNodeAddress():
	# 随机返回一个地址， 只做演示
	num = str(randint(0, 100))
	address = hashlib.sha256(num.encode(&quot;utf-8&quot;)).hexdigest()

	return address

stackRecord = []
def AddressNodeRun():
	NodeAddress = getNodeAddress()
	for block in nextBlocks:
		coinNum = getCoinBalance(block, NodeAddress)  # 币数量
		for i in range(coinNum):
			stackRecord.append(NodeAddress)
AddressNodeRun()  # 节点一
AddressNodeRun()  # 节点二
AddressNodeRun()  # 节点三
print(stackRecord)

# 然后 ，随机从 stackRecord 中 随机选一个地址，作为胜利者，币越多， 股权越大，被选中概率越大

winner = stackRecord[randint(0, len(stackRecord))]

print(winner)

</code></pre>
<h1 id="dpos-简介">DPoS 简介</h1>
<h1 id="dpos-实现">DPoS 实现</h1>
<pre><code># DPoS 共识算法 简单实现

# 引入 见证者 节点
import hashlib
from random import randint

# 见证人数量 N
N = 3

class WitnessNode(object):
	def __init__(self, NodeAddress):
		self.NodeAddress = NodeAddress


def getNodeAddress():
	# 随机返回一个地址， 只做演示
	num = str(randint(0, 100))
	address = hashlib.sha256(num.encode(&quot;utf-8&quot;)).hexdigest()
	return address

class Block(object):
	def __init__(self):
		self.Votes = randint(0, 100)
		self.Timestamp = None
		self.PrevHash = None
		self.Hash = None
		self.NodeAddress = getNodeAddress()
		self.Data = None


# 当前见证人列表
WitnessList = [
Block(),
Block(),
Block()
]

NodeLists = [
Block(),
Block(),
Block(),
Block(),
Block(),
Block(),
Block()
]

# 投票选选择见证者
def vote():
	for block in NodeLists:
		vote = randint(0, 100)
		block.Votes = vote

	# 根据 票数 排序 , 找到最多的一个点
	maxVote = 0
	nextWitness = NodeLists[0]
	for block in NodeLists:
		if block.Votes &gt; maxVote:
			maxVote = block.Votes
			nextWitness = block

	return nextWitness


# 增加新 见证者
def addNewWitness():
	nextWitness = vote()
	WitnessList.append(nextWitness)

	print(&quot;新投票选举后，见证人列表：&quot;)
	for one in WitnessList:
		print(one.NodeAddress, &quot;票数：&quot;, one.Votes)


# 踢出 见证者中坏节点
def removeBadWitness():

	if len(WitnessList) &gt; N:
		# 排序踢出最低点
		minVote = 100
		badWitnessIndex = 0
		for index, block in enumerate(WitnessList):
			if block.Votes &lt; minVote:
				minVote = block.Votes
				badWitnessIndex = index
		print(&quot;投票数最少：&quot;, minVote)
		WitnessList.pop(badWitnessIndex)

	print(&quot;新见证人列表： &quot;)
	for one in WitnessList:
		print(one.NodeAddress, &quot;票数：&quot;, one.Votes)



addNewWitness()
removeBadWitness()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用工具手册]]></title>
        <id>https://lianqiujun.co/post/chang-yong-gong-ju-shou-ce</id>
        <link href="https://lianqiujun.co/post/chang-yong-gong-ju-shou-ce">
        </link>
        <updated>2021-01-06T07:57:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="命令">命令</h1>
<ul>
<li>
<p><a href="https://lianqiujun.co/post/git%E5%91%BD%E4%BB%A4/">Git 命令</a></p>
</li>
<li>
<p><a href="https://lianqiujun.co/post/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/">IDEA 快捷键</a></p>
</li>
<li>
<p><a href="https://lianqiujun.co/post/Linux%E5%91%BD%E4%BB%A4/">Linux 命令</a></p>
</li>
<li>
<p><a href="https://lianqiujun.co/post/mac%E5%91%BD%E4%BB%A4/">Mac 命令</a></p>
</li>
<li>
<p><a href="https://lianqiujun.co/post/vim%E5%91%BD%E4%BB%A4/">Vim 命令</a></p>
</li>
<li>
<p><a href="https://lianqiujun.co/post/Markdown%E8%AF%AD%E6%B3%95/">Markdown 语法</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程要素：函数和数据]]></title>
        <id>https://lianqiujun.co/post/bian-cheng-yao-su-han-shu-he-shu-ju</id>
        <link href="https://lianqiujun.co/post/bian-cheng-yao-su-han-shu-he-shu-ju">
        </link>
        <updated>2021-01-06T07:13:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://docs.python.org/zh-cn/3.8/library/index.html">Python 官方文档</a><br>
| <a href="http://composingprograms.com/pages/12-elements-of-programming.html">教程文档</a></p>
<h2 id="函数和数据">函数和数据</h2>
<p>计算机编程语言的作用，除了让计算机执行一些任务以外。更大的作用是整理计算过程，并且表达出编程者思想以供其他人阅读。<br>
所以，<strong>程序主要是写给人看的，恰好还能够让机器执行。</strong></p>
<p>“将简单的想法，通过组合成更复杂的想法，是编程语言的核心”  --- 抽象</p>
<p>任何一门功能强大的编程语言，都具有以下三种机制：</p>
<ul>
<li>“基本表达式”和“语句”： 表示语言提供的最简单的语法</li>
<li>“组合”手段： 通过这些手段可以从简单的元素构建复合元素</li>
<li>“抽象”手段： 通过该手段可以将复合元素命名给变量并进行操作</li>
</ul>
<h3 id="11-什么是表达式">1.1 什么是&quot;表达式&quot;？</h3>
<p>每一门语言都有它最原始的表达式，比如数字。</p>
<pre><code># 数字
&gt;&gt;&gt; 42 
42

&gt;&gt;&gt; 1 + 1 
2 

# 运算符和标记符号 
+ - * / &gt; &lt;  
{} [] ''  &quot;&quot;
# 保留字
if  for  while 


</code></pre>
<h3 id="12-什么是调用表达式">1.2 什么是&quot;调用表达式&quot;?</h3>
<p>复合表达式中，最重要的一种是：调用表达式<br>
它将一个函数对某些参数进行一些特定的处理。</p>
<pre><code>a = max(4,5)  # a = 5
b = min(3,9)  # b = 3 
c = str(3)    # c = '3'
</code></pre>
<h3 id="13-库函数">1.3 库函数</h3>
<ul>
<li>库函数，就是许多函数被组合在各种模块中，然后这些模块共同构成了Python的库</li>
<li>Python标准库， 就是安装Python时一起被安装的库函数，可以直接import然后使用</li>
<li>第三方库， 根据需求不同，自行下载导入的第三方写好的库函数包。</li>
</ul>
<p>详细的内容可以参考：<br>
<a href="https://docs.python.org/zh-cn/3.8/library/index.html">Python 官方文档</a></p>
<h3 id="21-变量与环境">2.1 变量与环境</h3>
<p>编程语言中，如果要对一些值进行计算操作，会使用变量作为值的引用。给定一个值的变量名，就是将这个值绑定给这个变量了。</p>
<pre><code>&gt;&gt;&gt; radius = 10
&gt;&gt;&gt; radius
10

&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; pi * 71 / 223
1.0002380197528042
</code></pre>
<p>= ,即赋值号。是最简单的“抽象”方式，可以通过赋值号，将一系列复合运算的结果值与某个变量绑定，完成一次简化的过程。</p>
<p>通过上述的方式： 计算机完成将变量的值绑定在变量上，然后通过访问这些变量来获取其对应的值。<br>
这意味着，解释器/编译器必须维护某些内存，以保证维持“变量”与“值”直接这样的绑定关系，这就是程序的运行“环境”。</p>
<h3 id="22-解析表达式与表达树">2.2 解析表达式与表达树</h3>
<p>多个基础的表达式，通过嵌套组合成复杂表达式，再由复杂的表达式，逐层拆解为基础表达式，这个过程类似一颗倒立的树木。<br>
表达树：<br>
max(min(a,b), max(c,d))</p>
<p>↓</p>
<p>max() → min(a,b), max(c,d)</p>
<p>↓</p>
<p>min() → a,b 和 max() → c,d</p>
<p>↓</p>
<p>a,b,c,d</p>
<p>直到不可拆分，就达到了树的节点，也就是最基础的表达式了。</p>
<pre><code>x = 3

sum(x,1)
</code></pre>
<p>每一行代码，只会执行得的两种结局： 1.执行过程 2.解析表达式</p>
<pre><code>x = 3 # 此时单纯的“赋值” ， 对“环境” 中的值不做影响， 不产生任何新的结果

y = sum(x,1) # 表达式解析后，对“环境”中的“值”： x 对应的值3 进行 加法运算，加1后，新的结果值从函数中返回并绑定给变量名y
</code></pre>
<h3 id="23-纯功能函数">2.3 纯功能函数</h3>
<p>纯函数就是有一些输入值，经过函数处理后，返回一些输出值。而且使用同样的值调用同一个函数两次，返回的值都是相同的。<br>
纯函数更加容易测试，而且可以更加稳定的构建复合表达式。</p>
<h3 id="24-非纯功能函数">2.4 非纯功能函数</h3>
<p>非纯函数就是除了会返回值以外，还会有其他的行为，比如“打印”或者“文件生成”，总之可能会造成计算机状态发生变化的行为。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程要素：入门]]></title>
        <id>https://lianqiujun.co/post/bian-cheng-yao-su-ru-men</id>
        <link href="https://lianqiujun.co/post/bian-cheng-yao-su-ru-men">
        </link>
        <updated>2021-01-06T07:03:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://pythontutor.com/composingprograms.html#mode=edit">在线环境</a> |<br>
<a href="https://docs.python.org/zh-cn/3.8/">Python文档</a></p>
<h3 id="1-抽象是什么">1. 抽象是什么？</h3>
<p>抽象就是人对世间万物的一种感受，通过符号表达出来的过程。就像&quot;红色&quot;就是一个抽象的概念，你脑海中不存在&quot;色彩&quot;这种概念的时候，它就是一个很抽象的东西，当我们第一次接触&quot;红色&quot;这个词语时，并不清楚，&quot;红色&quot;是甜的，酸的，软的，硬的？还是说是一种&quot;颜色&quot;，这是通过我们在生活中不断的从周围的环境中慢慢感知出来的。</p>
<p><strong>简单来说，抽象就是将内心的感受使用一种特定的符号表示出来的”过程“。</strong></p>
<p><strong>数学</strong> 就是一门抽象的学科， 0,1,2,3,4,+,-,*,=,&gt;,&lt; 这些符号本身是没有意义的，他们是一种抽象的表现，就像我们前面提到的“红色”。 人有2只眼睛，1个嘴巴，这里的“数量” 是人类对生活的观察和感受，“2”，“1”则是人类对“数量”的抽象符号表示。</p>
<h3 id="2-数学为什么是抽象的">2. 数学为什么是抽象的？</h3>
<p>数学的发展史告诉我们，数学起源于“算”，即起源于物体个数、田亩面积、物体长度等的计算。要计算就要有计算方法，当各种计算方法积累到一定数量的时候，数学家就进行分类，抽象出某类问题的计算公式、法则、原理，统称为算法。所以数学的童年时期叫做算术，它表现为一种经验知识。</p>
<h3 id="3-计算机和编程与抽象的关系">3. 计算机和编程与抽象的关系</h3>
<p>通过理解了抽象是什么，应该明白：<strong>“编程语言”不应该是你要学习的东西，而是用来理解表达你经验知识的工具。</strong><br>
计算机，则是你掌握和控制这些抽象概念的一个机器。<br>
如果做比喻的话:</p>
<ul>
<li>“1,2,3,4” 经过人脑的转换，被理解成人脑海中所理解的“数量”</li>
<li>“编程语言” 经过计算机的转换，变成了计算机执行的一系列“操作”</li>
</ul>
<p>而“编程”就是，人类将自己对于世界的感受，用自己能够理解的方式整理之后（算法+数据结构），然后通过语言符号和基本规则（a,b,c,d,1,2,3,4，+，-，%）抽象成计算机能够理解和执行的程序代码。</p>
<h3 id="4-编程语言">4.  编程语言</h3>
<p>不同的编程语言，有着自己的规范或是规则。但是它们的本质是一样的，就是对数学计算的抽象。我们采用的编程语言Python，就是一种“简单”的编程语言，为什么说它简单，就是因为Python的抽象更加接近人类理解的语言“英语”。</p>
<ul>
<li>注意：人类的语言“汉语”，“英语”也是一种抽象的表现。</li>
</ul>
<p>“红” 和 “red” 只是两个不同的符号，但它们的意义是一样的。<br>
就像Java中的“true” 和 Python中的“True”，代表的意义没什么不同。</p>
<h3 id="5-实践">5. 实践</h3>
<pre><code>from urllib.request import urlopen    # (2)

# 计算机程序只干两件事：
# (1) 计算一些值    
# (2) 执行一些动作

# 后面用符号标记每行代码的功能： （1），（2）

tianqi = urlopen('http://t.weather.sojson.com/api/weather/city/101020100')  # (2)

# 一、 什么是函数（function） ？
# 函数就是将处理数据的过程封装起来，“抽象”成一个符号来代替这些过程。
# urlopen() 就是Python库中的一个函数，url网址是一条数据，返回的结果
# 是另外一条数据,也就获得了内容，简化： B = urlopen(A)  
# 这就用了简单的一句话完成了一些动作，而复杂的过程存在于函数中。
# 这里将这些复杂过程抽象成一个函数名“urlopen”

data = set(tianqi.read().decode().split(',')) # (1)

# 二、 什么是对象（object）？
# set() 函数中经过 read() decode() split() 等一系列函数的复杂计算
# 最终得到data （对象），将“数据”和“处理数据的逻辑”紧密的联系在一起
# 最终简化： C = set(B)    B是开始的数据，C是“抽象”处理后的数据。


result = [w for w in data if len(w) &gt; 0]    # (2)

# 三、 计算机如何理解程序？解释器 （Interpreters）
# 语法中的表达式： result是经过了语言特定的表达式，获得的数据。
# 而在不同的编程语言，可能会有着各自的语法规则（特色）
# 那么计算机是如何理解不同的编程语言的？ 解释器/编译器
# Python、Java、Go、C# 每种语言都有自己特定的解释器。


# 最后， 我们将发现所有这些核心概念都是紧密相关的：
# 函数就是对象，对象就是函数，解释器是两者的实现表达的过程。
# 这些概念的清晰理解对于掌握编程技术至关重要。

</code></pre>
<h3 id="6-学习">6. 学习</h3>
<ul>
<li>实例1  双指针法</li>
</ul>
<pre><code>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1:
给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。
示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}


class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        # 先排序
        nums.sort()
        i = 0
        while i &lt; len(nums) - 1:
            if nums[i] == nums[i + 1]:
                nums.remove(nums[i])
            else:
                i = i + 1
        return len(nums)


</code></pre>
<ul>
<li>实例2  哈希表遍历</li>
</ul>
<pre><code>&quot;&quot;&quot;
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum

&quot;&quot;&quot;

class Solution:
    def twoSum(self, nums: list, target: int) -&gt; list:
        nl = []
        k = {}
        if len(nums) &lt; 2:
            return []
        elif (len(nums) == 2) and (target == nums[0] + nums[1]):
            return [0, 1]

        for i in range(len(nums)):
            k[nums[i]] = i

        for i in range(len(nums)):
            c = target - nums[i]  # 差值
            if (c in nums) and (k[c] != i):
                # 添加下标
                nl.append(k[c])
                nl.append(i)
        nl = list(set(nl))
        return nl

nums = [3, 2, 3]
target = 6
# [0, 2]
r = Solution().twoSum(nums, target)
print(r)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 编程要素]]></title>
        <id>https://lianqiujun.co/post/python-bian-cheng-yao-su</id>
        <link href="https://lianqiujun.co/post/python-bian-cheng-yao-su">
        </link>
        <updated>2021-01-06T07:01:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目录">目录</h1>
<h2 id="1-入门">1. <a href="#">入门</a></h2>
<h2 id="2-函数和数据">2. <a href="#">函数和数据</a></h2>
<h2 id="3-定义新功能">3. <a href="#">定义新功能</a></h2>
<h2 id="4-设计功能">4. <a href="#">设计功能</a></h2>
<h2 id="5-控制">5. <a href="#">控制</a></h2>
<h2 id="6-高阶函数">6. <a href="#">高阶函数</a></h2>
<h2 id="7-递归函数">7. <a href="#">递归函数</a></h2>
]]></content>
    </entry>
</feed>