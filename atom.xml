<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aturx.github.io/</id>
    <title>链 求 君</title>
    <updated>2020-06-30T16:03:47.845Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aturx.github.io/"/>
    <link rel="self" href="https://aturx.github.io/atom.xml"/>
    <subtitle>AturX  的个人网站</subtitle>
    <logo>https://aturx.github.io/images/avatar.png</logo>
    <icon>https://aturx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 链 求 君</rights>
    <entry>
        <title type="html"><![CDATA[比特币交易所]]></title>
        <id>https://aturx.github.io/post/bi-te-bi-jiao-yi-suo</id>
        <link href="https://aturx.github.io/post/bi-te-bi-jiao-yi-suo">
        </link>
        <updated>2020-06-30T15:58:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-什么是比特币交易所">1. 什么是比特币交易所？</h1>
<p>比特币交易所是一个数字市场，交易者可以在其中使用不同的法定货币或山寨币买卖比特币。它是一个在线平台，充当加密货币买卖双方之间的中介。</p>
<pre><code>重要要点

* 比特币交易所充当买卖双方之间的中介。

* 比特币交易所就像经纪人一样，你可以通过银行转账，电汇和其他常见的存款方式来存钱。但是，你通常需要为此服务付出一定的代价。

* 如果交易者想进行加密货币交易，他们需要支付一定的服务费，类似于你在不同国家/地区交易货币时银行收取的费用。

* 买卖基于与现有的交易系统，买方（买主）下达限价订单，然后当卖方（制造商）可以使用相应的加密货币将其出售。
</code></pre>
<h1 id="2-了解比特币交易所">2. 了解比特币交易所</h1>
<p>比特币交易平台使买家与卖家匹配。就像传统的证券交易所一样，交易者可以通过输入市场订单或限价订单来选择买卖比特币。当使用市场订单时，交易者授权交易所在最佳的价格时进行货币交易。设置了限价订单后，交易者将规定交易所在低于当前要价或高于当前出价的价格交易货币，具体高低取决于它们是在买还是卖。</p>
<p>为了可以在交易所上进行比特币交易，用户必须在交易所进行注册并经过一系列的验证过程以验证其身份。验证成功后，将为用户开设一个帐户，然后用户必须先将资金转入该帐户，然后才能购买硬币。</p>
<p>不同的交易所具有不同的付款方式，可用于存入资金，包括银行电汇，直接银行转账，信用卡或借记卡，银行汇票，汇票甚至礼品卡、支付宝、微信等。想要从其帐户中提款的交易者可以使用交易所提供的选项进行提款，包括银行转账，支付宝转账，微信转账，支票邮寄，现金交付，银行电汇或信用卡转账。</p>
<h1 id="3-去中心化交易所">3. 去中心化交易所</h1>
<p>去中心化的比特币交易所是在没有中央授权的情况下进行的交易。这种方式可以进行数字货币的点对点交易，而无需交换机构来促进交易。</p>
<p>去中心化交易所有很多好处。首先，许多加密货币用户认为去中心化交易所更适合大多数数字货币本身的去中心化结构。与其他类型的交易所相比，许多去中心化交易所也要求其成员提供较少的个人信息。</p>
<p>其次，如果用户将资产可以直接转让给其他用户，则无需将资产转让给交易所，从而降低了黑客和其他欺诈行为造成的盗窃风险。</p>
<p>第三，去中心化交易所可能不太容易受到价格操纵和其他欺诈性交易活动的影响。</p>
<p>另一方面，去中心化交易所（像所有加密货币交易所一样）必须以交易量和流动性的形式维持基本的用户量。并非所有的去中心化交易所都能实现这些重要的基础指标。</p>
<p>此外，与使用中心化交易所的用户相比，去中心化交易所的用户如果是欺诈的受害者，他们的追回损失的可能性更小。</p>
<h1 id="4-特别注意事项">4. 特别注意事项</h1>
<h1 id="41-费用">4.1 费用</h1>
<p>进行存款和取款需要付出一定的服务费，具体取决于转移资金的付款方式。</p>
<p>除了交易费和资金转移费外，交易者还可能需要支付货币兑换费，具体取决于比特币交易所接受的货币。如果用户将人民币转帐到仅以美元进行交易的交易所，则银行或交易所将收取费用将人民币转换为美元。与接受您当地货币的交易所进行交易是避免外汇费用的最佳方法。</p>
<p>所有比特币交易所都有交易费，该交易费适用于交易所内完成的每个买卖订单。收费率取决于所进行的比特币交易量。</p>
<h1 id="42-比特币钱包">4.2 比特币钱包</h1>
<p>请注意，比特币交易所不同于比特币钱包。前者提供了一个平台，供比特币买卖双方进行交易，而后者只是一种数字存储服务，供比特币持有者安全地存储其代币。从技术上讲，比特币钱包存储私钥，私钥用于授权交易和访问用户的比特币地址。大多数比特币交易所都为其用户提供比特币钱包，但可能会为此服务收费。</p>
<h1 id="43-比特币交易所的例子">4.3 比特币交易所的例子</h1>
<p>例如，在一个比特币交易所上，三个硬币卖家要求BTC / USD 8265.75，BTC / USD 8269.55和BTC / USD 8270.00。发起市场订单以购买比特币的交易员将以<code>8265.75</code>美元的最佳要价执行订单。如果仅五个比特币可用于最佳卖出价，而十个硬币可用于<code>$8269.55</code>，并且交易者希望以市场价格购买10个比特币，则该交易者的订单将以5个硬币（<code>$8265.75</code>）和其余5个硬币（<code>$8269.55</code>）成交。</p>
<p>但是，一个认为自己可以以更好的价格获得比特币的交易者可以将一个<code>限价单</code>设定为<code>2260.10</code>美元。如果卖方将其要价与该订单相匹配或将价格设置为低于此数字，则该订单将被执行。所有这些都是通过交易所完成的，而交易所则需要为其业务收取一定比例的交易费。</p>
<h1 id="5-最受欢迎的比特币交易所">5. 最受欢迎的比特币交易所</h1>
<p>比特币（BTC）交易所是虚拟货币世界尤其是其生态系统不可或缺的一部分。实际上，交易所是世界上许多数字货币用户必须使用代币和法定货币进行交易的主要手段。当今的数字货币交易所必须成功地平衡各种监管措施，保持最新的安全保护措施以减少欺诈和黑客攻击的可能性，并吸引用户以确保生存能力和足够的流动性。</p>
<p>Mt.Gox 交易所，昵称：门头沟。曾经享有垄断者地位的交易所。在2013年和2014年，它占据了BTC-USD交易量的80-90％。<br>
然而这个传奇性的交易所并没有永恒的存在，在大量的比特币显然从其保险箱中被盗之后，这一次最受欢迎的交易所就面临灭顶之灾。“门头沟被盗事件”可以说是一个警示性的故事。</p>
<p>现在，成功的交易所已经从其中学到了很多东西。</p>
<p>（1）火币网</p>
<ul>
<li>地址：https://www.huobi.com</li>
</ul>
<p>火币全球专业站，是火币集团旗下服务于全球专业交易用户的创新数字资产国际站，致力于发现优质的创新数字资产投资机会，目前提供四十多种数字资产品类的交易及投资服务，总部位于新加坡，由火币全球专业站团队负责运营。火币集团是一家具有全球竞争力与影响力的数字资产综合服务商，为超过130个国家百万级用户提供优质服务。在新加坡、香港、韩国、日本等多个国家和地区均有独立的交易业务和运营中心</p>
<p>（2）Binance 币安</p>
<ul>
<li>地址：https://www.binance.com</li>
</ul>
<p>币安(Binance)，国际领先的区块链数字资产国际站，向全球提供广泛的数字货币交易、区块链教育、区块链项目孵化、区块链资产发行平台、区块链研究院以及区块链公益慈善等服务，目前用户覆盖全球180多个国家和地区，以140万单/秒的核心内存撮合技术，是全球加密货币交易速度最快的平台之一，也是全球加密货币交易量最大的平台之一。</p>
<p>（3）Gate 比特儿</p>
<ul>
<li>地址：https://www.gate.io</li>
</ul>
<p>Gate国际站，是一家有态度的全球区块链资产国际站。从13年创办至今，已为来自全球超过130个国家的数百万用户，提供了近百种优质区块链资产品类的交易和投资服务。Gate致力于做一家值得信赖的安全、稳定、有信誉的区块链资产国际站，不仅为用户提供安全、便捷、公平的区块链资产交易服务，同时全面保障用户的交易信息安全和资产安全。</p>
<p>（4）OKEX</p>
<ul>
<li>地址：https://www.okex.com</li>
</ul>
<p>OKEX 是全球著名的数字资产国际站之一，主要面向全球用户提供比特币、莱特币、以太币等数字资产的现货和衍生品交易服务，隶属于OKEX Technology Company Limited。 OKEX创立时，获得了世界顶级投资人Tim Draper参与设立的创业工场百万美金的天使投资，Tim Draper先生同时也是Hotmail、百度、特斯拉等世界顶级企业的投资人。</p>
<p>（5）ZB 中币</p>
<ul>
<li>地址：https://www.zb.com</li>
</ul>
<p>ZB集团成立于2012年，旨在区块链的发展提供领导力和更加稳定的环境。总部设立于瑞士苏黎世，ZB集团经营着包括数字资产国际站、电子钱包、投资基金、研究机构和媒体在内的业务网络。集团的旗舰平台是行业领先的数字资产国际站 ZB。自2013年初推出以来，该平台在创新方面一直处于领先地位。ZB集团还拥有全球创新加密货币国际站ZBG、全球首个基于矿池的国际站http://BW.com。</p>
<p>（6）Bitfinex</p>
<ul>
<li>地址：https://www.bitfinex.com</li>
</ul>
<p>Bitfinex是全世界最大、最高级的比特币国际站之一，支持以太坊、比特币、莱特币、以太经典等虚拟币的交易，每天的成交量达30多亿人民币。提供币币交易，美元与币的交易。注册非常简单。2016年，Bitfinex大概有12万枚比特币通过社交媒体被盗。受此事件影响，当时比特币价格跌了20%。 优势： 支持美元交易 多种交易形式和功能 不足： 平台页面布局不符合国内用户使用习惯</p>
<p>（7）MXC 抹茶</p>
<ul>
<li>地址：https://www.mxc.io</li>
</ul>
<p>MXC国际站是由华尔街以及日本欧洲资深量化交易团队联合区块链资深从业者通过去中心化自组织形式创立的一个专注于区块链资产交流和交换的平台。MXC将为用户提供更加安全、便捷、智能的区块链资产流通服务，聚合全球优质区块链资产，融合全球最顶尖的安全技术，致力于打造全球顶级的区块链资产国际站。</p>
<p>（8）Dragonex 龙网</p>
<ul>
<li>地址：https://www.dragonex.io</li>
</ul>
<p>龙网（DragonEx）是新加坡虚拟货币国际站，2017年11月2日正式上线运营。上线同日发行平台币龙币（DT），持有其平台币DT可以获得平台收入分红。首创的开放平台引进的游戏应用爆红整个行业，同时开发了众多功能，如DK大乐透、扭龙蛋、期权预测、抵押借贷等等。目前支持C2C快速法币充提、USDT交易、ETH交易、BTC交易、DC交易、合约交易、杠杆交易。</p>
<p>（9）Coinw 币赢国际站</p>
<ul>
<li>地址：https://www.coinw.ai</li>
</ul>
<p>币赢网Coinw是中国香港开设的著名数字资产国际站，面向全球用户提供BTC、ETH、HC、EOS、LEEK、ELF、MTC等优质主流数字资产的交易服务。币赢网Coinw提供移动端APP，方便用户随时随地操作。</p>
<p>（10）ZBG</p>
<ul>
<li>地址： https://www.zbg.com</li>
</ul>
<p>ZBG 在2018年成立于香港，凭借创新、高效和全球化的运营，ZBG在短时间内迅速跻身行业世界前十，被誉为新一线国际站。 目前平台已支持七国语言访问，为全球180万加密资产投资者提供服务，平台日均活跃超过12万。在未来，ZBG将继续拓展全球市场，为全球区块链爱好者提供稳定、安全、快捷的区块链项目上市、加密资产投资等服务。</p>
<h1 id="交易所购买比特币的成本">交易所购买比特币的成本</h1>
<p>交易比特币需要多少钱？除了比特币本身的价格外，每个加密货币交易所都会在客户购买和出售硬币时增加交易费用。这些费用包括制造商（通过限价订单增加订单簿流动性）和收取者（通过市场订单从订单簿中减去流动性）费用。在某些情况下，如果限价单已经存在于订单簿中，则加密货币交易者可能会产生制造商以及交易商的费用。</p>
<p>加密货币交易所主要通过两种方式来计算费用：每笔交易采用固定的费用，或者采用帐户30天交易量的百分比收取费用。结合两种情况，他们根据交易量的大小决定具体的服务费用。</p>
<pre><code>重要要点

* 自从2009年首次推出比特币以来，买卖加密货币变得越来越受欢迎。

* 现在存在数十种大型在线交易所，以帮助买卖数字货币以及彼此之间进行加密货币交易。

* 所涉及的典型成本包括支付给交易所的交易佣金，买卖价差的宽度以及向您的银行帐户转移资金的费用。

</code></pre>
<p>在加密货币交易所进行交易时要考虑的四件事 交易者在购买加密货币时必须考虑四件事。</p>
<p>首先，在大多数司法管辖区，加密货币交易所不受监管。全球一些国家/地区的大多数监管机构在其一些最大的交易市场中都采取了放任不管的方式来进行加密货币监管。例如，在最大的加密货币交易市场中，加密货币交易所受美国众多法规的约束。截至2017年初，中国禁止某些类型的加密货币交易，占总交易量的90％。</p>
<p>其次，加密货币交易所的收费服务旨在鼓励频繁交易价值数千美元的大笔交易。费用通常随着交易量和交易频率的增加而降低。因此，在加密货币交易中，小的订单和不频繁的订单并不具有成本效益。例如，某些交易所对价值10,000,000美元及以上的交易不收取任何费用。</p>
<p>第三，交易所鼓励使用加密货币进行交易。法定货币通常会在交易所产生存款和取款费，具体取决于付款方式。但是在大多数情况下，与其他硬币一起购买加密货币是免费的。在某些情况下，可能需要支付少量费用才能为所需的加密货币设置钱包。</p>
<p>第四，大多数知名的加密货币交易所都不提供对所有硬币的访问权限。但是，在许多情况下，交易者可以将资金从一个钱包转移到另一个钱包，并使用法定货币或加密货币为他们的交易账户注资。例如，希望以市值排名前15位的加密货币卡尔达诺（ADA）的交易者目前无法直接在流行的Coinbase交易所上进行交易。 但是，交易者可以使用法定货币在Coinbase上购买比特币。另一家交易所Binance已经为用户提供了从其他钱包中导入硬币的功能。一旦他们的Binance帐户中有比特币，他们就可以使用它购买交易所中列出的ADA。多个钱包在不同交易所之间的转账在每一端会产生少量费用。</p>
<h1 id="总结">总结</h1>
<p>对于个人资产的分配管理来说，用于交易的资产建议保留在交易所，很少交易的大额资产建议保留在个人钱包中。对于大额且进行交易的资产，可以分开分配在多个主流的交易所中。由于交易所被盗事件经常发生，加密货币放置在交易所中并不是万无一失的选择。分开管理，也同样分散了风险，主流交易所都被盗窃的概率还是很小的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Pipenv管理Python虚拟环境]]></title>
        <id>https://aturx.github.io/post/shi-yong-pipenv-guan-li-python-xu-ni-huan-jing</id>
        <link href="https://aturx.github.io/post/shi-yong-pipenv-guan-li-python-xu-ni-huan-jing">
        </link>
        <updated>2020-06-29T03:16:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-pipenv-的安装">1. Pipenv 的安装</h1>
<p>python3+ 安装 pipenv 的依赖包</p>
<pre><code>pip3 install pipenv
</code></pre>
<h1 id="2-创建pipenv-的虚拟环境">2. 创建Pipenv 的虚拟环境</h1>
<p>具体执行步骤如下：</p>
<p>（1）命令行进入项目目录下</p>
<p>（2）创建Python虚拟环境</p>
<p>执行<code>pipenv --python 3.7</code><br>
生成Python 3.7 版本虚拟环境。（本地必须先具备该版本Python环境）<br>
或者可以使用，<code>pipenv --three</code> 则使用系统当前的 python3 版本生成虚拟环境。</p>
<p>完成创建后，项目目录下会产生<code>Pipfile</code>记录项目依赖。</p>
<p>（3）验证环境</p>
<p>执行<code>pipenv --venv</code>,显示当前虚拟环境所用的解释器位置。</p>
<p>（4）配置Pycharm的虚拟环境</p>
<p>根据（3）中获得的虚拟环境解释器位置，在Pycharm中进行配置，具体过程如下。</p>
<h1 id="3-pycharm-连接虚拟环境">3. Pycharm 连接虚拟环境</h1>
<p>（1）配置Pycharm项目虚拟环境</p>
<p>打开 <code>Pycharm</code>，点击 <code>File -&gt; settings -&gt; Project</code> 选择你要更改的环境，如果没有或点击<code>+</code>进行环境添加。<br>
命令行中用<code>pipenv --venv</code>,查看当前虚拟环境所用的解释器位置，查到项目的虚拟环境目录进行配置。</p>
<p>在添加环境时，找到目录中<code>Script</code>文件夹中<code>python.exe</code>后点击确认。</p>
<figure data-type="image" tabindex="1"><img src="https://aturx.github.io//post-images/1593401275807.PNG" alt="" loading="lazy"></figure>
<p>现在就获得了一个干净的Python 3.7 虚拟环境。</p>
<p>（2）配置Pycharm命令行环境</p>
<p>避免命令行中Python执行环境和系统环境搞混淆，需要进行配置。</p>
<p>设置修改项目中的 Python Console 控制台，避免和系统环境搞混<br>
<code>File -&gt; settings -&gt; Project</code> 中<code>结构、执行、部署</code>进行修改<code>Console</code>,设置好工作目录为项目目录。</p>
<figure data-type="image" tabindex="2"><img src="https://aturx.github.io//post-images/1593401293189.PNG" alt="" loading="lazy"></figure>
<h1 id="4-安装项目依赖包">4. 安装项目依赖包</h1>
<h3 id="下载慢修改源">下载慢，修改源</h3>
<pre><code>[[source]]

url = &quot;https://mirrors.aliyun.com/pypi/simple&quot;
verify_ssl = true
name = &quot;pypi&quot;
</code></pre>
<h3 id="命令">命令：</h3>
<ul>
<li>pipenv shell</li>
</ul>
<p>进入pipenv的虚拟环境中。</p>
<ul>
<li>pipenv install</li>
</ul>
<p>安装<code>Pipfile</code>中的依赖包。</p>
<ul>
<li>pipenv install xxx</li>
</ul>
<p>安装指定依赖包，并更新至<code>Pipfile</code>。</p>
<ul>
<li>pipenv lock</li>
</ul>
<p>锁定项目依赖，生成<code>Pipfile.lock</code>文件。</p>
<ul>
<li>pipenv run xxx.py</li>
</ul>
<p>在虚拟环境下执行脚本。</p>
<h1 id="5-常用操作">5. 常用操作</h1>
<ul>
<li>pipenv shell</li>
</ul>
<p>pipenv新建的虚拟环境放在统一的目录下, 在某个目录下运行pipenv<br>
shell时pipenv会自动在虚拟环境目录下搜索以当前目录名称开头的虚拟环境目录,如果没找到则判断为无虚拟环境。</p>
<ul>
<li>pipenv graph</li>
</ul>
<p>查看依赖包。</p>
<ul>
<li>pipenv install requests</li>
</ul>
<p>用Pipenv 安装包。</p>
<ul>
<li>pipenv install pytest --dev</li>
</ul>
<p>分环境配置包，有些包只在开发环境下使用dev</p>
<ul>
<li>pipenv uninstall requests</li>
</ul>
<p>卸载Python包</p>
<ul>
<li>pipenv uninstall --all</li>
</ul>
<p>卸载全部</p>
<ul>
<li>pipenv lock<br>
有时lock文件不存在了，再次生成。</li>
</ul>
<h1 id="6-参考">6. 参考</h1>
<ul>
<li>
<p><a href="https://cuiqingcai.com/5846.html">Pipenv的常用操作</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_20728575/article/details/82949529">Pycharm使用Pipenv</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 异步IO编程]]></title>
        <id>https://aturx.github.io/post/python-yi-bu-io-bian-cheng</id>
        <link href="https://aturx.github.io/post/python-yi-bu-io-bian-cheng">
        </link>
        <updated>2020-06-12T06:28:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-什么是异步io">1. 什么是异步IO？</h1>
<p>在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。</p>
<p>因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。</p>
<p>多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。</p>
<p>有一种解决方案可以解决这个问题，即异步IO编程：</p>
<p>当遇到IO操作时，代码只负责发出IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。当IO操作完成后，将收到一条“IO完成”的消息，处理该消息时就可以直接获取IO操作结果。</p>
<h1 id="2-python-中的协程及使用">2. Python 中的协程及使用</h1>
<p>协程，又称微线程，英文名Coroutine。</p>
<p>协程的特点是一个线程执行，但是达到多线程的效果。<br>
正常程序A调用B，B调用C, <code>A -&gt; B -&gt; C</code> 函数层次调用，结果依次返回。但是采用协程后，B可中断，不必等待C执行完就能返回A，A可继续执行（A一般为循环，下个周期可接收到C完成的反馈结果）。</p>
<ol>
<li>普通函数</li>
</ol>
<pre><code>def function():
    return 1
</code></pre>
<ol start="2">
<li>生成器函数</li>
</ol>
<pre><code>def generator():
    yield 1
</code></pre>
<ol start="3">
<li>异步函数（协程）</li>
</ol>
<pre><code>async def async_function():
    return 1
</code></pre>
<ol start="4">
<li>异步生成器</li>
</ol>
<pre><code>async def async_generator():
    yield 1
</code></pre>
<p>在3.5过后，我们可以使用async修饰将普通函数和生成器函数包装成异步函数和异步生成器。</p>
<h1 id="3-传统的同步io实现">3. 传统的同步IO实现</h1>
<pre><code>from datetime import datetime
from time import sleep
import threading
import asyncio

def hello():
   print(&quot;1111&quot;)
   sleep(3)
   print(&quot;2222&quot;)

def world():
   print(&quot;3333&quot;)
   sleep(2)
   print(&quot;4444&quot;)

def demo_no_async():
   start = datetime.now()
   # 传统方式 顺序执行  耗时约 5 秒
   hello()
   world()
   print(datetime.now() - start)

demo_no_async()
</code></pre>
<h1 id="4-异步io-采用python-协程实现">4. 异步IO 采用Python 协程实现</h1>
<h2 id="python-35-之前版本写法">Python 3.5 之前版本写法</h2>
<p>Python 3.5 之前写法 ： 协程实现单线程并发， 最快继续边界是最大耗时操作时长  即 5秒</p>
<pre><code>

@asyncio.coroutine
def hello0():
	print('Hello world! (%s)' % threading.currentThread())
	yield from asyncio.sleep(5)
	print('Hello again! (%s)' % threading.currentThread())

@asyncio.coroutine
def hello1():
	print('Hello world! (%s)' % threading.currentThread())
	yield from asyncio.sleep(2)
	print('Hello again! (%s)' % threading.currentThread())

@asyncio.coroutine
def hello2():
	print('Hello world! (%s)' % threading.currentThread())
	yield from asyncio.sleep(3)
	print('Hello again! (%s)' % threading.currentThread())


def run():
	start = datetime.now()
	loop = asyncio.get_event_loop()
	tasks = [hello0(), hello1(),hello1(),hello1(), hello2(), hello2(), hello2(), hello0()]
	loop.run_until_complete(asyncio.wait(tasks))
	loop.close()
	print(datetime.now() - start)

run()
</code></pre>
<h2 id="python-35-之后版本关键字写法">Python 3.5 之后版本关键字写法</h2>
<p>python3.5 之后  异步IO 实现 单线程高并发效果</p>
<pre><code>
async def async_hello():
	print('async_hello! (%s)' % threading.currentThread())
	await asyncio.sleep(4)
	print('async_hello again! (%s)' % threading.currentThread())

async def async_world():
	print('async_world! (%s)' % threading.currentThread())
	await asyncio.sleep(7)
	print('async_world again! (%s)' % threading.currentThread())

def demo_async():
	start = datetime.now()
	loop = asyncio.get_event_loop()
	# 异步IO方式 执行 任务
	tasks = [async_hello(), async_world()]
	loop.run_until_complete(asyncio.wait(tasks))
	loop.close()
	print(datetime.now() - start)

demo_async()

</code></pre>
<h1 id="参考">参考</h1>
<p><a href="https://zhuanlan.zhihu.com/p/27258289">Python Async/Await入门指南</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1048430311230688">async/await</a></p>
<p><a href="https://github.com/aturX/100DD100/tree/master/day059">本文源码</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用以太坊域名服务（ENS）的好处]]></title>
        <id>https://aturx.github.io/post/shi-yong-yi-tai-fang-yu-ming-fu-wu-ensde-hao-chu</id>
        <link href="https://aturx.github.io/post/shi-yong-yi-tai-fang-yu-ming-fu-wu-ensde-hao-chu">
        </link>
        <updated>2020-06-11T02:30:14.000Z</updated>
        <content type="html"><![CDATA[<p>今天，介绍一下如何获取自己的ENS域名，以便其他人可以轻松地将Ether发送给您。</p>
<h1 id="什么是以太坊域名服务ens">什么是以太坊域名服务（ENS）？</h1>
<p>以太坊名称服务（Ethereum Name Service）是一个基于以太坊区块链的分布式、开放和可扩展的命名系统。ENS 域名让人们不用再复制或输入冗长的区块链地址。通俗地说，ENS 就是区块链中的域名系统。</p>
<h1 id="使用ens的好处">使用ENS的好处？</h1>
<p>ENS（以太坊域名服务的缩写）是基于智能合约的，建立在以太坊的去中心化应用程序（dApp）。</p>
<p>ENS 可以让你采用类似<code>hello.eth</code>这种的域名来代替<code>0x21eb14be414eDC32A819525C231c3eE97dc811F8</code>这样长的十六进制地址。</p>
<p>这意味着你将能够将数字货币直接转账到某个域名下而不需要记忆地址。但这还不是全部。ENS也可用于访问Swarm和IPFS内容哈希以及其他标识过程。它使用户可以轻松浏览并访问这些网络上的文件。可以在提供与元数据有关的名称（例如合同的ABI和用户的类似Whois的信息）的同时完成。</p>
<h1 id="ens与dns之间的区别">ENS与DNS之间的区别</h1>
<p>从某种意义上说，ENS的目标与互联网的DNS（域名服务）相似。然而，由于以太坊区块链提供的功能和限制，它们是截然不同的结构设计。<br>
尽管ENS是基于以太坊智能合约构建的，但它不会遭受影响DNS系统的相同安全问题。因此，它能让域名正常工作。</p>
<h1 id="为什么需要ens域名">为什么需要ENS域名？</h1>
<p>如前所述，以太坊名称服务ENS摆脱了必须复制或输入冗长的十六进制地址的繁琐过程。而且使用ENS，您将可以轻松地将资金发送到域名。然后，您将在mycontract.eth上使用智能合约，并在swarmsite.eth上查看由集群托管的站点。</p>
<p>获得ENS域后，您可以将其指向您选择的任何资金，还可以创建子域并根据需要分配它们。</p>
<p>值得注意的是，ENS是一个完全分散的系统。因此，可以通过拍卖过程在<code>.eth</code>顶级域（例如<code>hello.eth</code>）下创建新的ENS域。这发生在以太坊区块链上。而且，任何人都可以自己参加和购买ENS域。</p>
<h1 id="如何获得域名">如何获得域名？</h1>
<h2 id="域名注册拍卖">域名注册拍卖</h2>
<p>域名拍卖的运作方式，分为三个不同的阶段。</p>
<ul>
<li>
<p>阶段1<br>
您需要为要购买的名称进行拍卖，然后出价。完成此操作后，其他参与者将启动为期3天的计时器，以对标题进行出价。此时，投标人的详细信息已隐藏。因此，没有人能说出您的出价，甚至是出价的名称。</p>
</li>
<li>
<p>第二阶段<br>
在为期3天的拍卖结束后，又开始了2天的“展示”期。在此期间，每个投标人都必须透露其投标细节。否则，他们将失去全部出价。如果您不是出价最高的人，则会退还您的出价，减去0.5％的费用，该费用将被扣除。</p>
</li>
<li>
<p>第三阶段<br>
在为期2天的展示期过后，将宣布出价最高的获胜者。但是他或她将必须支付第二高的出价者的金额。<br>
此金额在合同中指定。只要中标者控制ENS名称即可。获胜者被授权发送“最终”交易以退还任何额外资金。并且将为其分配新ENS域的命令。<br>
赢得名称拍卖后，至少在域名用于期间，ENS域名就属于他们的域名。但是，获胜者可能会决定释放该名称。持有所有权至少一年后，他/她可能会收回全部押金。</p>
</li>
</ul>
<p>请注意，并非所有ENS名称都可以立即进行出价，因为它们会在八周内逐步发布拍卖。原因是系统需要扩大规模，并且在此期间需要发现并修复错误。</p>
<h2 id="域名购买">域名购买</h2>
<p>现在让我们向您展示如何获得您的域名，以便其他人可以轻松地将Ether发送给您。</p>
<p>您可以使用以下列出的四个用户友好界面自己购买ENS域：</p>
<ul>
<li>
<p><a href="https://app.ens.domains/">registrar.ens.domains，</a>“官方” Dapp。这需要启用了区块链的浏览器（Mist，带有Metamask插件的chrome或带有浏览器插件的奇偶校验）。</p>
</li>
<li>
<p><a href="https://www.myetherwallet.com/">My Ether</a> Wallet，一个完全在您自己设备中运行的开源钱包，它要求您上载和使用钱包的凭据。</p>
</li>
<li>
<p>ETHTools的ENS集成是一个开源解决方案，可以指导您完成整个过程，并使用服务器端存储来简化招标。</p>
</li>
<li>
<p>可以使用JavaScript控制台和web3.js中的命令行帮助您出价。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 多线程实践]]></title>
        <id>https://aturx.github.io/post/python-duo-xian-cheng-shi-jian</id>
        <link href="https://aturx.github.io/post/python-duo-xian-cheng-shi-jian">
        </link>
        <updated>2020-06-09T02:22:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-python-多线程标准库">1. Python 多线程标准库</h1>
<p>Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，使用threading这个高级模块就足够了。</p>
<h1 id="2-创建并使用多线程">2. 创建并使用多线程</h1>
<pre><code>import time, threading


# 新线程执行的代码:
def say_some():
	print('--------线程 [{}] 开始运行...'.format(threading.current_thread().name))
	n = 0
	while n &lt; 7:
		n = n + 1
		print('thread [{}] &gt;&gt;&gt; [{}]'.format(threading.current_thread().name, n))
		time.sleep(n)
	print('线程 [{}] 结束运行...'.format(threading.current_thread().name))


def demo1():
	print('--------线程 [{}] 开始运行...'.format(threading.current_thread().name))
	t = threading.Thread(target=say_some, name='SaySomeThread')
	t.start()
	t.join()  # 线程结束后继续执行
	print('线程 [{}] 结束运行...'.format(threading.current_thread().name))

</code></pre>
<h1 id="3-线程的锁">3. 线程的锁</h1>
<p>多线程和多进程最大的不同在于，多进程中，同一个变量，<br>
各自有一份拷贝存在于每个进程中，互不影响，而多线程中，<br>
所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，<br>
因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br>
所以，和多进程相比，多线程需要对特定的变量加锁，保证其修该操作不会乱。</p>
<pre><code># 锁
lock = threading.Lock()


def run_thread(n):
	for i in range(100000):
		# 先要获取锁:
		lock.acquire()
		try:
			# 修改变量
			n = n + 1
		finally:
			# 改完了一定要释放锁:
			lock.release()

</code></pre>
<p>包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。</p>
<h1 id="4-python-伪多线程原因gil锁">4. Python “伪”多线程原因：GIL锁</h1>
<p>使用C、C++或Java来写特定死循环，直接可以把全部核心跑满，4核就跑到400%，<br>
但是Python跑相同代码，只能将CPU跑到100%左右。</p>
<p>Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，<br>
任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，<br>
解释器就自动释放GIL锁，让别的线程有机会执行。</p>
<p>GIL全局锁实际上把所有线程的执行代码都给上了锁，<br>
所以，多线程在Python中只能交替执行，<br>
即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>解决方案： 多进程<br>
Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。<br>
多个Python进程有各自独立的GIL锁，互不影响。</p>
<h1 id="5-线程全局变量">5. 线程全局变量</h1>
<pre><code># 创建全局ThreadLocal对象:
local_something = threading.local()

# 1  执行线程
def process_say_someting():
	# 获取当前线程关联的student:
	text = local_something.content
	print('Hello, %s (in %s)' % (text, threading.current_thread().name))


# 2  赋值线程
def process_thread(t):
	# 为该线程，绑定ThreadLocal的值:
	local_something.content = t
	process_say_someting()


t1 = threading.Thread(target=process_thread, args=('hhhhh',), name='Thread-A')
t2 = threading.Thread(target=process_thread, args=('wwwwww',), name='Thread-B')
t1.start()
t2.start()
t1.join()
t2.join()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 元类及ORM框架实现]]></title>
        <id>https://aturx.github.io/post/python-yuan-lei-ji-orm-kuang-jia-shi-xian</id>
        <link href="https://aturx.github.io/post/python-yuan-lei-ji-orm-kuang-jia-shi-xian">
        </link>
        <updated>2020-06-09T02:22:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="python-元类及orm框架实现">Python 元类及ORM框架实现</h1>
<h2 id="python-数据库操作">Python 数据库操作</h2>
<p>数据库操作的基本过程：</p>
<ol>
<li>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection</li>
</ol>
<pre><code># 用 Python 的 sqlite 数据库举例

import sqlite3   

# 连接数据库，获得Connection
db_con = sqlite3.connect('demo.db')

print(type(db_con))  # &lt;class 'sqlite3.Connection'&gt;
</code></pre>
<ol start="2">
<li>连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果</li>
</ol>
<pre><code>sql = &quot;select * from user&quot;
cur = db_con.execute(sql)
print(type(cur))    # &lt;class 'sqlite3.Cursor'&gt;
</code></pre>
<ol start="3">
<li>在Python中操作数据库时，要先导入数据库对应的<strong>驱动</strong>，然后，通过Connection对象和Cursor对象操作数据</li>
</ol>
<pre><code>import sqlite3    # 数据库驱动
</code></pre>
<h2 id="对象关系映射object-relational-mapperorm">对象关系映射（Object-Relational Mapper，ORM）</h2>
<p>ORM 是一个数据抽象层，在ORM的概念中，类对应数据库中的表，属性对应列，<br>
类的单个实例表示数据库中的一行数据。 Python 编程语言常用的ORM<br>
框架是SQLAlchemy。，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，<br>
简言之便是：将对象转换成SQL，然后使用数据库API执行SQL并获取执行结果。<br>
SQLAlchemy本身无法操作数据库，其必须以来pymsql等第三方插件，Dialect用于和数据API进行交流，<br>
根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作。</p>
<pre><code>MySQL-Python
    mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;
  
pymysql
    mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;]
  
MySQL-Connector
    mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;
  
cx_Oracle
    oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...]
  
更多详见：http://docs.sqlalchemy.org/en/latest/dialects/index.html
</code></pre>
<ul>
<li>SQLAlchemy 底层处理<br>
使用 Engine/ConnectionPooling/Dialect 进行数据库操作，Engine使用ConnectionPooling连接数据库，然后再通过Dialect执行SQL语句。</li>
</ul>
<pre><code>def SQLAlchemy_demo():
	from sqlalchemy import create_engine
	import sqlalchemy
	import pymysql
	# 创建引擎
	engine = create_engine(&quot;mysql+pymysql://xxxxx:xxxxx@127.0.0.1:3306/mysql&quot;, max_overflow=5)
	# 执行sql语句
	result = engine.execute(&quot;select * from searcher_websites&quot;)
	res = result.fetchall()
	print(res)
</code></pre>
<ul>
<li>ORM 功能</li>
</ul>
<p>ORM 映射对象，完成建表，查询等，操作数据库方式</p>
<pre><code>
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine, Column, Integer, String
# ORM解决中文编码问题 sqlalchemy 默认使用latin-1进行编码。
  
engine = create_engine(&quot;mysql+pymysql://user:password@127.0.0.1:3306/mysql?charset=utf8&quot;, max_overflow=5,encoding='utf-8')
Base = declarative_base()

# 绑定数据库引擎
Session = sessionmaker(bind=engine)
session = Session()


# 创建于表映射的 实体类
class Webs(Base):
	__tablename__ = 'webs'
	id = Column(Integer, primary_key=True)    # 唯一编号
	name = Column(String(50), default='', unique=False)
	url = Column(String(50), default='', unique=True)
	cent = Column(Integer, default=0)
    
    # 打印内容
	def __str__(self):
		return (f'id={self.id}, name={self.name}, url={self.url} cent={self.cent} ')


def SQLAlchemy_ORM_demo(session):

	# 创建表
	Base.metadata.create_all(engine)  # 创建表
	# Base.metadata.drop_all(engine)   #删除表
	obj = Webs(name=&quot;baidu&quot;, url='http://www.baidu.com')

	# 添加数据
	session.add(obj)
	session.commit()
	# 查询 / 条件查询数据
	# session.query(Webs).filter(Webs.id &gt; 2)
	q = session.query(Webs).all()
	for i in q:
		print(i)

SQLAlchemy_ORM_dem(session)
</code></pre>
<h2 id="orm-框架实现">ORM 框架实现</h2>
<p>Python 中可以使用metaclass （元类）进行创建class。<br>
简单的解释就是：</p>
<ul>
<li>
<p>定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p>
</li>
<li>
<p>metaclass(元类)以后，就可以根据这个元类创建出类，所以：先定义metaclass，然后创建类。<br>
创建顺序是：先定义metaclass，就可以创建类，最后创建实例。<br>
要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>
</li>
</ul>
<p>如上章所示，使用ORM框架提供的<code>Column</code>类或者'Field'类来对应数据库的表字段。</p>
<p>首先来定义<code>Field</code>类，它负责保存数据库表的字段名和字段类型：</p>
<pre><code># Field 类 它负责保存数据库表的字段名和字段类型：
class Field(object):

    def __init__(self, name, column_type):
        self.name = name
        self.column_type = column_type
        self.default = None  # 字段默认值

    def __str__(self):
        return f'{self.__class__.__name__}:{self.name}'


# 在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField
class StringField(Field):
    # 实现 varchar 类型
    def __init__(self, name):
        super(StringField, self).__init__(name, 'varchar(256)')

class IntegerField(Field):
    # 实现 int 类型
    def __init__(self, name):
        super(IntegerField, self).__init__(name, 'bigint')

# 编写 metaclass 类, 元类继承 type
class ModelMetaclass(type):
    # name 名字  bases  继承父类   attrs 继承属性
    def __new__(cls, name, bases, attrs):
        if name == 'Model':
            return type.__new__(cls, name, bases, attrs)

        # 重点理解： 不同的表 字段不同，添加的 方法 属性 也不同
        mappings = dict()
        for k, v in attrs.items():
            # 在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中
            if isinstance(v, Field):
                print('Found mapping: %s ==&gt; %s' % (k, v))
                mappings[k] = v


        for k in mappings.keys():
            # 从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性
            attrs.pop(k)
        attrs['__mappings__'] = mappings  # 保存属性和列的映射关系
        attrs['__table__'] = name  # 假设表名和类名一致
        return type.__new__(cls, name, bases, attrs)

# 创建 基类
class Model(dict, metaclass=ModelMetaclass):

    def __init__(self, **kwargs):
        super(Model, self).__init__(**kwargs)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;'Model' object has no attribute '%s'&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        for k, v in self.__mappings__.items():
            # 更加字段 建立映射  不满足条件的不映射
            fields.append(v.name)
            params.append(getattr(self, k, v.default))

        sql = f'''insert into {self.__table__} ({&quot;,&quot;.join(fields)}) values ('{&quot;','&quot;.join(params)}')'''
        print('SQL: %s' % sql)
        print('ARGS: %s' % str(params))


# 使用 ORM
class User(Model):
    # 定义类的属性到列的映射：
    id = IntegerField('id')
    name = StringField('username')
    email = StringField('email')
    password = StringField('password')

# 创建一个实例：
u = User(id='0000', name='admin', email='test@gmail.com', password='admin')
# 保存到数据库：
u.save()

# 实现效果： ORM框架就是将实体类映射成可执行的SQL操作数据库
</code></pre>
<h2 id="参考">参考</h2>
<ul>
<li>
<p><a href="https://www.cnblogs.com/pycode/p/mysql-orm.html">使用Python ORM框架</a></p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1018490605531840">实现Python ORM框架</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/35746049">Djang ORM 源码分析</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比特币挖矿的理解]]></title>
        <id>https://aturx.github.io/post/bi-te-bi-wa-kuang-de-li-jie</id>
        <link href="https://aturx.github.io/post/bi-te-bi-wa-kuang-de-li-jie">
        </link>
        <updated>2020-06-02T06:40:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="比特币挖矿的本质">“比特币挖矿”的本质</h2>
<p>你很可能会听到“比特币挖矿”一词，然后你的脑海中就开始想象拿着铲子的矿工，在泥土中挖掘金子的场景。</p>
<p>事实证明，这样的比喻距离还不算贴切，比特币的挖掘远没有那么迷人，但同样具有不确定性，它是由解决复杂的计算数学问题的高性能计算机执行的（也就是说，过程很复杂以至于无法手动解决）。<br>
解决这些问题的计算机，所需要的是运气和计算力（工作量），这与矿工在地下挖沙时的效果是等效的。<br>
在撰写本文时，计算机解决这些问题中的一个的概率约为13万亿分之一，但随着时间推移以后难度会更大。</p>
<h2 id="比特币挖矿的了解">“比特币挖矿”的了解</h2>
<p>首先，当计算机在比特币网络上解决这些复杂的数学问题时，它们会产生新的比特币，这与采矿作业从地面提取黄金的过程一样。<br>
其次，通过解决计算数学问题，比特币矿工通过验证其交易信息，使比特币支付网络变得值得信赖和安全。</p>
<p>所有这些都将可能变得非常有意义，为了更详细地解释比特币挖矿的工作原理，让我们从一个更接近生活的角度开始：对印刷货币的监管。</p>
<p>通常，消费者倾向于信任印刷货币。这是因为法定纸币是由中央银行发行支持，其背后是有政府的公信力作为支撑背书的。<br>
甚至使用支付宝、微信等数字支付也是得到了中央机构的支持。例如，当你使用微信支付或支付宝支付进行在线购物时，该交易将由腾讯或阿里巴巴等公司处理。<br>
除了记录你的交易历史记录之外，这些公司还核实交易有没有欺诈行为，这也是你的账户在从事违法行为时可能被暂停冻结的原因之一。</p>
<p>另一方面，比特币不受中央机构监管，但比特币得到了全球数百万台称为“节点”的计算机的支持。<br>
该比特币网络执行着与中国央行，腾讯和阿里巴巴相同的功能，但有一些主要区别。<br>
节点存储所有先前交易的信息，并帮助验证其真实性。但是，与那些中央机构不同，比特币节点分布在世界各地，并将交易数据记录在公共列表中，任何人，都可以访问。</p>
<p>在商店或在线进行的交易由银行，销售点系统和实物收据记录。当有人向任何地方发送比特币时，我们称之为“交易”。<br>
在没有这些机构的情况下，比特币矿工通过以“块”形式将交易集中在一起并将其添加到称为“区块链”的公共记录中来达到相同的效果。<br>
然后，节点维护这些块的记录，以便将来可以对其进行验证。</p>
<p>当比特币矿工向区块链添加新的交易块时，他们的工作之一就是确保这些交易是准确的。<br>
特别是，比特币矿工需要确保比特币不会被复制，这是一种独特的数字货币特点，被称为“双重支付”或者“双花”。<br>
对于印刷货币，伪造始终是一个问题，但是通常，一旦您在商店中花费20元，该账单就由店员掌握，不存在“双花”问题。<br>
但是，对于数字货币，情况就大不一样了。数字信息可以相对轻松地进行复制，因此，使用比特币和其他数字货币，存在这样的风险，即消费者可以复制自己的比特币，然后将其发送给另一方，同时仍然保留原始信息。<br>
让我们假设用的是印制货币，也就是说有人试图复制自己的20元钞票，为了能够在杂货店里同时消费原始货币和伪造的货币（即40元）。</p>
<p>如果店员知道客户在重复付款，他们所要做的就是查看账单中钞票序列号。如果数字相同，那么业务员就会知道钱已经被重复使用了。这个类比类似于比特币矿工在验证新交易时所做的事情。<br>
如果有人要成功地双倍花费其比特币，他们将需要占据网络中51％的采矿能力。随着比特币的增长，要实现这一目的越来越困难。</p>
<h2 id="矿工与挖矿奖励">矿工与挖矿奖励</h2>
<p>一天中会发生多达500,000笔买卖，因此，验证每笔交易对于矿工而言可能是一件繁重的工作，这里的比特币矿工与微信，支付宝之间存在另一个重要区别。<br>
作为对他们努力的补偿，每当矿工向区块链添加新的交易块时，他们都将获得比特币，也被成为比特币的“挖矿奖励”，以此来激励网络中的矿工持续维护网络交易的正常记录。</p>
<p>大约每隔四年，区块奖励会减半一次，即每产生210,000个区块左右。<br>
2009年奖励为50个BTC，2013年为25个BTC，2018年为12.5个BTC，到2020年为6.25个BTC。比特币于2020年5月11日完成其第三次挖矿奖励减半。</p>
<p>从那时起，大约需要经历1458天，会进行下一次减半，即每个新区块仅能开采3.125比特币，作为挖矿奖励。该系统将持续到2140年左右，所有比特币将被挖出。<br>
届时，矿工只能获得交易费用作为奖励。这些费用确保了矿工仍然有动力进行交易打包并保持网络运转。<br>
个人认为，对交易费用的竞争将使它们在减半后仍然保持较低的水平。</p>
<h2 id="挖矿如何运作">挖矿如何运作？</h2>
<p>为了使比特币矿工能够从验证交易中实际赚取比特币，必须发生两件事。<br>
首先，他们必须验证价值1兆字节（MB）的事务，理论上该事务可以小到只有1个事务，但通常有几千个，具体取决于每个事务存储的数据量。其次，为了向区块链添加交易块，矿工必须计算解决一个复杂的数学问题，也称为“工作量证明”。</p>
<p>他们实际上正在尝试寻找一个小于或等于目标哈希的64位十六进制数字。<br>
基本上，矿工的计算机会根据单位每秒散列数（MH/s），每秒千兆位散列（GH/s）或什至每秒兆兆散列（TH/s）的速度去寻找符合条件的值，猜测所有可能的“哈希”直到找到解决方案为止。</p>
<p>换句话说，这是一场猜大小的赌博。</p>
<p>在撰写本文时，最新区块的难度级别超过13万亿。也就是说，计算机产生低于目标的哈希值的机会是13万亿分之一。从一个角度来看，与尝试一次就正确命中哈希值相比，单张彩票获奖的可能性高出约44,500倍。<br>
幸运的是，专用挖矿计算机系统单位时间内获得哈希值的数量是巨大的。尽管如此，挖掘比特币还是需要大量的电力和复杂的计算设备，而且以后还会需要更多。难度级别会每2016个区块或大约每2周调整一次，以保持采矿速率恒定为目标。<br>
也就是说，有更多的矿工竞争解决方案，那么计算的问题将变得更加困难，反之亦然。</p>
<p>一个有用的类比解释，假如我现在是一个五岁的孩子：“我告诉三个朋友我脑中想到一个1到100之间的数字，<br>
然后将该数字写在了纸上并将其密封在信封中。我的朋友们不必猜测出确切的数字，他们只需要有人能够猜测出一个数字小于或等于我写在纸上的数字，这个人就将获得奖励，而且不限制猜测的次数，他们可以一直尝试（即挖矿）直到有人成功。</p>
<p>比方说，我想了一个数字19。如果朋友A猜21，他们就输了，因为<code>21&gt;19</code>。如果朋友B猜16，而朋友C猜12，那么理论上他们都得出了可行的答案，因为<code>16&lt;19</code>并且<code>12&lt;19</code>。即使B的答案更接近目标答案19，但也不会多给B额外的奖励。现在想像一下，我提出了'猜我在想什么数字'这个问题，但是我不是在问三个朋友，也不是在问一个介于1到100之间的数字。<br>
相反，我是在问数百万个的比特币矿工，我在找一个64位的十六进制数字，这个数字是<code>上一个区块的计算结果</code>+<code>随机数</code>后进行哈希计算且符合以<code>17个0开头</code>，比如说小于<code>0000000000000000057fcc708cf0130d95e27c5819203e9f967ac56e4df598ee</code>的值。<br>
现在你会发现这很难猜测正确的答案，必须大量设备的尝试计算才可能找到，如果是找<code>18个0开头</code>的值那么难度就会更大了。</p>
<h2 id="矿工之间的竞争">矿工之间的竞争</h2>
<p>如果说计算正确结果概率是13万亿分之一听起来不那么困难，那么更困难的是比特币矿工不仅必须提出正确的哈希，而且还必须是第一个这样做的人。因为比特币的挖掘本质上是猜测，所以说一位矿工找到正确的答案几乎与计算机产生哈希的速度有关（即单位时间内尝试的次数）。<br>
就在十年前，比特币的挖矿还可以在普通台式计算机上进行。但是，随着时间的流逝，矿工们意识到视频游戏中常用的图形显卡GPU对挖矿更加有效。</p>
<p>2013年，比特币矿工开始使用专门设计用于尽可能高效地开采加密货币的计算机，称为专用集成电路（ASIC）。这些矿机可以从数千元到数万元不等，但它们在开采比特币方面的效率更高。</p>
<p>如今，比特币挖矿竞争如此激烈，以至于只有使用最新的ASIC才能盈利。使用台式计算机，GPU或较旧型号的ASIC时，能耗成本实际上超过了产生的收入。即使拥有最新的设备，一台计算机也很少能与众多矿工所组成的“矿池”竞争。一个采矿池是一组矿工，结合自己的计算能力组成的，最后按照算力比例分配获得的奖励。</p>
<p>现状是，拥有大量矿池的公司在比特币的计算中占有很大的比例，比如中国的比特大陆。</p>
<h2 id="比特币扩容之争">比特币扩容之争</h2>
<p>在13万亿分之1的概率下，在难度级别递增以及庞大的用户验证交易网络中，大约每大约10分钟验证一次交易。比特币网络每秒可处理约7笔交易，每10分钟将交易记录在区块链中一次。<br>
相比之下，Visa每秒可以处理约24,000笔交易。但是，随着比特币用户网络的不断增长，在10分钟内完成的交易数量最终将超过10分钟内可以处理的交易数量。<br>
届时，除非更改比特币协议，否则等待交易的时间将开始并持续更长的时间。</p>
<p>比特币协议的核心问题称在于“扩展容量”。尽管比特币矿工普遍同意必须采取一些措施来解决规模扩张问题，但人们却很少达成共识。提出了两种主要解决方案来解决缩放问题。<br>
社区的开发人员提出了不同的建议：</p>
<p>（1）为比特币创建第二个“离线”层，以允许更快的交易，之后再被区块链验证。<br>
（2）增加每个区块可以存储的交易数量。</p>
<p>解决方案1减少了每个区块要验证的数据量，将使矿工的交易更快，更便宜。解决方案2将通过允许增加块大小每10分钟处理更多信息来达到扩展效果。</p>
<p>2017年7月，代表比特币网络计算能力约80％至90％的比特币矿工和采矿公司投票决定合并一项程序，该程序将减少验证每个区块所需的数据量。也就是说，他们采用了解决方案1。<br>
矿工投票添加到比特币协议中的程序称为“隔离见证”，即SegWit。该术语是“隔离”（Segregated）和“见证”（Witness）的合并，表示“比特币交易的签名”。<br>
因此，隔离证人意味着将交易签名与区块分离，并将它们作为扩展区块附加。虽然在解决方案中似乎没有能将单独的程序添加到比特币协议中进行修改，但据估计签名数据最多占每个交易块中处理数据的65％，还是能达到一定的扩容效果。</p>
<p>不到一个月后，即2017年8月，一群矿工和开发人员发起了一次硬分叉，离开了比特币网络，使用与比特币相同的代码库创建了新的货币。尽管该小组同意采用方案1解决扩展的问题，但他们担心采用隔离见证技术无法完全解决扩展问题。<br>
所以，他们采用了解决方案2。由此产生的货币称为“比特币现金”（BCH），将块大小增加到8MB（原来BTC是1MB），以便加速验证过程，每天可以执行约200万笔交易。</p>
<p>在2019年11月6日，比特币现金的价值约为302美元，而比特币约为9,330美元。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么比特币有价值？]]></title>
        <id>https://aturx.github.io/post/wei-shi-me-bi-te-bi-you-jie-zhi</id>
        <link href="https://aturx.github.io/post/wei-shi-me-bi-te-bi-you-jie-zhi">
        </link>
        <updated>2020-05-25T01:30:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么比特币有价值">为什么比特币有价值？</h1>
<p>比特币提供透明的规则可将转移资金在互联网上，并通过分布式网络构建一个现金系统，从而成为替代央行发行法定货币的有效手段。</p>
<p>目前，已经讲了很多关于比特币的知识以及比特币价值的相关内容，我们在这里将着手探讨，如果加密货币获得进一步的广泛采用，其价值将是什么样的。</p>
<p>首先，比特币和其他数字货币被吹捧为法定货币的替代品。但是，是什么赋予了任何类型货币其价值？即，为什么货币具有价值？</p>
<p>如果该货币可以存储价值，或者换句话说，可以可靠地使用它来维持其相对价值且不贬值， 则可以使用这种货币。</p>
<p>在整个历史上的许多社会中，商品或贵金属被用作付款方式，因为它们被认为具有相对稳定的价值。</p>
<p>然而，社会发展并没有使得个人开始携带巨石，黄金或其他早期形式的货币作为价值交换手段，而是最终选择了铸造货币作为替代。使用许多铸造货币的原因，是因为它们是可靠的价值储存物，是由具有较长保质期且几乎没有贬值风险的金属制成的，并且相比巨石或黄金个人更加容易携带。</p>
<p>在现代，铸造货币通常采用纸币的形式，<br>
其自身成本价值与由贵金属制成的硬币不同。不过，现在个人使用电子货币作为付款方式的可能性更大。</p>
<p>但是，由于各国为了遏制对联邦黄金供应量增加的担忧而退出了金本位制，现在许多全球货币被归为法定货币。</p>
<p>法定货币是政府发行的，没有任何商品的支持，其价值基于个人对政府等拥有当事方的信念。今天，大多数主要的全球货币都是法定货币。</p>
<p>许多政府和社会已经发现，法定货币是最持久的货币，并且随着时间的推移，货币贬值或价值损失的可能性最小。</p>
<h2 id="货币的特有属性">货币的特有属性</h2>
<p>货币拥有以下基本属性：稀缺性、可分割性、实用性、可转移性。除了是否是价值存储的问题之外，成功的货币还必须满足与稀缺性，可分割性，实用性，可转移性，耐用性和不可伪造性等相关的条件。<br>
让我们依次看看这些特性。</p>
<ol>
<li>稀缺性</li>
</ol>
<p>维持货币价值的关键是其供应。货币供应量过大可能导致商品价格飙升，从而导致经济崩溃。货币供应量过少也会引起经济问题。 货币主义是宏观经济概念，旨在解决货币供应在经济中的增长（或缺乏）中的问题。</p>
<p>就法定货币而言，世界上大多数政府仍在继续印钞，以控制稀缺性。许多政府以预设的通货膨胀率运转，这会导致法定货币的价值下降。例如，在美国，这个比率历史上一直徘徊在2％左右。这与比特币不同，后者的发行率随时间变化。</p>
<ol start="2">
<li>可分割性</li>
</ol>
<p>成功的货币可分为较小的单位。为了使单一货币系统能够充当经济体内所有类型的商品和价值的交换媒介，它必须具有与这种可分割性相关的灵活性。货币必须被充分分割，以准确反映整个经济中每种可用商品或服务的价值。</p>
<ol start="3">
<li>实用性</li>
</ol>
<p>货币必须具有效用才能生效。个人必须能够可靠地将货币单位交易为商品和服务。<br>
这是货币首先发展的主要原因： 这样，市场参与者可以避免必须直接以货易货。<br>
实用性还要求能将货币轻松地从一个位置移动到另一位置。<br>
繁重的贵重金属和商品不容易满足这一特点。</p>
<ol start="4">
<li>可转移性</li>
</ol>
<p>为了使经济系统有用，货币必须在经济参与者之间轻松转移。以法定货币表示，这意味着货币单位必须在特定国家的经济体内以及国家之间通过交换而可以转移。</p>
<ol start="5">
<li>耐久性</li>
</ol>
<p>为了可以有效使用，货币必须至少在一定程度上是持久的。用容易被残缺，损坏或破坏的材料制成的硬币或钞票，或者随着时间的推移而退化到无法使用的程度的硬币或钞票是不够的。</p>
<ol start="6">
<li>不可伪造性</li>
</ol>
<p>正如货币必须是耐用的一样，为了保持效力，它也必须很难伪造。如果不是这样，恶意方很容易通过制造假钞来破坏货币系统，从而对货币的价值产生负面影响。</p>
<p>为了评估比特币作为一种货币的价值，我们将其与上述法定货币的每个特性进行比较。</p>
<h2 id="比特币与法定货币的比较">比特币与法定货币的比较</h2>
<ol>
<li>稀缺性</li>
</ol>
<p>当比特币于2009年推出时，其开发者在协议中规定代币的供应上限为2100万。某种情况下，当前的比特币供应量约为1800万，即比特币的汇率大约每四年就会释放一半，到2022年供应量将超过1900万。</p>
<p>请注意，更改协议内容将需要参对比特币挖掘的大多数计算能力的控制，这是不可能的。</p>
<p>比特币采用的供应方式与大多数法定货币不同。全球法定货币供给通常被认为是分成不同的，M0，M1，M2和M3。M0指流通中的货币。 M1是M0加上活期存款（如支票帐户）。M2是M1加上储蓄帐户和少量定期存款（称为存款证明）。M3是M2加上大量的定期存款和货币市场基金。</p>
<p>由于M0和M1易于在商业中使用，因此我们将把这两个存储类别视为交换媒介，而M2和M3将被视为金钱用作价值存储。作为其货币政策的一部分，大多数政府对流通货币的供应保持一定的灵活控制，并根据经济因素进行调整。</p>
<p>比特币不是这种情况。到目前为止，可生成的更多代币的持续可用性再激励着一个强大的采矿社区，尽管随着接近2100万枚代币的上限时，可能会发生重大变化。<br>
那时确切会发生什么很难说。打个比方，可以想象政府突然停止生产任何新法案。<br>
幸运的是，直到2140年左右才计划开采最后一个比特币。通常，稀缺性可以推动价值上升。黄金等贵金属可以看出这一点。</p>
<ol start="2">
<li>可分割性</li>
</ol>
<p>2100万比特币远远小于世界上大多数法定货币的流通量。幸运的是，比特币最多可分割为小数点后8位。最小单位，等于0.00000001比特币，由于比特币背后的匿名开发者被称为“中本聪”。<br>
这使得比特币对最小单位为“聪”，其的数量达到了万亿，可以分布在整个比特币全球经济系统中。</p>
<p>与美元以及大多数其他法定货币相比， 比特币的可分割程度要大得多。人民币可以分为1角，即1元的1/10，而“聪”仅是1 BTC的1/100,000,000。正是这种极端的可分割性使得比特币的稀缺成为可能。</p>
<p>如果比特币随着时间的推移持续上涨价格，则只拥有一小部分比特币的用户仍然可以参与日常交易。如果没有任何可分割性，则 1 BTC的价格为 1 万美元时，这将会阻止该货币用于大多数小额交易。</p>
<ol start="3">
<li>可实用性</li>
</ol>
<p>比特币的最大卖点之一是其对区块链技术的使用。区块链是一种去中心的分布式账本系统，这意味着参与比特币市场的任何一方都无需彼此建立信任关系，就使可以该系统正常运行。</p>
<p>这得益于完善的检查和验证系统，这对于维护分布式账本和挖掘新比特币至关重要。最重要的是，区块链技术的灵活性意味着它在加密货币空间之外也具有实用性。</p>
<ol start="4">
<li>可转移性</li>
</ol>
<p>多亏了加密货币交易所，钱包和其他工具，比特币可以在几分钟之内在各方之间转移，而不管交易的规模如何，而且成本非常低。当前传统金融系统中的转帐过程可能一次需要花费几天的时间，并且需要付费。可转移性是任何货币的极其重要的方面。尽管开采比特币，维护区块链和处理数字交易需要大量电力，但个人在此过程中通常不需要消耗持有任何比特币的实物成本。</p>
<ol start="5">
<li>耐久性</li>
</ol>
<p>耐用性是法定货币实际使用中的遇到主要问题。一元钞票虽然坚固，但仍可以撕裂，燃烧或以其他方式变得无法使用。<br>
数字付款方式不会以同样的方式遭受这些物理伤害。因此，比特币具有极大的价值。 它不能像钞票那样被破坏。<br>
但这并不是说比特币不会丢失。如果用户丢失了他或她的加密密钥，则相应的钱包中的比特币可能会永久无法使用。但是，比特币本身不会被销毁，并将继续存在于区块链上的记录中。</p>
<ol start="6">
<li>不可伪造性</li>
</ol>
<p>多亏了复杂的，分布式的区块链去中心帐本系统，比特币很难被伪造。要想伪造比特币，实际上将需要欺骗比特币网络中的所有参与者，这可不是一件容易的事。</p>
<p>能够创建伪造比特币的唯一方法是执行所谓的“双重消费”。这是指用户在两个或多个单独的交易中“花费”或转移同一比特币，从而出现有效地创建重复交易记录的情况。 虽然这对于法定货币不是问题<br>
（不可能在两个或多个单独的交易中花费相同的钞票），但在理论上，使用数字货币这种问题是可能出现的。</p>
<p>但是，导致双重支出不太可能的原因是比特币网络的规模已经十分巨大。所谓的51％攻击是很难实现的，除非矿工理论上控制着所有网络算力的一半以上。<br>
通过控制所有网络计算力的大部分，该矿工可以控制网络的其余部分以伪造记录。 但是，对比特币来说这种攻击将需要大量的精力，金钱和计算能力，因此极不可能。</p>
<h2 id="比特币的挑战">比特币的挑战</h2>
<p>通常，与法定货币相比，比特币在上述特性中的表现相当不错。那么，比特币作为货币面临的挑战是什么？</p>
<p>最大的问题之一是比特币作为价值存储的地位。比特币作为价值存储的效用取决于其作为交换媒介的效用。反过来，我们基于这样的假设：要使某物用作价值存储，它需要具有一定的内在价值，如果比特币不能成功地作为交换媒介，那么它将没有实际用途，因此也就没有内在价值。价值，并且不会作为价值存储而吸引人。像法定货币一样，比特币也不受任何实物商品或贵金属的支持。</p>
<p>在整个历史过程中，比特币的当前价值主要由投机兴趣驱动。比特币表现出泡沫的特征价格急剧上涨，并引起了媒体的关注。随着比特币继续获得更大的主流采用率，这可能会下降，但是未来不确定。围绕加密货币存储和交易所的问题频出，给比特币的实用性和可转让性带来了挑战。</p>
<p>近年来，数字货币交易所一直受到黑客攻击，盗窃和欺诈的困扰。当然，盗窃也发生在法定货币世界中。但是，在这些情况下，法律法规能更加有效的解决，并提供一些更直接的补救方法。从广义上讲，比特币和加密货币在监管方面仍被视为“莽荒之地”。不同的政府以不同的方式对待比特币，比特币被采用为全球货币的影响将是巨大的。</p>
<p>我们将比特币作为一种货币或比特币作为一种价值存储任意一个的全球的15％的值。粗略地说，M1（包括M0）目前价值约4.9万亿美元，是目前在全球范围内的交换媒介价值。减去M1的M3（包括所有其他货币）价值约45万亿美元。今天的黄金价值超过2.1万亿美元。</p>
<p>总体而言，我们假设估计全球价值存储的估计值为47.1万亿美元，包括储蓄账户，大小定期存款，货币市场基金和金条。<br>
因此，我们对交换媒介和价值存储的全球总价值的估计为72.1万亿美元。</p>
<p>如果比特币有朝一日能够要达到这一估值的15％，那么它的市值将达到10.8万亿美元。如果那时所有的2100万比特币都在流通，那么1比特币的价格将达到514,000美元。</p>
<p>这是一个相当简单的推测，也许它所关乎的最大问题是，比特币将实现多少采用率？</p>
<p>给出比特币这个价格的估计，是建立在它没有中途由于低采用率而失败的基础上。还可能包括被一种或多种其他数字货币取代。<br>
经常争论说，由于比特币可以支持花费不到一个小时的转账，因此未来的比特币生态系统中的资金流向将高于当前的平均资金流向。但是，对此还有另一种观点，那就是货币的流通速度并不受任何重要方式的限制，其主要决定因素是人们进行交易的意愿。</p>
<p>比特币未来是否能够真正的成为法定货币的替代者，现在来看尚且处于进行时。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比特币如何运作]]></title>
        <id>https://aturx.github.io/post/bi-te-bi-ru-he-yun-zuo</id>
        <link href="https://aturx.github.io/post/bi-te-bi-ru-he-yun-zuo">
        </link>
        <updated>2020-05-20T07:04:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="比特币如何运作">比特币如何运作?</h1>
<p>如何对比特币进行准确的分类尚有争议。</p>
<p>它是一种货币，一种价值存储物，一种支付网络工具还是一种虚拟资产？</p>
<p>幸运的是，对比特币的定义相对更容易。 它是由软件程序构成，并非像金光闪闪的硬币图片所描绘的实物。</p>
<p>比特币是一串纯粹的数字所组成的，是一组协议或者说是算法的计算结果。</p>
<p>历史上数百次通过使用密码学（制作和破解密码的科学技术）创建虚拟货币的尝试中，它并非最早的一个，但却是最成功的。</p>
<p>比特币之后，已经启发了数千种数字货币的创造，但就市值而言，它仍然是最大的加密货币，这使得它在其十多年历史中一直保持主导地位。</p>
<p>（补充说明：根据比特币基金会的说法，“比特币-Bitcoin”一词在将加密货币称为实体时被大写，而在指代某种货币或单位本身时被称为“比特币-bitcoin”。比特币也缩写为“<br>
BTC”。）</p>
<ul>
<li>重要要点</li>
</ul>
<pre><code>1. 比特币是一种数字货币，是一种去中心化系统，可在被称为区块链的分布式账本中记录交易。

2. 比特币矿工使用复杂的计算机硬件来解决复杂的数学难题，以确认一个区块中的所有交易的有效性。完成
后，这些区块将被添加到区块链记录中，并向该矿工奖励少量的比特币，这个过程被称为“挖矿”。

3. 挖矿并不是获得比特币的唯一方式，比特币市场的其他参与者可以通过加密货币交易所或点对点方式买卖比特币。

4. 比特币分布式账本通过无信任系统得到保护，以防欺诈行为。即便比特币交易所在进行高度安全防范的条件下，依然有潜在的盗窃行为，而备受瞩目的盗窃案已经发生数次。
</code></pre>
<h2 id="1-诞生">1. 诞生</h2>
<p>比特币最早由自称中本聪的人在2008年的论文中首先提出，论文描述了区块链和比特币，有一段时间这两个术语几乎都是同义词。<br>
自那以来，区块链已经发展成为一个独立的概念，并且人们随后使用类似的加密技术，创建数千个区块链。<br>
因此此历史可能会使术语混淆，区块链有时是指原始的比特币区块链。<br>
在其他时候，它通常是指区块链技术或任何其他特定的区块链技术，例如为以太坊提供底层的区块链技术。</p>
<p>区块链技术的基础原理非常简单。<br>
任何给定的区块链均由按时间顺序排列的离散信息块的单链组成。<br>
原则上，此信息可以是1和0的任何字符串，这意味着它可以包括电子邮件，合同，土地所有权，结婚证书或债券交易。<br>
从理论上讲，只要双方都同意合同，就可以在区块链上建立两方之间的任何类型的合同。<br>
这消除了第三方参与任何合同的任何需要。<br>
这就开辟了无限的可能性，其中包括点对点金融产品，例如贷款或分散式储蓄和支票账户，而与银行或任何中介机构无关。</p>
<h2 id="2-后继者">2. 后继者</h2>
<p>比特币的当前目标是价值存储和支付系统。<br>
以太坊项目的主要目标是建立一个平台或者说世界计算机，在这个平台上可以执行“智能合约”，从而创建了一个去中心的金融基础设施，而没有任何中间商，但是随之而来的是存在费用和潜在的数据泄露风险。</p>
<p>这种多样性的发展，成功的引起了政府和私人公司的注意。<br>
实际上，一些分析人士认为，区块链技术最终将成为加密货币热潮中最具影响力的技术。<br>
但是，就比特币而言，区块链上的信息主要是交易。<br>
比特币实际上只是一个列表。A人向B人发送X比特币，B人向C人发送Y比特币，等等。<br>
通过加密计算这些交易，使得分布式网络的每个人都知道并确认交易的准确性。<br>
重要的是要注意，这些交易不一定是在人与人之间进行，可以是不同机构之间，不同系统之间，实现价值互通。</p>
<p>任何人都可以访问和使用比特币网络，而你的种族，性别，宗教，物种或政治倾向完全不相关。<br>
这为物联网创造了巨大的可能性。未来，我们会看到无人驾驶出租车或超大型汽车拥有自己的区块链钱包的系统。<br>
该车将从乘客那里收到加密货币，并且直到收到资金后才可以行驶。<br>
车辆将能够评估何时需要加油，并会自动使用钱包余额更方便的加油。</p>
<h2 id="3-使命">3. 使命</h2>
<p>尽管绝对公开，或者正因为如此，比特币极难篡改。比特币没有物理存在，因此你不能通过将其锁定在保险箱中或将其埋在树林中来保护它。</p>
<p>从理论上讲，小偷要想从你手中夺走它，所需要做的就是在分布式账本上添加一行，以表示“你付给了他，你所拥有的一切”。</p>
<p>一个令人担忧的是双重支付，即“双花问题”。如果一个有意破坏者想要花费一些比特币在两个或多个不同的地方，那么货币的价值信任将受到质疑。</p>
<p>对货币价值的信心就会迅速消失。为了实现双花，恶意攻击者将需要至少占用特币采矿能力的51％。所以，比特币网络越大，现实就越不现实，因为所需的计算能力将是天文数字，而且非常昂贵。</p>
<p>为了进一步防止任何一种情况的发生，您需要高度安全的信任机制。在这种情况下，使用传统货币的常规解决方案是通过中央，中立的仲裁员（例如银行）进行交易。比特币让这一过程变得不必要。（中本聪 最初的描述发表于2008年10月，这并非巧合，当时人们对银行的信任处于几代人的低谷。而当今的冠状病毒环境和政府债务不断增加的情况下，这显然又是一个反复出现的主题。）</p>
<p>与其拥有可靠的权威来保持总账本一致，不如使得网络去中心化，将比特币网络分散。每个人都能够关注其他所有人的账本，没有人特别需要认识或信任任何人就能使系统正常运行，一切基于程序算法实现共识。</p>
<p>假设一切都按预期进行，则加密协议可确保写在最长、时间最久的一条公开透明的区块链上的区块的可靠性是得到整个网络所认可的。</p>
<h2 id="4-技术与安全">4. 技术与安全</h2>
<ul>
<li>矿业</li>
</ul>
<p>网络中的节点维护这个去中心的公共账本正常运作并获得比特币奖励的过程称为采矿。参与的节点被称为矿工，矿工网络建立在比特币用户网络的基础上，这些网络将这些用户的交易记录在区块链上。</p>
<p>记录一串交易对于现代计算机而言是微不足道的，但是由于比特币的软件使该过程人为地耗时，因此挖矿过程是困难的。<br>
如果没有额外的难道，人们就可以轻易伪造交易来欺骗他人。他们可以将欺诈交易记录在区块链中，并在此基础上增加更多的虚假交易，以至于让网络中的其他节点无法分辨是欺诈行为还是真实交易。</p>
<p>同样，如果很容易就能创建欺诈交易并插入到区块中。那么网络将会变得非常庞大，充满了恶意制造的垃圾交易，而比特币将一文不值。</p>
<p>比特币采用一种巧妙的算法来解决这个问题，将“工作量证明”与其他加密技术相结合就是“中本聪”的突破。<br>
比特币的软件程序会调整矿工的工作难度，以便每10分钟左右网络会出一个1兆字节大小的交易块。<br>
这样，这段时间内的交易量就可以被打包到块中。整个网络有时间审查新的区块和它之前的公共账本，并且每个人都可以就现状达成共识。<br>
矿工希望看到比特币网络平稳运行，通过向分布式分类账中添加区块来验证交易。<br>
他们的工作也将得到奖励。我们将在下面仔细研究采矿奖励。</p>
<ul>
<li>减半</li>
</ul>
<p>如前所述，矿工因验证交易区块而获得比特币奖励。每开采210,000个区块，或每四年大约减少一半的奖励。此事件称为“比特币减半”。比特币系统是作为通货紧缩系统设计的，新的比特币被释放到流通系统中。</p>
<p>此过程对比特币采矿的奖励理论会持续到2140年左右。一旦从代码中开采了所有比特币并且完成了一半的交易，矿工将继续向网络用户收取交易打包费用作为激励。<br>
希望那时候，健康的网络竞争能够使比特币网络的手续费能保持在较低水平。</p>
<p>该系统提高了比特币的稀有率，并降低了通货膨胀率，直到最终为零。在2020年5月11日进行第三次减半之后，比特币开采每个区块的奖励是6.25比特币。</p>
<ul>
<li>哈希</li>
</ul>
<p>这是有关挖矿工作原理的一些技术性描述。遍布全球且不受个人或组织约束的矿工网络在接收到最新一批交易数据后，他们通过一种加密算法来运行数据，该算法最终生成一个“哈希值”，即一串数字和字母组成的，用于验证信息的有效性，但不会泄露信息本身。<br>
（实际上，这种分散式挖矿的理想愿景不再是个人可行的了，工业规模的挖矿矿场的出现和强大的矿池构已经成了寡头垄断。）</p>
<p>光有一个哈希值<br>
<code>000000000000000000c2c4d562224f272bd33d64e2a7d2f2feb67c15e826118f</code>，<br>
你是将无法知道相关区块（如＃1234）包含哪些事务或交易的。<br>
但是，你可以通过验证一堆数据的最终哈希值是否与该哈希值相同，从而辨别是否这是相同的数据。并确保它（#1234）未被篡改。如果一个数字不对应，那么不管数据多么少，数据都会生成完全不同的哈希串。<br>
例如，如果您通过哈希函数运行字符串“hello”，则可能会得到<code>2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</code>。<br>
但是，删除“o”字母后，“hell”的哈希值将是<code>0ebdc3317b75839f643387d783535adc360ca01f33c75f7c1e7373adcd675c0b</code>。<br>
尽管你只更改了原始文本中的一个字母，但得到的是完全不同的哈希。</p>
<p>哈希技术使比特币网络能够立即检查区块的有效性，可防止篡改。</p>
<p>为了保证新的区块得到之前区块的确认，前一个块的哈希将会作为一部分被写入新块内。如果在上一个块中的详细信息被篡改了，则该新的区块哈希也将被更改。即该区块的哈希值会引发一系列新的哈希值的变化，所以在比特币网络中进行历史数据的篡改几乎是无法实现的。</p>
<p>但是，只是把数据生成哈希值只能防止篡改，并不能真正保证比特币交易的可靠性。<br>
这个过程是如此简单快捷，以至于恶意破坏者仍然可以伪造哈希向网络发送垃圾信息，并且也许，如果有足够的计算能力，就可以将欺诈性交易写到之前的几个区块中，实现交易回滚。<br>
因此，比特币协议的“工作量证明”是十分必要的机制。<br>
通过向矿工指定一个非常苛刻满足条件，来达到这一效果，即他们的哈希值必须低于某个目标。</p>
<pre><code>一串随机的哈希值如 ‘2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824’ 非常容易获得
一串符合‘0000’ 开头的哈希值就没那么容易得到了。‘00004dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824’
这需要大量的计算获得，相对如果条件是‘00000000’开头，那么找到这样一个哈希值的难度就变得更高了。

'00000000111' &lt; '00001111111' 这就是“哈希值必须低于某个目标”的意义，“0”越多，值越小。
</code></pre>
<p>这就是块<code>＃1234</code> 的哈希值以一长串零开始的原因。由于每个数据字符串都将生成一个且仅一个哈希，因此，寻求足够小的哈希需要在数据末尾添加随机数。</p>
<p>开采的区块将被广播到网络让其他节点接收确认，确认过程需要花费一个小时左右的时间，尽管有时需要更长的时间。<br>
（同样，此描述也得到了简化。不对块进行整体哈希处理，而是将其分解为更有效的结构，称为Merkle树。）</p>
<ul>
<li>挖矿难度</li>
</ul>
<p>根据网络接收的流量大小，比特币的协议判断需要更长或更短的零开头字符串，从而调整至每10分钟达到一个新区块速率的难度。<br>
截至2019年10月，当前的难度约为6.379万亿，高于2009年的1。这表明，自从十年前推出这种加密货币以来，算力的提升和难度的提升，开采比特币变得更加困难。</p>
<p>挖矿是计算密集型的操作，需要大型，昂贵的计算设备和大量的电力来为其供电，而且需要更加高效的竞争力。<br>
尚不清楚哪种随机数将会起作用，因此唯一目标就是尽可能多的进行尝试计算不同的哈希，直到找到符合条件的。</p>
<p>早期，矿工们意识到，可以通过将多个计算设备合并成矿池，共享计算能力，最终将奖励分配给彼此来提高成功的机会。<br>
即使多个挖矿者共同分配了这些奖励，但仍然有足够的动力促使矿工进行比特币挖矿。</p>
<ul>
<li>奖励减半</li>
</ul>
<p>每次开采新区块时，成功的矿工都会收到一笔奖励的比特币交易。<br>
最初是50个，但后来减半到25个，之后是12.5个，截止2020年5月完成减半后仅为6.25个。<br>
每210,000个区块（或大约每四年）会发生一次减半，直到达到零。届时，所有2100万个比特币将被开采完成，而矿工将仅依靠打包交易服务费用来维护网络。</p>
<ul>
<li>51% 攻击</li>
</ul>
<p>当比特币推出时，计划该加密货币的总供应量将是2100万个。<br>
矿工们聚集起来挖矿的事实令人有些担忧，如果池超过网络挖掘能力的50％，则其参与者可能会有机会实现“双花”交易。<br>
他们还可能会阻止他人的交易。简而言之，这批矿工将有能力改变系统的分布式特性，并凭借其拥有的多数权力来操作交易的验证。</p>
<p>这可能意味着比特币的终结，但即使是所谓的51％攻击也可能无法使恶意攻击者撤消旧的交易，因为工作量证明要求使该过程非常耗费人力。<br>
要回滚并更改区块链，池将需要控制网络的大部分，以至于可能毫无意义。<br>
当你控制整个货币时，那你可以与谁进行交易呢？</p>
<p>从矿工的角度来看，51％的攻击是一种经济自杀命题。当采矿池Ghash.io在2014年达到网络计算能力的51％时，它自愿承诺不超过比特币哈希率的39.99％，以保持对加密货币价值的信心。<br>
与矿工有关的另一个令人担忧的问题是，实际趋势是他们集中在世界上电力价格相对便宜的部分地区，例如中国。</p>
<ul>
<li>比特币交易所</li>
</ul>
<p>对于大多数参与比特币网络的个人来说，区块链的来龙去脉，哈希率和挖掘并不是特别重要。<br>
在采矿社区之外，比特币所有者通常通过比特币交易所购买其供应的加密货币。这些在线平台可以促进比特币和其他数字货币的交易。</p>
<p>像Coinbase、币安、火币这样的比特币交易所汇聚了来自世界各地的市场参与者，进行买卖加密货币。<br>
这些交易所不仅越来越受欢迎（近年来比特币的知名度不断提高），而且还面临监管，法律和安全方面的挑战。<br>
随着世界各国政府以不同方式（以货币，资产类别或任何其他其他类别）审查加密货币，监管比特币买卖的法规非常复杂且不断变化。</p>
<p>对于比特币交易所的参与者来说，也许比改变监管监督的威胁更为重要的是盗窃和其他犯罪活动。<br>
尽管比特币网络本身在其整个发展历史上一直是安全的，但各个交易所不一定是安全的。<br>
许多盗窃都针对知名度较高的加密货币交易下手，常常导致价值数百万美元的代币损失。</p>
<p>最著名的交易所盗窃案，可能是2014年之前一直主导着比特币交易领域的Mt.Gox交易所被盗事件。<br>
当时该平台宣布可能盗窃了大约850,000个BTC，当时价值近4.5亿美元。随后Mt.Gox交易所申请破产并关门。<br>
直到今天，大部分被盗的赏金（现在价值约80亿美元）尚未被追回。</p>
<ul>
<li>私钥和钱包</li>
</ul>
<p>由于以上种种原因，理所当然的，比特币交易者和所有者将希望采取任何可能的安全措施来保护其资产。<br>
为此，他们选择使用私钥和钱包。<br>
比特币的所有权本质上可以归结为两个部分，即公共密钥和私有密钥。粗略的类比是用户名（公钥）和密码（私钥）。<br>
公钥的哈希（称为地址）是在区块链上显示的哈希，使用哈希可提供一定的安全性。</p>
<p>要接收比特币，发件人只需知道你的地址即可。公钥是从私钥派生的，你需要通过该私钥进行签名验证身份后，才能发送交易到另一个地址。</p>
<p>要访问比特币，请使用一个钱包，钱包可以采用不同的形式，从提供保险和借记卡的第三方Web应用程序到打印在纸上的QR码。<br>
最重要的区别是在“热”钱包和“冷”钱包之间的区别，“热”钱包已连接到Internet，因此容易受到黑客攻击，而“冷”钱包没有连接到Internet。</p>
<p>在Mt.Gox交易所被盗案中，据信大部分被盗的BTC都是从热钱包里拿走的。<br>
尽管如此，许多用户还是将自己的私钥委托给了加密货币交易所，这实际上是在押注，认为交易所将会比自己的计算机发生盗窃可能性更小，或者说交易所的安全性更高。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python面向对象编程：实现IoC控制反转]]></title>
        <id>https://aturx.github.io/post/python-mian-xiang-dui-xiang-bian-cheng-shi-xian-ioc-kong-zhi-fan-zhuan</id>
        <link href="https://aturx.github.io/post/python-mian-xiang-dui-xiang-bian-cheng-shi-xian-ioc-kong-zhi-fan-zhuan">
        </link>
        <updated>2020-05-18T08:48:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-面向对象基础知识">一、面向对象基础知识</h2>
<ol>
<li>
<p><code>type()</code> 判断数据类型</p>
</li>
<li>
<p><code>isinstance(a,b)</code> 判断class继承关系</p>
</li>
<li>
<p><code>dir()</code> 获取相关属性</p>
</li>
<li>
<p><code>__slots__</code><br>
限制属性添加,class类可以任意添加属性，<code>__slots__</code>用于限制添加的属性</p>
</li>
<li>
<p><code>@property</code> 和 <code>@x.setter</code> 装饰器，主要功能是：把一个方法变成属性调用<br>
解决的问题是，对于数据的检验，类似Java中的get<br>
set方法，但是可以对属性进行必要的检验，而对外暴露的依然是对属性的操作</p>
<pre><code>class Student(object):

 @property
 def score(self):
     return self._score

 @score.setter
 def score(self, value):
     if not isinstance(value, int):
         raise ValueError('score must be an integer!')
     if value &lt; 0 or value &gt; 100:
         raise ValueError('score must between 0 ~ 100!')
     self._score = value
     
使用：

 &gt;&gt;&gt; s = Student()
 &gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
 &gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
 60
 &gt;&gt;&gt; s.score = 9999
 Traceback (most recent call last):
   ...
 ValueError: score must between 0 ~ 100!
</code></pre>
</li>
<li>
<p>枚举类型:<br>
枚举类型可以当普通常量来使用，而且这些常量属同一类，比如星期，月份，错误编码，控制代码等。</p>
<pre><code>from enum import Enum
# 固定 定值 采用枚举
 class MaxCent(Enum):
     People = 30
     Air = 30
     Place = 20
     Other = 20

 print(MaxCent[&quot;People&quot;])
</code></pre>
</li>
</ol>
<h2 id="二-面向对象编程实践">二、面向对象编程实践</h2>
<p>IoC 解决的核心问题是：</p>
<ul>
<li>谁负责创建组件？</li>
<li>谁负责根据依赖关系组装组件？</li>
<li>销毁时，如何按依赖顺序正确销毁？</li>
</ul>
<hr>
<ol>
<li>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制</li>
</ol>
<p>例：</p>
<pre><code>class DB():	
    def __init__(self, config):	
        print(&quot;使用{}进行数据库连接操作&quot;.format(config))

	def query(self, data):
		print(&quot;查询: {}&quot;.format(data))

	def delete(self, data):
		print(&quot;删除： {}&quot;.format(data))
		
class Config():
    def __init__(self):
        print(&quot;配置信息&quot;)

class QueryService():
    def __init__(self):
        print(&quot;控制程序，顺序执行，创建对象&quot;)
        config = Config()
        db = DB(config)
    
        db.query(&quot;test query&quot;)

class DeleteService():
    def __init__(self):
        print(&quot;同上, Config 和 DB 再次被实例化&quot;)
        config = Config()
        db = DB(config)
        db.delete(&quot;test delete&quot;)


QueryService()
DeleteService()
</code></pre>
<ol start="2">
<li>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责<br>
，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制<br>
比如，上方： DB 将不再由 QueryService， DeleteService<br>
自己创建，而是等待外部，通过“方法”注入 比如交由一个 setDB()</li>
</ol>
<p>例：</p>
<pre><code>class QueryServiceIoC():

	def __init__(self):
		self.db = None
	# 依赖注入（DI：Dependency Injection）
	def setDB(self, db):
		self.db = db

	def query(self):
		print(&quot;通过注入查询&quot;)
		self.db.query(&quot;test IoC Query&quot;)

class DeleteServiceIoC():

	def __init__(self):
		self.db = None

	def setDB(self, db):
		self.db = db

	def delete(self):
		self.db.delete(&quot;test IoC Delete&quot;)
</code></pre>
<p>IoC又称为依赖注入（DI：Dependency<br>
Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。<br>
(参考 Java Spring)因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。<br>
一种最简单的配置是通过XML文件来实现</p>
<pre><code> &lt;beans&gt; &lt;bean id=&quot;DB&quot; class=&quot;DB&quot; /&gt;
    
    &lt;bean id=&quot;QueryServiceIoC&quot; class=&quot;QueryServiceIoC&quot;&gt;
        &lt;property name=&quot;DB&quot; ref=&quot;DB&quot; /&gt;
    &lt;/bean&gt;
    
    &lt;bean id=&quot;DeleteServiceIoC&quot; class=&quot;DeleteServiceIoC&quot;&gt;
        &lt;property name=&quot;DB&quot; ref=&quot;DB&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
分别三个 Bean 组件， DB 被分别注入到  QueryServiceIoC 和 DeleteServiceIoC 中
</code></pre>
<p>除了 set() 方法可以注入，还可以直接构造方法/初始化注入</p>
<pre><code>class QueryServiceIoCNew():	
    # 依赖注入（DI：Dependency Injection）	
    def __init__(self, db):	self.db = db

    def query(self):
        print(&quot;通过注入查询&quot;)
        self.db.query(&quot;test IoC Query&quot;)
</code></pre>
<p>Java Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用</p>
<p>Python 实现 IoC 思路， 由于Spring 使用 XML 存储 Bean 组件的依赖关系，在Python中实现则用一个BeanFactory替代，<br>
context: 存储Bean的名字和对应的类或者值的字典<br>
allowRepalce: 是否允许替换已经注入的Bean</p>
<pre><code># 依赖管理
class BeanFactory():
	def __init__(self,allowReplace=False):
		&quot;&quot;&quot;构造函数 allowReplace:是否允许替换已经注入的bean &quot;&quot;&quot;
		self.context = {}
		self.allowReplace = allowReplace

	def setBean(self, beanName, resource, *args, **kwargs):
		if not self.allowReplace:
			assert not beanName in self.context, &quot;该BeanFactory不允许重复注入%r,请修改beanName&quot; % beanName

		# 闭包函数
		def call():
			&quot;&quot;&quot;定义一个函数闭包,如果注入的resource是可调用类型,
			就将*args和**kwargs传入并调用该函数,然后将返回值返回
			如果是一个不可调用对象,就直接返回 &quot;&quot;&quot;
			if callable(resource):
				return resource(*args, **kwargs)
			else:
				return resource

		# 将call闭包与beanName建立映射
		self.context[beanName] = call


	def __getitem__(self, beanName):
		&quot;&quot;&quot;重载__getitem__方法,使得BeanFactory支持使用[]获取beanName对应的注册的资源 &quot;&quot;&quot;
		try:
			# 从context字典中取出beanName对应的资源
			resource = self.context[beanName]
		except KeyError:
			raise KeyError(&quot;%r 未注册&quot; % beanName)
		# 返回闭包函数调用后的结果
		return resource()

SpringIoCFactory = BeanFactory()



def HasMethods(*methods):
	def test(obj):
		for each in methods:
			try:
				attr = getattr(obj, each)
			except AttributeError:
				return False
			if not callable(attr): return False
		return True
	return test

def NoAssertion(obj): return True
class RequiredResource(object):
	def __init__(self, beanName, assertion=NoAssertion):
		self.beanName = beanName
		self.assertion = assertion
	def __get__(self, obj, T):#每次访问descriptor时都会调用__get__方法
		return self.result # &lt;-- .操作符会自动调用__getattr__
	def __getattr__(self, name):
		assert name == 'result', &quot;Unexpected attribute request other then 'result'&quot;
		self.result = self.Request()
		return self.result
	def Request(self):
		obj = SpringIoCFactory[self.beanName]
		assert self.assertion(obj), \
			&quot;The value %r of %r does not match the specified criteria&quot; \
			% (obj, self.feature)
		return obj



class TestIoCService():
	# 依赖注入（DI：Dependency Injection）
	db = RequiredResource('db')
	def __init__(self):
		self.s = &quot;初始化成功， 注入 db:  &quot;

	def print_db_info(self):
		self.db.query(&quot;通过依赖注入进行的查询！&quot;)


class DB_IoC():
	# 依赖注入（DI：Dependency Injection）
	config = RequiredResource('config')
	def __init__(self):
		print(&quot;使用{} 进行数据库连接操作&quot;.format(self.config))

	def query(self, data):
		print(&quot;查询: {}&quot;.format(data))

	def delete(self, data):
		print(&quot;删除： {}&quot;.format(data))


if __name__ == &quot;__main__&quot;:
	print(&quot;******* Test IoC Demo ********&quot;)
	SpringIoCFactory.setBean(&quot;db&quot;, DB_IoC)
	SpringIoCFactory.setBean(&quot;config&quot;, Config)

	# 测试
	tic = TestIoCService()
	tic.print_db_info()

	&quot;&quot;&quot;
	实现了 DB类 和Config 类 ，通过 IoC 方式进行依赖注入
	BeanFactory 是一个简易的IoC管理器，然后通过 RequiredResource 将需要实例化的类
	注入到使用的类中，完成“依赖注入”。
	而DB类 和Config类的实例化过程，并不是使用时才被实例化，而是提前被IoC容器创建，在使用的时候
	只是直接获取。从而实现“控制反转”
	&quot;&quot;&quot;
</code></pre>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208">面对对象高级编程</a></p>
</li>
<li>
<p><a href="http://www.voidcn.com/article/p-vxpqmayc-brn.html">Python IoC 实现</a></p>
</li>
</ul>
]]></content>
    </entry>
</feed>