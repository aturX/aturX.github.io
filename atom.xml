<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lianqiujun.co</id>
    <title>链 求 君 | 区 块 链</title>
    <updated>2020-11-17T15:50:00.188Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lianqiujun.co"/>
    <link rel="self" href="https://lianqiujun.co/atom.xml"/>
    <subtitle>实践更多区块链项目，探索更多Web3可能性！</subtitle>
    <logo>https://lianqiujun.co/images/avatar.png</logo>
    <icon>https://lianqiujun.co/favicon.ico</icon>
    <rights>All rights reserved 2020, 链 求 君 | 区 块 链</rights>
    <entry>
        <title type="html"><![CDATA[Flow Go SDK 开发实践]]></title>
        <id>https://lianqiujun.co/post/flow-go-sdk-kai-fa-shi-jian</id>
        <link href="https://lianqiujun.co/post/flow-go-sdk-kai-fa-shi-jian">
        </link>
        <updated>2020-11-17T09:07:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="flow-go-sdk">Flow Go SDK</h1>
<p>Flow Go SDK 提供相关开发包帮助 Golang 开发者完成在 Flow network 上进行应用的构建和开发。</p>
<p><em>注意: 这个 SDK 通过 <a href="https://github.com/onflow/flow/blob/master/docs/emulator.md">Flow Emulator</a>完成实现，并且可以被用于本地开发。</em></p>
<h2 id="英文"><a href="/README.md">英文</a> | <a href="#">中文（简体）</a></h2>
<h2 id="什么是-flow">什么是 Flow ?</h2>
<p>Flow is a new blockchain for open worlds. Read more about it <a href="https://github.com/onflow/flow">here</a>.</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#getting-started">开始</a>
<ul>
<li><a href="#installing">安装</a></li>
<li><a href="#generating-keys">生成密钥</a>
<ul>
<li><a href="#supported-curves">支持的曲线</a></li>
</ul>
</li>
<li><a href="#creating-an-account">创建一个帐户</a></li>
<li><a href="#signing-a-transaction">签名一个交易</a>
<ul>
<li><a href="#how-signatures-work-in-flow">Flow中的签名是如何在工作的</a>
<ul>
<li><a href="#single-party-single-signature">一人一签</a></li>
<li><a href="#single-party-multiple-signatures">多人签名</a></li>
<li><a href="#multiple-parties">多方</a></li>
<li><a href="#multiple-parties-two-autorizers">多方参与，两个自动执行器</a></li>
<li><a href="#multiple-parties-multiple-signatures">多方参与，多个签名</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sending-a-transaction">发起一笔交易</a></li>
<li><a href="#querying-transaction-results">查询交易结果</a></li>
<li><a href="#querying-blocks">查询块</a></li>
<li><a href="#executing-a-script">执行一个脚本</a></li>
<li><a href="#querying-events">查询事件</a>
<ul>
<li><a href="#event-query-format">事件查询格式</a></li>
<li><a href="#event-results">事件的结果</a></li>
</ul>
</li>
<li><a href="#querying-accounts">查询账户</a></li>
</ul>
</li>
<li><a href="#examples">例子</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="开始">开始</h2>
<h3 id="安装">安装</h3>
<p>开始使用 SDK, 首先安装 Go 1.13+ 版本， 并且运行 <code>go get</code>:</p>
<pre><code class="language-sh">go get github.com/onflow/flow-go-sdk
</code></pre>
<h3 id="生成密钥">生成密钥</h3>
<p>Flow 使用 <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a><br>
去控制用户的账户权限。 每一个密钥都使用了 <code>SHA2-256</code> 或者 <code>SHA3-256</code> 哈希算法实现了。</p>
<p>这里有关于如何生成 ECDSA，采用P-256 (secp256r1) 曲线及私钥的相关方法:</p>
<pre><code class="language-go">import &quot;github.com/onflow/flow-go-sdk/crypto&quot;

// 种子 短语
// 注意: 这只是一个例子, 请使用安全的方式随机生成种子
seed := []byte(&quot;elephant ears space cowboy octopus rodeo potato cannon pineapple&quot;)

privateKey, err := crypto.GeneratePrivateKey(crypto.ECDSA_P256, seed)
</code></pre>
<p>这个私钥可以被编码成  bytes 类型 (i.e. for storage):</p>
<pre><code class="language-go">encPrivateKey := privateKey.Encode()
</code></pre>
<p>可以为一个私钥创建一个对应的公钥:</p>
<pre><code class="language-go">publicKey := privateKey.PublicKey()
</code></pre>
<h4 id="支持的曲线">支持的曲线</h4>
<p>例子部分使用了 ECDSA 密钥， 采用的曲线算法是 P-256 (secp256r1) 。<br>
Flow 也支持 Bitcoin 和 Ethereum 所使用的 secp256k1 曲线算法</p>
<p>这里展示如何采用secp256k1 曲线生成一个 ECDSA 私钥:</p>
<pre><code class="language-go">privateKey, err := crypto.GeneratePrivateKey(crypto.ECDSA_secp256k1, seed)
</code></pre>
<p>这里是支持的签名哈希算法的完整列表:<a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms">Flow 签名 &amp; 哈希算法</a></p>
<h3 id="创建一个帐户">创建一个帐户</h3>
<p>一旦你完成了 <a href="#generating-keys">生成一个密钥对</a>, 您可以使用它的公钥，创建一个新帐户。</p>
<pre><code class="language-go">import (
    &quot;github.com/onflow/flow-go-sdk&quot;
    &quot;github.com/onflow/flow-go-sdk/crypto&quot;
    &quot;github.com/onflow/flow-go-sdk/templates&quot;
)

ctx := context.Background()

// 为账户生成一个新的私钥
// 注意: 这只是一个例子, 请使用安全的方式随机生成种子
seed := []byte(&quot;elephant ears space cowboy octopus rodeo potato cannon pineapple&quot;)
privateKey, _ := crypto.GeneratePrivateKey(crypto.ECDSA_P256, seed)

// 得到公钥
publicKey := privateKey.PublicKey()

// 从公钥中构建一个用户密钥
accountKey := flow.NewAccountKey().
    SetPublicKey(publicKey).
    SetHashAlgo(crypto.SHA3_256).        // SHA3_256 哈希算法生成的密钥对
    SetWeight(flow.AccountKeyWeightThreshold) // 授予这个密钥签名权重

// 生成一个帐户创建脚本
// 这将创建一个帐户，该帐户只有一个公钥，没有代码
script, _ := templates.CreateAccount([]*flow.AccountKey{accountKey}, nil)

// 连接到本地运行的模拟器
c, err := client.New(&quot;localhost:3569&quot;)
if err != nil {
    panic(&quot;failed to connect to emulator&quot;)
}

payer, payerKey, payerSigner := examples.ServiceAccount(c)

tx := flow.NewTransaction().
    SetScript(script).
    SetGasLimit(100).
    SetProposalKey(payer, payerKey.Index, payerKey.SequenceNumber).
    SetPayer(payer)

err = tx.SignEnvelope(payer, payerKey.Index, payerSigner)
if err != nil {
    panic(&quot;failed to sign transaction&quot;)
}

err = c.SendTransaction(ctx, *tx)
if err != nil {
    panic(&quot;failed to send transaction&quot;)
}

result, err := c.GetTransactionResult(ctx, tx.ID())
if err != nil {
    panic(&quot;failed to get transaction result&quot;)
}

var myAddress flow.Address

if result.Status == flow.TransactionStatusSealed {
    for _, event := range result.Events {
        if event.Type == flow.EventAccountCreated {
            accountCreatedEvent := flow.AccountCreatedEvent(event)
            myAddress = accountCreatedEvent.Address()
        }
	}
}
</code></pre>
<h3 id="签名一个交易">签名一个交易</h3>
<p>下面是一个简单的例子使用 <code>crypto.PrivateKey</code> 签名一个交易.</p>
<pre><code class="language-go">import (
    &quot;github.com/onflow/flow-go-sdk&quot;
    &quot;github.com/onflow/flow-go-sdk/crypto&quot;
)

var (
    myAddress    flow.Address
    myAccountKey flow.AccountKey
    myPrivateKey crypto.PrivateKey
)

tx := flow.NewTransaction().
    SetScript([]byte(&quot;transaction { execute { log(\&quot;Hello, World!\&quot;) } }&quot;)).
    SetGasLimit(100).
    SetProposalKey(myAddress, myAccountKey.Index, myAccountKey.SequenceNumber).
    SetPayer(myAddress)
</code></pre>
<p>交易签名通过 <code>crypto.Signer</code> 接口完成.  <code>crypto.Signer</code> 最安全、最简单的接口实现方法是 <code>crypto.InMemorySigner</code>.</p>
<p>使用这样的签名，可以更安全地生成密钥存储在硬件设备中，如 <a href="https://en.wikipedia.org/wiki/Hardware_security_module">HSM</a>.  <code>crypto.Signer</code><br>
就是这样的签名接口的简单实现。</p>
<pre><code class="language-go">// 通过你的私钥构造一个签名器，通过哈希算法完成签名
mySigner := crypto.NewInMemorySigner(myPrivateKey, myAccountKey.HashAlgo)

err := tx.SignEnvelope(myAddress, myAccountKey.Index, mySigner)
if err != nil {
    panic(&quot;failed to sign transaction&quot;)
}
</code></pre>
<h4 id="flow-中的签名是如何在工作的">Flow 中的签名是如何在工作的</h4>
<p>Flow 引入了新的概念，允许在创建和签署事务时具有更大的灵活性。</p>
<p>在尝试下面的示例之前，我们建议您阅读<a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#signing-a-transaction">事务签名文档</a>.</p>
<hr>
<h5 id="一人一签"><a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#single-party-single-signature">一人一签</a></h5>
<ul>
<li>Proposer, payer, authorizer是同一个account (<code>0x01</code>)</li>
<li>只要交易必须签名</li>
<li>提案密钥必须有充分的签名权重。</li>
</ul>
<table>
<thead>
<tr>
<th>Account</th>
<th>Key ID</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x01</code></td>
<td>1</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">account1, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;01&quot;))

key1 := account1.Keys[0]

// 安全的通过私钥创建一个签名器
key1Signer := getSignerForKey1()

tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction { 
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetGasLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetPayer(account1.Address).
    AddAuthorizer(account1.Address)

// 账户1 使用 key 1 进行交易的签名
err := tx.SignEnvelope(account1.Address, key1.Index, key1Signer)
</code></pre>
<p><a href="/examples#single-party-single-signature">完整的可运行的例子</a></p>
<hr>
<h5 id="多人签名"><a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#single-party-multiple-signatures">多人签名</a></h5>
<ul>
<li>
<p>Proposer, payer, authorizer是同一个account (<code>0x01</code>)</p>
</li>
<li>
<p>只要交易必须签名</p>
</li>
<li>
<p>每个密钥的权重为0.5，因此需要两个签名者。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Account</th>
<th>Key ID</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x01</code></td>
<td>1</td>
<td>0.5</td>
</tr>
<tr>
<td><code>0x01</code></td>
<td>2</td>
<td>0.5</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">account1, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;01&quot;))

key1 := account1.Keys[0]
key2 := account1.Keys[1]

//  安全的通过私钥创建两个签名器
key1Signer := getSignerForKey1()
key2Signer := getSignerForKey2()

tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction { 
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetGasLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetPayer(account1.Address).
    AddAuthorizer(account1.Address)

//  账户1 使用 key 1 进行交易的签名
err := tx.SignEnvelope(account1.Address, key1.Index, key1Signer)

//  账户1 使用 key 2 进行交易的签名
err = tx.SignEnvelope(account1.Address, key2.Index, key2Signer)
</code></pre>
<p><a href="/examples#single-party-multiple-signatures">完整的可运行的例子</a></p>
<hr>
<h5 id="多方"><a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties">多方</a></h5>
<ul>
<li>
<p>Proposer和authorizer是同一个账号(<code>0x01</code>)</p>
</li>
<li>
<p>Payer是一个单独的帐户(<code>0x02</code>).</p>
</li>
<li>
<p>帐户<code>0x01</code>对有效支付签名。</p>
</li>
<li>
<p>帐户<code>0x02</code>在交易上签名。</p>
</li>
<li>
<p>帐户<code>0x02</code>必须最后签名，因为它是付款人。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Account</th>
<th>Key ID</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x01</code></td>
<td>1</td>
<td>1.0</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>3</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">account1, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;01&quot;))
account2, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;02&quot;))

key1 := account1.Keys[0]
key3 := account2.Keys[0]

// 安全的通过私钥创建两个签名器
key1Signer := getSignerForKey1()
key3Signer := getSignerForKey3()

tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction { 
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetGasLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetPayer(account2.Address).
    AddAuthorizer(account1.Address)

// 账户1 使用 key 1 进行交易的签名
err := tx.SignPayload(account1.Address, key1.Index, key1Signer)

// 账户2 使用 key 3 进行交易的签名
// 注意: 付款者总是最后一个签名
err = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)
</code></pre>
<p><a href="/examples#multiple-parties">完整的可运行的例子</a></p>
<hr>
<h5 id="多方参与两个自动执行器"><a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties">多方参与，两个自动执行器</a></h5>
<ul>
<li>
<p>Proposer和authorizer是同一个账号(<code>0x01</code>)</p>
</li>
<li>
<p>Payer是一个单独的帐户(<code>0x02</code>)</p>
</li>
<li>
<p>帐户<code>0x01</code>对支付签名。</p>
</li>
<li>
<p>帐户<code>0x02</code>在交易上签名。</p>
</li>
</ul>
<p>-帐户<code>0x02</code>必须最后签名，因为它是付款人。</p>
<p>-帐户<code>0x02</code>也是一个授权器，用于展示如何将两个authaccount包含到一个事务中</p>
<table>
<thead>
<tr>
<th>Account</th>
<th>Key ID</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x01</code></td>
<td>1</td>
<td>1.0</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>3</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">account1, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;01&quot;))
account2, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;02&quot;))

key1 := account1.Keys[0]
key3 := account2.Keys[0]

// 安全的通过私钥创建两个签名器
key1Signer := getSignerForKey1()
key3Signer := getSignerForKey3()

tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction {
            prepare(signer1: AuthAccount, signer2: AuthAccount) {
              log(signer.address)
              log(signer2.address)
          }
        }
    `)).
    SetGasLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetPayer(account2.Address).
    AddAuthorizer(account1.Address).
    AddAuthorizer(account2.Address)

//  账户1 使用 key 1 进行交易的签名
err := tx.SignPayload(account1.Address, key1.Index, key1Signer)

//  账户2 使用 key 3 进行交易的签名
//  注意: 付款者总是最后一个签名
err = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)
</code></pre>
<p><a href="/examples#multiple-parties-two-authorizers">完整的可运行的例子</a></p>
<hr>
<h5 id="多方参与多个签名"><a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties-multiple-signatures">多方参与，多个签名</a></h5>
<ul>
<li>
<p>Proposer和authorizer是同一个账号(<code>0x01</code>)</p>
</li>
<li>
<p>Payer是一个单独的帐户(<code>0x02</code>)</p>
</li>
<li>
<p>帐户<code>0x01</code>对有效付款签名。</p>
</li>
<li>
<p>帐户<code>0x02</code>在交易上签名。</p>
</li>
<li>
<p>帐户<code>0x02</code>必须最后签名，因为它是付款人。</p>
</li>
<li>
<p>两个账户都必须签名两次(每个密钥签名一次)。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Account</th>
<th>Key ID</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x01</code></td>
<td>1</td>
<td>0.5</td>
</tr>
<tr>
<td><code>0x01</code></td>
<td>2</td>
<td>0.5</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>3</td>
<td>0.5</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>4</td>
<td>0.5</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">account1, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;01&quot;))
account2, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;02&quot;))

key1 := account1.Keys[0]
key2 := account1.Keys[1]
key3 := account2.Keys[0]
key4 := account2.Keys[1]

// 安全的通过私钥创建4个签名器
key1Signer := getSignerForKey1()
key2Signer := getSignerForKey1()
key3Signer := getSignerForKey3()
key4Signer := getSignerForKey4()

tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction { 
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetGasLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetPayer(account2.Address).
    AddAuthorizer(account1.Address)

// 账户1 使用 key 1 进行交易的签名
err := tx.SignPayload(account1.Address, key1.Index, key1Signer)

// 账户1 使用 key 2 进行交易的签名
err = tx.SignPayload(account1.Address, key2.Index, key2Signer)

// 账户2 使用 key 3 进行交易的签名
// 注意: 付款者总是最后一个签名
err = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)

// 账户2 使用 key 4 进行交易的签名
// 注意: 付款者总是最后一个签名
err = tx.SignEnvelope(account2.Address, key4.Index, key4Signer)
</code></pre>
<p><a href="/examples#multiple-parties-multiple-signatures">完整的可运行的例子</a></p>
<h3 id="发起一笔交易">发起一笔交易</h3>
<p>You can submit a transaction to the network using the Access API client.</p>
<pre><code class="language-go">import &quot;github.com/onflow/flow-go-sdk/client&quot;

// 连接本地服务
c, err := client.New(&quot;localhost:3569&quot;)
if err != nil {
    panic(&quot;failed to connect to emulator&quot;)
}

ctx := context.Background()

err = c.SendTransaction(ctx, tx)
if err != nil {
    panic(&quot;failed to send transaction&quot;)
}
</code></pre>
<h3 id="查询交易结果">查询交易结果</h3>
<p>提交交易后，您可以通过ID查询交易状态:</p>
<pre><code class="language-go">result, err := c.GetTransactionResult(ctx, tx.ID())
if err != nil {
    panic(&quot;failed to fetch transaction result&quot;)
}
</code></pre>
<p>结果包括一个“Status”字段，该字段将是以下值之一:</p>
<ul>
<li>
<p><code>UNKNOWN</code> - 该交易尚未被网络看到。</p>
</li>
<li>
<p><code>PENDING</code> - 交易尚未包含在一个块中。</p>
</li>
<li>
<p><code>FINALIZED</code> - 交易已包含在一个区块中。</p>
</li>
<li>
<p><code>EXECUTED</code> - 交易已执行，但结果尚未打包。</p>
</li>
<li>
<p><code>SEALED</code> - 事务已经被执行并且结果被打包在一个块中。</p>
</li>
</ul>
<pre><code class="language-go">if result.Status == flow.TransactionStatusSealed {
  fmt.Println(&quot;Transaction is sealed!&quot;)
}
</code></pre>
<p>结果还包含一个“Error”，该“Error”包含失败事务的错误信息。</p>
<pre><code class="language-go">if result.Error != nil {
    fmt.Printf(&quot;Transaction failed with error: %v\n&quot;, result.Error)
}
</code></pre>
<h3 id="查询区块">查询区块</h3>
<p>你可以使用' GetLatestBlock '方法来获取最新的打包或未打包的区块:</p>
<pre><code class="language-go"> 
isSealed := true
latestBlock, err := c.GetLatestBlock(ctx, isSealed)
if err != nil {
    panic(&quot;failed to fetch latest sealed block&quot;)
}

 
isSealed := false
latestBlock, err := c.GetLatestBlock(ctx, isSealed)
if err != nil {
    panic(&quot;failed to fetch latest unsealed block&quot;)
}
</code></pre>
<p>一个块包含以下字段:</p>
<ul>
<li>
<p><code>ID</code> - 块的ID(散列)</p>
</li>
<li>
<p><code>ParentBlockID</code> - 链中前一个块的ID。</p>
</li>
<li>
<p><code>Height</code> - 链条中区块的高度。</p>
</li>
<li>
<p><code>collectionguarantee</code> - 集合中包含的集合列表。</p>
</li>
</ul>
<h3 id="执行一个脚本">执行一个脚本</h3>
<p>可以使用“ExecuteScriptAtLatestBlock”方法根据最新的密封执行状态执行只读脚本。</p>
<p>此功能可用于从区块链读取状态。</p>
<p>脚本必须采用以下形式:</p>
<ul>
<li>具有单一返回值的单一<code>main</code>函数</li>
</ul>
<p>这是一个有效脚本的例子:</p>
<pre><code>fun main(): Int { return 1 }
</code></pre>
<pre><code class="language-go">import &quot;github.com/onflow/cadence&quot;

script := []byte(&quot;fun main(): Int { return 1 }&quot;)

value, err := c.ExecuteScript(ctx, script)
if err != nil {
    panic(&quot;failed to execute script&quot;)
}

ID := value.(cadence.Int)

// 转换成  Go int 类型
myID := ID.Int()
</code></pre>
<h3 id="查询事件">查询事件</h3>
<p>你可以查询事件与' GetEventsForHeightRange '函数:</p>
<pre><code class="language-go">import &quot;github.com/onflow/flow-go-sdk/client&quot;

blocks, err := c.GetEventsForHeightRange(ctx, client.EventRangeQuery{
    Type:       &quot;flow.AccountCreated&quot;,
    StartHeight: 10,
    EndHeight:   15,
})
if err != nil {
    panic(&quot;failed to query events&quot;)
}
</code></pre>
<h4 id="事件查询格式">事件查询格式</h4>
<p>一个事件查询包括以下字段:</p>
<p><strong>Type</strong></p>
<p>要筛选的事件类型。事件类型由声明它们的帐户和合约命名。</p>
<p>例如, 一个 <code>Transfer</code> 被定义在一个 <code>Token</code> 合约中，该合约被部署在账户 <code>0x55555555555555555555</code> 中， 将会得到一个类型 <code>A.0x55555555555555555555.Token.Transfer</code>.</p>
<p>阅读 <a href="https://github.com/onflow/cadence/blob/master/docs/language.md#events">语言文档</a> 关于 Cadence 语言.</p>
<p><strong>StartHeight, EndHeight</strong></p>
<p>要过滤的块。事件将从“StartHeight”到“EndHeight”范围内的块返回。</p>
<h4 id="事件的结果">事件的结果</h4>
<p>函数的作用是: 返回按块分组的事件。</p>
<p>每个块包含一个按执行顺序匹配查询的事件列表。</p>
<pre><code class="language-go">for _, block := range blocks {
    fmt.Printf(&quot;Events for block %s:\n&quot;, block.BlockID)
    for _, event := range block.Events {
        fmt.Printf(&quot; - %s&quot;, event)
    }
}
</code></pre>
<!--
#### Decoding an Event

TODO: 事件解码示例
-->
<h3 id="查询账户">查询账户</h3>
<p>您可以查询帐户的状态用 <code>GetAccount</code> 函数:</p>
<pre><code class="language-go">import &quot;github.com/onflow/flow-go-sdk&quot;

address := flow.HexToAddress(&quot;01&quot;)

account, err := c.GetAccount(ctx, address)
if err != nil {
    panic(&quot;failed to fetch account&quot;)
}
</code></pre>
<p>A <code>flow.Account</code> contains the following fields:</p>
<ul>
<li><code>Address: flow.Address</code> - The account address.</li>
<li><code>Balance: uint64</code> - The account balance.</li>
<li><code>Code: []byte</code> - The code deployed at this account.</li>
<li><code>Keys: []flow.AccountKey</code> - A list of the public keys associated with this account.</li>
</ul>
<h2 id="例子">例子</h2>
<p><a href="/examples">examples</a>目录包含使用SDK与控件交互的代码示例</p>
<p><a href="https://github.com/onflow/flow/blob/master/docs/emulator.md">Flow Emulator</a>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以太坊开发简介]]></title>
        <id>https://lianqiujun.co/post/yi-tai-fang-kai-fa-jian-jie</id>
        <link href="https://lianqiujun.co/post/yi-tai-fang-kai-fa-jian-jie">
        </link>
        <updated>2020-11-02T07:48:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="以太坊开发一览">以太坊开发一览</h1>
<p>本文档旨在帮助你使用以太坊进行构建程序。它涵盖了以太坊概念，解释了以太坊技术栈，并记录了更复杂的应用程序和用例的高级主题。</p>
<p>如果这是你首次尝试以太坊开发，建议从头开始，像书一样逐步学习。</p>
<h2 id="1-基础知识">1. 基础知识</h2>
<ul>
<li><a href="#">以太坊简介</a></li>
</ul>
<p>关于以太坊知识的快速概览</p>
<ul>
<li><a href="#">Web2 vs Web3</a></li>
</ul>
<p>基于区块链的应用程序与传统应用程序的根本区别</p>
<ul>
<li><a href="#">dapp简介</a></li>
</ul>
<p>去中心化应用程序的简单介绍</p>
<ul>
<li><a href="#">以太坊虚拟机（EVM）</a></li>
</ul>
<p>EVM处理以太坊网络上的所有计算过程，关于EVM的简单介绍</p>
<ul>
<li><a href="#">区块</a></li>
</ul>
<p>区块链中确保数据状态同步的关键环节“区块”，可以保证所有参与者之间同步数据，形成一条链</p>
<ul>
<li><a href="#">帐户</a></li>
</ul>
<p>以太坊的账户是网络中可以保持余额并发送交易的实体</p>
<ul>
<li><a href="#">交易</a></li>
</ul>
<p>导致以太坊状态改变或资产转移以及其他行为的总称</p>
<ul>
<li><a href="#">区块浏览器</a></li>
</ul>
<p>一种读取有关交易，账户，区块和网络数据的工具</p>
<ul>
<li><a href="#">Gas 气体</a></li>
</ul>
<p>处理交易所需的任何计算都需要消耗Gas气体，由交易发送方以ETH支付相应的Gas 费用</p>
<ul>
<li><a href="#">挖矿</a></li>
</ul>
<p>帮助以太坊系统进行处理交易和创建区块的方式</p>
<ul>
<li><a href="#">以太坊网络</a></li>
</ul>
<p>以太坊包含主网和多个测试网络</p>
<ul>
<li><a href="#">节点和客户端</a></li>
</ul>
<p>参与网络的个人以及他们运行以验证交易的软件</p>
<h2 id="2-以太坊技术栈">2. 以太坊技术栈</h2>
<ul>
<li><a href="#">技术栈介绍</a></li>
</ul>
<p>以太坊/ web3 技术栈相关概述</p>
<ul>
<li><a href="#">智能合约</a></li>
</ul>
<p>部署在以太坊上，交易触发时运行相关功能的程序</p>
<ul>
<li><a href="#">编程语言</a></li>
</ul>
<p>参与以太坊开发可以使用的编程语言</p>
<ul>
<li><a href="#">JavaScript 客户端库</a></li>
</ul>
<p>让web应用与以太坊上智能合约进行方便交互的库</p>
<ul>
<li><a href="#">安全</a></li>
</ul>
<p>以太坊开发的安全规范</p>
<ul>
<li><a href="#">存储</a></li>
</ul>
<p>以太坊开发的数据存储</p>
<ul>
<li><a href="#">开发框架</a></li>
</ul>
<p>简化以太坊开发的工具</p>
<ul>
<li><a href="#">开发环境</a></li>
</ul>
<p>编写dapp代码的最佳环境</p>
<h2 id="3-高级知识">3. 高级知识</h2>
<ul>
<li>
<p><a href="#">代币标准</a></p>
</li>
<li>
<p><a href="#">Oracle 预言机</a></p>
</li>
<li>
<p><a href="#">Layer 2 拓展</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是智能合约及其运作方式？]]></title>
        <id>https://lianqiujun.co/post/shi-me-shi-zhi-neng-he-yue-ji-qi-yun-zuo-fang-shi</id>
        <link href="https://lianqiujun.co/post/shi-me-shi-zhi-neng-he-yue-ji-qi-yun-zuo-fang-shi">
        </link>
        <updated>2020-10-10T04:29:15.000Z</updated>
        <content type="html"><![CDATA[<p>智能合约是执行一组指令的计算机代码。Dapps是去中心的应用程序，与智能合约相互结合在一起，让人们可以与之交互。</p>
<h2 id="简单介绍">简单介绍</h2>
<ul>
<li>
<p>智能合约是表示为一段代码的合约，旨在执行一组指令。</p>
</li>
<li>
<p>“智能合约”一词是在1990年代由Nick Szabo撰写的学术论文中提出的。</p>
</li>
<li>
<p>Dapps或去中心化应用程序本质上是一系列的智能合约交互。</p>
</li>
</ul>
<p>我们都熟悉应用程序和应用程序商店。你通常是浏览各种软件，下载所需的应用程序，然后就离开了。</p>
<p>在精美的UX和UI界面后面，这些应用程序正在执行其创建者制定的一组特定指令或程序。它可能是一款游戏，日历或商店服务等。</p>
<p>智能合约的执行有与之非常相似的功能。但智能合约是指以一段代码表示的合约，旨在执行一组指令。</p>
<p>Vitalik Buterin和以太坊社区相信这是区块链的未来。如果说比特币是商业世界的黄金，那么智能合约就是商业世界赖以生存的石油。</p>
<h2 id="智能合约如何工作">智能合约如何工作？</h2>
<p>因此，如果你想在没有智能合约的情况下在线购买汽车。为此，你需要：</p>
<ol>
<li>
<p>找到一个汽车销售网站，列出或保存你想要查看的所有汽车的信息。</p>
</li>
<li>
<p>与卖家沟通的购买支付方式等，确认了使用何种支付系统，可让你在见到车后进行支付。如果汽车不是你想要的，则有一定的退款能力。</p>
</li>
<li>
<p>你还需要向当局注册汽车所有权。</p>
</li>
</ol>
<p>所有这些点都要求你<strong>信任你正在访问的站点或服务，而且在很多时候，该过程的每个部分都由不同的公司或个人控制</strong>。</p>
<p>行为不良的个人或组织无需花费太多时间即可更改上述任何一项的正常运作，从而使整个过程无效。</p>
<p>签订智能合约可以消除在购买商品时解决多方信任的问题。</p>
<p>为什么？智能合约的特点是：</p>
<p>🔒安全 - 他们使用加密技术来阻止人们更改记录。</p>
<p>🔍透明 - 每个人都可以在区块链上看到智能合约的含义以及它的用途。</p>
<p>🙏不再需要中间商 - 智能合约不需要第三方进行验证。区块链为你做到这一点。</p>
<p>🤖自治 - 它们会自动工作，因此你不必等待有人主动去执行。</p>
<p>✅准确  - 因为智能合约是用代码编写的，所以它们不依赖于语言的灰色区域以及单词的含义。如果发生这种情况，请执行以下操作。</p>
<p>智能合约的核心往往是一种机制（用计算机代码表示），“如果发生这种情况，那就这样做”。</p>
<p>现在已经能够发现许多的自动化场景。假设你要使用借记卡或信用卡支付费用。你的银行所运行的软件将执行“如果发生这种情况，则执行此操作”：</p>
<p>💸 如果银行帐户中的金额大于要求的金额，请释放资金</p>
<p>💵 如果银行帐户中的金额少于要求的金额，请勿释放资金</p>
<p><strong>智能合约的区别在于，该决定权属于区块链，而不是由银行（或任何第三方）来控制</strong>。</p>
<p>因此，上述示例将其应用于基于区块链的智能合约中，将看到以下内容：</p>
<p>💸 如果数字钱包中的金额较大且尚未用完，请释放资金。</p>
<p>💵 如果数字钱包中的金额较小或已用完，请勿释放资金。</p>
<p><strong>关于智能合约的令人兴奋的一点是，它意味着任何人都可以与任何其他人达成协议，而区块链会记录整个事情</strong>。</p>
<h2 id="dapp如何使用智能合约">Dapp如何使用智能合约？</h2>
<p>最好将Dapps或去中心化应用程序视为捆绑在一起的一堆智能合约。</p>
<p>单独的智能合约只能用于一种类型的交易。但是，dapp可以将多个智能合约捆绑在一起以执行更复杂的事情。</p>
<p>就像今天的应用程序一样，dapp也可以在合约之上放置友好的界面。</p>
<p>一些著名的DAPP：</p>
<p>📉 Augur - 一个市场预测工具，它允许任何人去预测事件并获得奖励。</p>
<p>🏦 MakerDAO - 一种去中心化金融（DeFi） dapp，使用户无需中间人就可以借出和借用加密货币。</p>
<p>🦄 Uniswap - 基于以太坊的去中心化交易所，无门槛，允许任何人去交换ERC20代币。</p>
<p>🐱 CryptoKitties  - 独特的NFT为基础的加密收藏品可以使用智能合同，创造独一无二的加密宠物。</p>
<p>👛 Argent - 一个使用智能合约管理地址和私钥的以太坊的钱包。</p>
<h2 id="谁创建了智能合约">谁创建了智能合约？</h2>
<p>就像用于支持大多数加密货币的区块链技术一样，智能合约是从不太完善的早期技术中衍生出来的。当下的智能合约，它们源自较早的电子指令执行程序，该程序使用if / else语句或使用其他条件逻辑，根据提供的信息自动产生结果。</p>
<p>“智能合约”一词本身是在1990年代由著名的计算机科学家和密码学家Nick Szabo撰写的一篇学术论文中创造的，该科学家还是负责开发比特币的最早先驱之一，即Bit Gold。Szabo最初出于各种基本目的描述了智能合同，但后来在1996年的论文中详细阐述了该技术在数字现金，智能财产等方面的潜在用例。</p>
<p>以太坊在其区块链上实施了图灵完备的语言，从而可以在其智能合约中实现了更复杂的逻辑。</p>
<p>智能合约并不总是完美的，尽管智能合约通常被认为是执行协议和逻辑的“无需信任”的方式，但并非完全没有问题。</p>
<p>一方面，智能合约在许多区块链上都是不可变的。这意味着一旦启动它们，就不能对其进行更改或升级，如果代码存在根本问题，则可能导致灾难性的后果。这可能是2016年以太坊The DAO黑客事件中最突出的一点原因，该黑客利用The DAO 合约功能中的漏洞，偷走了数百万以太坊（ETH）。</p>
<p>未知和新颖的攻击媒介也经常被利用，通常以投资者亏本而告终。在2020年9月，随着Yearn Finance的Andre Cronje的一个项目Eminence的测试版本的崩溃。当时大量投资者将资金投入其中之后，它被一个未知的黑客盗取了1500万美元。</p>
<p>同样，简单的错误代码很可能会使智能合约变得无用。这可以从2020年8月DeFi产量农业项目YAM的崩溃中看出，该项目使用未经审计的智能合约，并因严重的错误而崩溃，导致其治理功能毫无作用。</p>
<h2 id="智能合约的未来">智能合约的未来</h2>
<p>如今，大多数区块链都具有智能合约功能，活跃的开发者社区使用Cosmos，NEO和Hyperledger等区块链上的智能合约来创建dapp。智能合约的功能 范围从比特币或莱特币之类的非常简单的货币到以太坊，Tron和Polkadot等具有Dapp功能的更高级的区块链上。</p>
<p>它们现在用于各种各样的任务，包括数字身份，供应链管理，保险，数据存储等等。</p>
<p>我们仍处在可以使用智能合约和dapp的初期。但是已经有公司甚至政府在尝试其潜力。</p>
<p>🏦 政府 - 爱沙尼亚等国家已经开始使用区块链来管理国家。</p>
<p>🔗 供应链 - 像Provenance这样的初创公司正在帮助制造公司使用区块链来购买和运送商品。</p>
<p>📓 保险 - 像Etherisc这样的新兴公司正在帮助为航空和农业行业创建保险平台。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是以太坊2.0及其重要性？]]></title>
        <id>https://lianqiujun.co/post/shi-me-shi-yi-tai-fang-20-ji-qi-chong-yao-xing</id>
        <link href="https://lianqiujun.co/post/shi-me-shi-yi-tai-fang-20-ji-qi-chong-yao-xing">
        </link>
        <updated>2020-10-09T06:27:24.000Z</updated>
        <content type="html"><![CDATA[<p>以太坊网络升级成以太坊2.0是一个长期计划。旨在解决当前网络的可扩展性和安全性问题。在以太坊2.0完成后，它将转换成为采用权益证明共识机制的区块链“世界计算机”。</p>
<h2 id="简单介绍">简单介绍</h2>
<ul>
<li>
<p>按市值计算的第二大加密货币以太坊正在计划对其网络进行重大更新。</p>
</li>
<li>
<p>以太坊2.0升级旨在解决网络的可扩展性和安全性。</p>
</li>
<li>
<p>升级的第一阶段将于2020年进行，以太坊将转向权益证明共识机制(PoS)。</p>
</li>
</ul>
<h2 id="什么是以太坊20">什么是以太坊2.0？</h2>
<p>以太坊2.0分多个阶段启动，首次升级预计将在2020年底启动。</p>
<p>以太坊2.0与以太坊最大的不同在于，它将采用“权益证明（PoS）”机制替换当前采用的“工作量证明（PoW）”机制。</p>
<h2 id="权益证明与工作证明有何不同">权益证明与工作证明有何不同？</h2>
<p>对于以太坊等区块链，需要以去中心化的方式验证交易。与比特币一样，以太坊目前使用一种称为工作量证明（PoW）的共识机制。</p>
<p>在该系统中，矿工使用计算机硬件的计算能力来解决复杂的数学难题并验证新交易。第一个解决难题的矿工将新交易添加到组成区块链的所有交易的记录中。然后用加密货币奖励他们。但是，此过程可能会消耗大量能源，效率并不乐观。</p>
<p>权益证明（PoS）的不同之处在于，用交易验证程序代替矿工，向加密货币提供验证交易的权利。选择这些验证器以根据其持有的数量和持有的时间长短来选择一个区块。</p>
<p>然后，其他验证者可以证明他们看到了一个验证结果。当有足够的证明时，可以将一个区块添加到区块链中。然后，验证者将因成功提出区块建议而获得奖励。此过程称为“锻造”或“铸造”。</p>
<p>PoS的主要优点是，它比PoW的能源效率高得多，因为它将能源密集型计算机处理与共识算法分离开来。这也意味着你不需要大量的计算能力即可保护区块链。</p>
<h2 id="以太坊20如何比以太坊10更好地扩展">以太坊2.0如何比以太坊1.0更好地扩展？</h2>
<p>升级到以太坊2.0的主要原因之一是可拓展性。使用以太坊1.0，网络每秒只能支持大约30个事务。这会导致延误和拥堵。以太坊2.0承诺每秒最多交易100,000次。这种增加将通过实施分片技术来实现。</p>
<p>当前的以太坊是由单个链和连续块组成的区块链。这是安全的，但是非常慢并且效率不高。随着分片链的引入，该区块链被拆分，从而使交易可以并行链而不是连续链进行处理。这样可以加快网络速度，并且可以更轻松地扩展。</p>
<h2 id="以太坊20如何更安全">以太坊2.0如何更安全？</h2>
<p>以太坊2.0的设计考虑了安全性。大多数权益证明网络都只有少量的验证器，这会使系统更集中并且网络安全性降低。以太坊2.0至少需要16,384个验证器，使其更加分散，因此更加安全。</p>
<p>以太坊2.0代码的安全审核由包括区块链安全公司Least Authority在内的组织进行。</p>
<p>以太坊基金会正在为以太坊2.0建立专门的安全团队，以研究加密货币中可能存在的网络安全问题。以太坊2.0研究人员贾斯汀·德雷克（Justin Drake）在一条推文中表示，这项研究将包括“模糊测试，赏金悬赏，加密经济建模，应用密码分析，形式验证等”。</p>
<h2 id="以太坊20升级将如何进行">以太坊2.0升级将如何进行？</h2>
<p>在Topaz，Medalla，Spadina和Zinken一系列测试网络发布之后，以太坊2.0的全面推出将分三个阶段进行：阶段0，阶段1和阶段2（开发人员希望从零开始计数）。阶段0的目标是在2020年启动，其他阶段则在接下来的几年中进行。</p>
<p>阶段0，存储和管理验证者的注册表，并为以太坊2.0部署权益证明（PoS）共识机制。原始的以太坊PoW链将与此同时运行，因此数据连续性不会中断。</p>
<p>阶段1，将于2021年进行，将整合权益分片链的证明。该网络预计将以64个分片启动（吞吐量是以太坊1.0的64倍），尽管在启动时它们尚不支持帐户或智能合约。并且，将于2021年进行一次临时更新，它将使以太坊主网正式过渡到权益证明。</p>
<p>阶段2，计划于2021/22推出，将使分片变得功能齐全并与智能合约兼容。它还涉及添加以太坊帐户并启用转账和提款，实施跨分片转账以及签订合同。它将为基于以太坊2.0的可扩展应用程序构建执行环境。</p>
<h2 id="以太坊20未来发展">以太坊2.0未来发展</h2>
<p>2020年9月，有消息称Spadina测试网在启动时遇到了问题，迫使至少在发布前要再进行一次“彩排”。Spadina是旨在测试以太坊2.0的创世纪或第一个区块的创建的短期测试网。它与较大的Medalla测试网不同，后者是一个通用的沙箱，代表了网络的运行版本。Spadina测试网存在的问题主要包含用户参与度低，“混乱”和“无效存款”。</p>
<p>更多的改进还在继续中，这种加密货币的未来将如何发展？</p>
<p>以太坊联合创始人Vitalik Buterin制定了路线图，说明未来五到十年如何才能实现以太坊2.0。他说，在过去的两年中，试图了解可能的发展方向，到具体的研究与开发，试图优化我们知道可以实施的特定原语，以太坊已经发生了有效的转变。”</p>
<p>他说，现在的挑战主要是“越来越多地围绕以太坊进行的应用在快速的发展，而发展的速度将随着时间的推移而继续增长，而以太坊2.0尚未准备好。”。</p>
<p>2020年6月，Buterin指出，在实施分片链之前，以太坊2.0至少还需要依赖ZK-rollups等当前可行的扩展方法。</p>
<p>ZK-rollups可以与当前的以太坊网络配合使用，并允许其处理更多交易。他们从实际的区块链上处理交易，然后每隔一段时间上传一次。这是一种快速增加以太坊交易数量的方式，而不会引起网络上的巨大膨胀。</p>
<p>但是使用ZK-rollups存在潜在的缺陷，根据以太坊2.0路线图，建立ZK-rollups依赖于一个集中的参与者—通常是开发者。该路线图指出：“这会诱使开发人员操纵代码或提供漏洞信息，从而破坏了权力下放并增加了社交工程遭到黑客攻击的风险。”</p>
<p>因此，从某种意义上说，这并不是一个完美的解决方案。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是Decentraland？]]></title>
        <id>https://lianqiujun.co/post/shi-me-shi-decentraland</id>
        <link href="https://lianqiujun.co/post/shi-me-shi-decentraland">
        </link>
        <updated>2020-09-29T09:31:08.000Z</updated>
        <content type="html"><![CDATA[<p><code>Decentraland是一个建立在以太坊区块链上的虚拟世界，人们可以在这里进行购买，出售，社交等活动。</code></p>
<p>《模拟城市》，《文明》，《我的世界》。游戏开发人员花费了数年时间来制作世界级的游戏，使人们能够建造建筑物，城市或殖民整个世界。但是，除了您击败的数字敌人之外，您在制作这些出色作品中还能更多的展示什么呢？不多。如果您将真实的货币价值赋予所创造的东西，然后将其出售给出价最高的人，将会发生什么？这就是Decentraland的承诺，Decentraland是一款由区块链驱动的世界构建游戏。</p>
<p>Decentraland可以帮助创造新的世界和新的财富类型，还是仅仅在利用旧的财富？</p>
<h2 id="什么是decentraland">什么是Decentraland？</h2>
<p>土地所有者控制在其土地上发布的内容，该内容被编码为智能合约。这些内容可以是图像、应用、游戏等任何内容。用户可以以与现实世界类似的方式探索，旅行和访问场所。该平台还是用户交互的点对点网络。</p>
<p>借助Decentraland，我们正在创建一个生态系统，将在加密货币上实现的许多解决方案与即将被大量采用的VR系统结合在一起。其结果是一个带有原始经济网络的社会3D世界。</p>
<h2 id="如何在decentraland购买土地">如何在Decentraland购买土地？</h2>
<p>你知道吗？Decentraland上的土地包裹已经卖了数千万美元。在2017年12月的一次交易所中，一块土地以60,000美元的价格售出！</p>
<h2 id="你可以用mana做什么">你可以用MANA做什么？</h2>
<p>加密货币MANA是一种实用通证，例如LAND，将在Decentraland的世界中使用。代币将用于支付土地，化身，物品，收藏品以及赌博等娱乐活动。赚取MANA的能力是对开发人员创建和管理优质内容的一种激励。MANA还是ERC-20代币，可以在加密货币交易所购买和交易。</p>
<p>MANA有固定的供应，当购买LAND来换取MANA时，MANA将被销毁掉了。</p>
<h2 id="谁创造了decentraland">谁创造了Decentraland？</h2>
<p>Decentraland由Esteban Ordano创立，注册为Metaverse Holdings Ltd，总部位于中国北京。Ordano是在一个软件工程师BitPay和相信共同打造领先的Bitcoin基础设施库，Bitcore。他还从事Copay的工作，并领导了创建Streamium应用程序的团队。Ordano与其他Decentraland团队成员一起在阿根廷共同创建了一个面向区块链的黑客空间，名为Voltaire。</p>
<ul>
<li>
<p>2015年–成立了Decentraland</p>
</li>
<li>
<p>2017年8月-首次代币发行（ICO）筹集了2000万美元</p>
</li>
<li>
<p>2017年12月–举行了第一次“土地”拍卖，开发商在这里挑选了主要的虚拟财产位置</p>
</li>
<li>
<p>2018年3月–在因需求而成为优先事项之后，开设了Decentraland土地市场</p>
</li>
<li>
<p>2018年6月–开发人员开始制作作品，该月的LAND销量是CryptoKitties销量的两倍。</p>
</li>
<li>
<p>2019年4月–带有护照的可定制化身揭幕，并将很快推出。</p>
</li>
</ul>
<p>从2018年1月21日到2018年10月22日，Decentraland记录了近39,000笔交易，代表MANA花费了2,350万美元。</p>
<h2 id="未来发展">未来发展</h2>
<p>Decentraland仍在开发中。它已经经历了几个阶段的发展，恰当地称为“石器时代”和“铜器时代”，其路线图中还有更多。在每个阶段中，都会添加新功能，例如创建应用程序，聊天应用程序等的功能。</p>
<p>最终的目标是让Decentraland拥有自己的经济，在那里人们可以将土地出租给其他人，在产品和服务的广告广告牌上放置广告，并在游戏内创建聚集场所供用户度过。</p>
<p>Decentraland的巨大承诺是，就像常规游戏一样，区块链可以变得有趣且引人入胜，而且还可以帮助人们以只有区块链才能实现的方式获得财产所有权。</p>
<p>会成功吗？时间会证明一切。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git功能分支工作流实践]]></title>
        <id>https://lianqiujun.co/post/git-gong-neng-fen-zhi-gong-zuo-liu-shi-jian</id>
        <link href="https://lianqiujun.co/post/git-gong-neng-fen-zhi-gong-zuo-liu-shi-jian">
        </link>
        <updated>2020-09-23T10:08:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="工作流">工作流</h2>
<p><strong>核心思路</strong>:  所有的功能开发应该在一个专门的分支，而不是在master分支上。</p>
<p>这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。 另外，也保证了master分支的代码一定不会是有问题的，极大有利于集成环境。</p>
<pre><code>1. git checkout -b new-featureA master


2. dev

3. git push -u origin new-featureA

4. git merge new-featureA
 

</code></pre>
<h2 id="功能分支实践">功能分支实践</h2>
<p>功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用Pull Requests的方式讨论变更。</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9488460"><label class="task-list-item-label" for="task-item-9488460"> 1. 现有远程主分支master</label></li>
</ul>
<pre><code>coderA 拉取到本地

git clone ssh://user@host/path/to/repo.git

</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2739226"><label class="task-list-item-label" for="task-item-2739226"> 2. coderA  开发新功能</label></li>
</ul>
<p>coderA 将代码拉取到本地，将要开发新功能featureA</p>
<pre><code>git checkout -b new-featureA master


dev ing...

git status
git add &lt;some-file&gt;
git commit

</code></pre>
<p>将新的功能push分支到中央仓库是很好的做法，这样可以方便地备份，如果和其它开发协作，也让他们可以看到coderA的提交。</p>
<pre><code>git push -u origin new-featureA
</code></pre>
<p>这条命令push new-featureA分支到中央仓库（origin），-u选项设置本地分支去跟踪远程对应的分支。 设置好跟踪的分支后，coderA就可以使用git push命令省去指定推送分支的参数。</p>
<pre><code>之后就可以在 new-featureA 分支下完成开发，最后推送到远程的分支上， 并可以向master 发起 Pull Request 

git push 
</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5250939"><label class="task-list-item-label" for="task-item-5250939"> 3. 接受 Pull Request</label></li>
</ul>
<p>adminCoder 看到 coderA 开发的新功能，可以review并在该分支上进行修改，讨论，最后接受Pull Request</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2556321"><label class="task-list-item-label" for="task-item-2556321"> 4. 分支合并到master</label></li>
</ul>
<pre><code>方法一：
git checkout master
git pull
git pull origin new-featureA
git push

方法二：
git merge new-featureA
</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1770254"><label class="task-list-item-label" for="task-item-1770254"> 5. 其他补充操作</label></li>
</ul>
<pre><code>查看分支:
$ git branch

切换分支：
$ git checkout master

删除分支：
git branch -d (branchname)

简化步骤:
git commit -am &quot;可以提交跟踪过的文件&quot;

版本回退至上个版本:
$ git reset --hard HEAD^     

退到/进到 指定commit的sha码:
$ git reset --hard commit_id 

强推到远程：
$ git push origin HEAD --force

查看命令历史：
$ git reflog 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git集中式工作流实践]]></title>
        <id>https://lianqiujun.co/post/git-ji-zhong-shi-gong-zuo-liu-shi-jian</id>
        <link href="https://lianqiujun.co/post/git-ji-zhong-shi-gong-zuo-liu-shi-jian">
        </link>
        <updated>2020-09-23T02:48:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="模拟团队开发流程实践">模拟团队开发流程实践</h1>
<h2 id="整体流程">整体流程</h2>
<pre><code>1.  ssh user@host 

2.  git init --bare /path/to/repo.git

3.  git clone ssh://user@host/path/to/repo.git

4. dev  ing...



5.  A Coder

git status # 查看本地仓库的修改状态
git add # 暂存文件
git commit # 提交文件
git push origin master

6. B Coder

git pull --rebase origin master
git status # 查看本地仓库的修改状态
git add # 暂存文件
git commit # 提交文件
git push origin master

7. 出现冲突，撤销 pull

git rebase --abort

</code></pre>
<h2 id="分步骤实践">分步骤实践</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7127786"><label class="task-list-item-label" for="task-item-7127786"> 1.创建项目</label></li>
</ul>
<pre><code>明确项目后，先初始化好中央仓库 裸仓库（bare repository）

ssh user@host

git init --bare /path/to/repo.git

</code></pre>
<p>团队开发人员有 coderA，coderB</p>
<hr>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7771145"><label class="task-list-item-label" for="task-item-7771145"> 2. 克隆项目</label></li>
</ul>
<p>两人分别将git项目克隆至本地：</p>
<pre><code>git clone ssh://user@host/path/to/repo.git
</code></pre>
<p>克隆仓库时Git会自动添加远程别名origin指回『父』仓库</p>
<hr>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9569198"><label class="task-list-item-label" for="task-item-9569198"> 3. 开发程序并提交代码</label></li>
</ul>
<p>coderA 开发了功能 A.txt<br>
coderB 正在开发功能 B.txt</p>
<pre><code>git status # 查看本地仓库的修改状态
git add # 暂存文件
git commit # 提交文件
</code></pre>
<p>那么coderA 先将功能A.txt发布到master仓库:</p>
<pre><code>coderA

git status # 查看本地仓库的修改状态
git add # 暂存文件
git commit # 提交文件
git push origin master
</code></pre>
<hr>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2829160"><label class="task-list-item-label" for="task-item-2829160"> 4. 更新代码，并提交代码</label></li>
</ul>
<p>此时coderB完成了，B.txt功能的开发，并准备发布至master</p>
<pre><code>git push origin master

此时，会有消息提醒：你的代码和master相比不是最新的需要更新，因为coderA增加了新功能
</code></pre>
<p>错误提示：</p>
<pre><code>error: failed to push some refs to '/path/to/repo.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
hint: before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</code></pre>
<p>所以， 先<code>同步代码</code>, 后<code>提交代码</code>:</p>
<pre><code>git pull --rebase origin master

git status # 查看本地仓库的修改状态
git add # 暂存文件
git commit # 提交文件
git push origin master
</code></pre>
<p>如果你忘加rebase这个选项，pull操作仍然可以完成，但每次pull操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。 对于集中式工作流，最好是使用rebase而不是生成一个合并提交</p>
<p>如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行<code>git pull --rebase</code>命令前的样子：</p>
<pre><code>git rebase --abort
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是Aragon？]]></title>
        <id>https://lianqiujun.co/post/shi-me-shi-aragon</id>
        <link href="https://lianqiujun.co/post/shi-me-shi-aragon">
        </link>
        <updated>2020-07-25T03:14:51.000Z</updated>
        <content type="html"><![CDATA[<pre><code>Aragon Network 希望通过区块链技术改善我们的工作方式，创建有效的去中心化组织和数字法院。
</code></pre>
<h1 id="什么是-aragon-network">什么是 Aragon Network ？</h1>
<p>人类喜欢一起工作。多年来，我们建立了无数的组织，使我们所有人彼此协作。实际上，几乎没有人能称自己为独狼。问题是：组织人是一项昂贵的工作。公司每年留出数十亿美元用于管理费用。决策会产生摩擦成本。没有总体架构，文件可能会重复或丢失；项目被推迟；有时双方要花费数年的时间才能解决争端。Aragon Network 认为他们找到了解决方案。</p>
<h1 id="什么是-aragon">什么是 Aragon ？</h1>
<p>Aragon使用区块链来提高公司和组织的效率和透明度。公司可以使用Aragon彼此签署智能合约协议。然后可以将它们安全地存储在区块链上，以供任何一方在需要时访问。Aragon喜欢视自己为数字司法管辖区。该网络正在创建一个去中心化的结算系统，该系统可用于在相关各方之间快速有效地进行仲裁。该平台具有自己的Token 令牌 Aragon Network Token - 简称“ANT” - 用于支付费用，并托管在第三方中以提供激励给良好诚实的用户行为。</p>
<h1 id="谁创造了aragon">谁创造了Aragon ？</h1>
<p>Aragon Network是Luis Cuende和Jorge Izquierdo的创意。Cuende之前曾帮助在区块链上建立时间戳技术，还与Microsoft，Telefonica和爱沙尼亚政府等公司合作。伊兹奎尔多（Izquierdo）15岁时获得了苹果奖学金。Aragon目前由Aragon基金会（Aragon Foundation）管理，该基金会是一个致力于建立和推广网络的非营利组织。</p>
<p>阿拉贡（Aragon）这个名字来自两位创始人共同成长的西班牙地区。它不是以《指环王》角色命名的；那只是一个巧合。</p>
<h1 id="aragon-简史">Aragon 简史</h1>
<p>2017年2月 - Aragon Network 诞生。<br>
2017年5月 - Aragon推出其ICO。<br>
2017年6月 - Aragon 与去中心化交易平台0x签署了合作伙伴协议。<br>
2018年2月 - Aragon Architect 推出，这是公司在平台上构建自己的个人资料的一种方式。<br>
2019年 - Aragon 成为全球最负盛名的 DAO 解决方案服务商。<br>
2020年7月 - Aragon China 成立了， 共同构建 Aragon 的东方生态。</p>
<h1 id="aragon-有什么特别之处">Aragon 有什么特别之处？</h1>
<p><strong>安全性</strong> - 用户需要先抵押Aragon代币，然后才能帮助其参与网络。这有助于创建一个诚实开放的生态系统，并使智能合约具有可执行性。由于不良或不诚实的行为，代币将被没收。</p>
<p><strong>简洁性</strong>-Aragon的智能合约必须易于阅读。这使技术知识很少的用户可以有效地使用该平台。</p>
<p><strong>稳定性</strong>-加密货币是易变资产。作为抵押品的金额最终可能会变得比最初存入时少很多。Aragon代币保持稳定的价值。该网络可以回购代币以保持价格浮动，也可以出售以阻止币值升得过高。</p>
<p><strong>隐私</strong>-Aragon上的用户无需泄露私人或机密信息。这使人们能够维护与个人身份的同时关联不同的单独的区块链身份，可用于制定协议和开展业务。</p>
<h1 id="aragon代币如何生产">Aragon代币如何生产？</h1>
<p>Aragon团队最初铸造了将近4000万个ANT代币，在ICO中出售了其中的70％。Aragon基于以太坊网络，所以这些是ERC20代币。网络完全启动并运行后，计划将根据社区的需求铸造或销毁代币。而这些决定将会由Aragon用户自己决定。</p>
<p>阿拉贡（Aragon）的ICO最初定于6月中旬运行，但这一时间被缩短了。该项目在不到15分钟的时间内达到了2500万美元的高峰。</p>
<h1 id="aragon如何运作">Aragon如何运作？</h1>
<p><strong>智能合约</strong>-Aragon使用智能合约；就像其他协议一样，它们是协议。最大的区别是它们自动实现的。他们可以自主执行交易。合同将资金托管在托管机构中，只要部分协议得到满足，它们便可以自动支付。</p>
<p><strong>预言机</strong>-需要将人类可读的合同和现实事件转换为区块链可以理解的数据。Aragon使用预言机使平台上持有的协议能够响应实际操作。</p>
<p><strong>去中心治理</strong>-在Aragon网络中，没有集中式的权力来做出决定并执行裁决。用户作为分散的自治组织或DAO的一部分来管理自己。这使他们能够通过简单的共识解决分歧。</p>
<p><strong>权力下放</strong>-每当发生纠纷时，网络都会任命一个该案的陪审员。双方将提供证据，然后陪审员将作出决定，就像在真正的法院中一样。双方均有权对该决定提出上诉；如果获得批准，将把案件提交上级法院。</p>
<h1 id="你可以使用aragon代币ant做什么">你可以使用Aragon代币（ANT）做什么？</h1>
<p>Aragon令牌用作平台上达成的协议的抵押。它们还用于支付因使用网络而产生的费用和成本。参与网络治理的陪审员和用户在ANT方面的时间投入和专业知识也将获得补偿。</p>
<h1 id="aragon-china-诞生">Aragon China 诞生</h1>
<p>Aragon China 2020年7月正式成立，Aragon China将和DAOSquare联手推进DAO在中国的发展。Aragon的成功将完全取决于有多少企业开始使用它。如果它被证明很受欢迎，它将构成一种全新的模型的基础，以使公司能够相互组织和交互，如今Aragon 在中国的发展势必让人充满期待。</p>
<h1 id="了解更多">了解更多</h1>
<ul>
<li>
<p><a href="https://aragon.org/">Aragon</a></p>
</li>
<li>
<p><a href="http://dao.aragonchina.xyz">Aragon China DAO</a></p>
</li>
<li>
<p><a href="https://aragon.org/token/ant">ANT</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[默克尔树（Merkle Trees）]]></title>
        <id>https://lianqiujun.co/post/mo-ke-er-shu-merkle-trees</id>
        <link href="https://lianqiujun.co/post/mo-ke-er-shu-merkle-trees">
        </link>
        <updated>2020-07-23T03:10:19.000Z</updated>
        <content type="html"><![CDATA[<p>默克尔树使区块链更加高效和值得信赖。Merkle树可以在保持安全性的同时节省内存和处理能力。</p>
<p>要深入了解区块链的工作原理，你需要了解其一些基本的基础架构，并且没有比Merkle Trees更基本的基础了。在本文中，我们通过深入研究Merkle树来了解区块链的工作原理。</p>
<h2 id="什么是默克尔树">什么是默克尔树？</h2>
<p>默克尔树使区块链更加高效和值得信赖。通过以某种方式组织数据，默克尔树可以节省内存和处理能力，同时还能确保所有内容的安全。安全性来自加密和哈希函数，我们将在下文中进行详细说明。</p>
<h2 id="哈希函数">哈希函数</h2>
<p>通常，Merkle树和密码学的关键组成部分是哈希。  哈希函数是一种将信息转换为一组唯一的字母和数字的过程。唯一的字符串称为哈希。即使输入的内容其一小部分发生变化，哈希输出也会完全改变。加密散列函数是一种单向函数，易于输入信息，但几乎无法获取信息。Merkle树依赖于这两种功能来组织和验证数据。</p>
<h2 id="默克尔树如何组织">默克尔树如何组织？</h2>
<p>默克尔树通过将数据分成不同的部分，使区块链更具可扩展性。在最基本的形式中，默克尔树看起来有点像圣诞树，每个“父”节点都恰好有两个“子”节点。两个子节点的哈希创建父节点的哈希。散列的过程一直遍历整个树，直到最终到达顶部的一个“根”散列为止。几乎任何数量的数据都可以放入Merkle树中，但它总是以顶部的根哈希结尾。</p>
<h2 id="它是如何工作的">它是如何工作的？</h2>
<p>在Merkle树中，诸如智能合约中或帐户之间的交易之类的数据被散列或转换为一串数字和字母。然后，再次对该散列进行散列，但是这次与树中它旁边的数据的散列（其“同级”）结合在一起。两个兄弟姐妹的新哈希创建“父母”的新哈希。散列的这一过程一直遍历树，直到到达最顶部的一个根散列为止。</p>
<p>请记住，更改哈希输入的任何部分都会极大地改变其输出。知道了这一点，我们还知道更改Merkle树中的任何数据都会导致其哈希值发生变化，而父节点的哈希值也会发生变化，最终导致根哈希值发生变化。此属性确保Merkle树中的信息被冻结并且无法更改，但可以对其进行检查和验证。</p>
<h2 id="什么是默克尔证明">什么是默克尔证明？</h2>
<p>Merkle Trees巧妙地组织了数据以备以后恢复，但是Merkle Proofs用于实际验证信息是否正确。Merkle证明使用你正在检查的信息，以及与之相连的树的所有“分支”，直至根哈希。如果哈希从该分支到根是一致的，则为true。如果根哈希值不匹配，则表明数据已被篡改。</p>
<p>Merkle Proofs不需要验证整个树中的所有信息，只需要足够的计算能力即可验证少量数据以查看其是否为真。</p>
<h2 id="谁发明了默克尔树">谁发明了默克尔树？</h2>
<p>Merkle Trees以计算机科学家兼教授Ralph Merkle的名字命名，他与Merkle Trees本身一起发明了公钥加密和加密哈希，该概念于1987年被发明出来。</p>
<p>我们的示例引用了Merkle树的最基本版本，即Binary Merkle Trees，每个父节点只有两个子节点，但是每个父节点具有更多子节点的情况要复杂得多。由于以太坊必须处理智能合约的交易，因此它使用了更为复杂的Merkle树类型，称为Patricia树。</p>
<p>Merkle证明用于区块链轻客户端。这些较少占用内存的程序使人们可以参与区块链，而无需下载每个交易和每个区块的所有数据。轻量级客户只需要知道每个块的根哈希，然后在需要时使用Merkle证明来验证信息。</p>
<h2 id="未来发展">未来发展</h2>
<p>像以太坊这样的区块链即使使用Merkle Trees 仍然无法扩展，因此这种基本的加密工具不会很快消失。不管森林有多大，它都将永远需要它的根。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[量子计算和加密货币]]></title>
        <id>https://lianqiujun.co/post/liang-zi-ji-suan-he-jia-mi-huo-bi</id>
        <link href="https://lianqiujun.co/post/liang-zi-ji-suan-he-jia-mi-huo-bi">
        </link>
        <updated>2020-07-22T03:04:10.000Z</updated>
        <content type="html"><![CDATA[<p>量子计算是计算领域的下一个巨大飞跃。但这也可能会造成加密技术的巨大破坏。我们来一起探索一下这项新技术。</p>
<p>量子计算和量子物理学听起来像是科幻小说中的东西：一切都是由波和粒子组成的，物质可以同时存在于同一位置，粒子可以被发送到星系的另一侧，但仍然保持连接。本文探讨什么是量子计算机以及它们对加密行业造成什么样的威胁。</p>
<p>科学家和研究人员开始利用量子物理学的力量来构建功能强大的计算机，并具有破解世界级别的加密算法的能力。除了区块链以外，量子计算还可能威胁全球金融系统，机密情报机构以及手机上所有数据的安全。</p>
<h2 id="什么是量子物理学">什么是量子物理学？</h2>
<p>量子物理学也称为量子力学，是仅适用于足够小的物体以适用其规则的一种物理学。在经典物理学中，几乎所有事物都以可预测的方式运行-计算和测量可以精确进行。一旦你开始研究量子物理学大小的物体，事情将变得更加不可预测。也就是说，量子力学研究的对象是不可预测的。</p>
<p>既然，不能保证量子物理学中的测量和计算是准确的，则只能使用概率来猜测。在量子水平上，粒子可以像波一样开始表现，甚至根据是否被观察而突然改变其状态。在量子领域，一切都变得不确定。</p>
<h2 id="什么是量子计算机">什么是量子计算机？</h2>
<p>通过利用量子力学定律，量子计算机可以比我们最先进的现代计算机强大得多。关于量子计算机，最重要的理解是量子位。经典计算机使用由“0”和“1”表示的位。普通位是二进制的-每次打开或关闭-一次处于一种状态，“是”或者“否”。量子位可以为“0”，“1”，以及在它们之间切换或同时为两者。由于量子计算机的基本单位是这些神奇的量子位，因此量子计算机可以以普通计算机甚至无法接近的速度执行功能或计算-这也是为什么它们有一天可能能够破解加密货币。</p>
<p>举个例子：如果我们从一台普通计算机上得到四个比特，它们可以是16种组合中的任何一种，即1000、1100、1110，但是在进行计算时只能选择将其合为一体。但是，有了四个bit位时，它们可以同时处于这16个位置中的所有位置，并且所表示的数量会成倍增加。仅20个量子位就可以并行存储超过一百万个值，这使量子计算机能够通过并行执行而不是一次单独进行计算来解决问题。</p>
<p>量子力学的思想可以追溯到1900年被认为是量子理论之父的马克斯·普朗克（Max Planck）进行的研究。量子计算机将在1980年代和1970年代晚些时候出现，当时保罗·贝尼奥夫（Paul Benioff）证明有可能制造出一种在量子物理学定律下运行的计算机。</p>
<h2 id="量子计算有什么特别之处">量子计算有什么特别之处？</h2>
<p>由于量子位可以在状态之间切换（可以是“ 1”，“ 0”，也可以同时处于多个状态），因此量子位可以并行或同时执行多个计算。量子比特使量子计算机能够如此快速地处理复杂的计算，以至于普通计算机要花费超过5亿年才能破解比特币的加密，而量子计算机则可以在10分钟之内破解它。</p>
<p>“量子计算机中工作的确切物理机制在理论上有些复杂，并且直观上令人难以理解。通常，用量子物理学的多世界维度来解释它，其中计算机不仅在我们的宇宙中而且还在其他宇宙中同时执行计算。” - 安德鲁·齐默曼·琼斯（Andrew Zimmerman Jones）（《傻瓜弦理论》的作者）</p>
<h2 id="量子计算机是如何制造的">量子计算机是如何制造的？</h2>
<p>传统计算机基本上由数百万个管理电子流的微型开关组成。但是，当我们将这些门缩小到亚原子水平时，控制电流是否流过门的能力变得有些奇怪。通过称为量子隧穿的想法，当我们到达亚原子水平时，电子可以随意跳过闸门，从而使机器处理这种流动的能力变得毫无用处。结果，使得量子计算机的制造方式大不相同。</p>
<p>它们在亚原子粒子的奇异而有趣的微观世界中工作，在量子世界中，量子比特会做奇怪的事情，例如同时处于16个状态中的任何一个状态，直到观察到它们塌陷为一个状态为止。结果，与传统计算中使用的“逻辑门”相对，“量子门”经历了一个过程，即它设置了一些量子位，应用量子门来“纠缠”它们，操纵可能的概率，并然后测量结果。看到这里感到困惑？是的，这是一个真正的伤脑筋的场景。</p>
<p>但是，你需要了解的是，为了能够控制此过程，例如Google正在使用一种特殊的超导金属，该金属的工作温度比空间低八倍，与现在摆在桌上的计算机相去甚远。所以结论就是，量子计算机不太可能很快走出实验室面向大众。</p>
<h2 id="我们应该担心吗">我们应该担心吗？</h2>
<p>根据以太坊创始人Vitalik Buterin和加密传教士Andreas Antonopolous的这些聪明人的说法，目前还没有必要对量子计算机感到恐慌。据Antonopolous称，量子计算机目前还远没有强大到足以破坏比特币之类的东西。</p>
<p>从理论上讲，量子计算可能会破坏加密技术，但换个角度想可能也在保护像比特币和以太坊这样的加密资产，Vitalik认为，像Google宣布的那样，量子计算机的概念尚没有完全实现并被证明。当前在区块链中使用的加密技术也可能是足够强大的，甚至可以抵抗完全实现的量子计算机，这意味着并非所有的加密技术都容易受到攻击。</p>
<p>换言之，量子计算机不仅可以用来破解密码，而且还可以帮助构建更强大的量子加密。为比特币以太坊等区块链抵制量子计算机制定了升级计划。</p>
<h2 id="未来发展">未来发展</h2>
<p>即使我们现在很安全，加密货币世界也已经有人开始未雨绸缪了。Praxxis和QAN等抗量子区块链已经在开发中，以准备对抗潜在的量子危机。我们可以放心地知道，即使量子计算机开始占领世界，我们的加密货币也将是安全的。</p>
]]></content>
    </entry>
</feed>