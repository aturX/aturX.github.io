<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aturx.github.io/</id>
    <title>链 求 君</title>
    <updated>2020-05-09T09:43:00.271Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aturx.github.io/"/>
    <link rel="self" href="https://aturx.github.io/atom.xml"/>
    <subtitle>AturX  的个人网站</subtitle>
    <logo>https://aturx.github.io/images/avatar.png</logo>
    <icon>https://aturx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 链 求 君</rights>
    <entry>
        <title type="html"><![CDATA[Python 字符串与编码]]></title>
        <id>https://aturx.github.io/post/python-zi-fu-chuan-yu-bian-ma</id>
        <link href="https://aturx.github.io/post/python-zi-fu-chuan-yu-bian-ma">
        </link>
        <updated>2020-05-09T09:42:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="比特bit">比特（bit）</h1>
<p>计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理，bit是计算机的最小单位。</p>
<h1 id="字节byte">字节（byte）</h1>
<p>最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），一个字节能表示的最大的整数就是255（二进制11111111=十进制255）</p>
<h1 id="ascii-编码">ASCII 编码</h1>
<p>计算机最早发明，通用语言是英语，所以采用127个字符，表示大小写英文字母、数字和一些符号就足够了。这个编码表，就是<code>ASCII</code>编码，比如<code>A</code> 编码是<code>65</code>.<br>
用一个字节（<code>0~255</code>）就能够表示。</p>
<p>但是，对于其国家他语言来说，光常用的中文汉字就几千个，还有其他韩语、日语等等，一个字节（<code>0~255</code>）陷入是不够的，至少两个字节（<code>0~65535</code>），还不能和<code>ASCII</code>编码冲突，中国制定自己的<code>GB2312</code>编码,日文<code>Shift_JIS</code>,韩文<code>Euc-k</code>,各国各自的标准自然会出现冲突，所以多语言混合的内容中，经常会看到乱码出现。</p>
<p>为了解决这个问题，出现了Unicode（万国码）编码。</p>
<h1 id="unicode-编码">Unicode 编码</h1>
<p>Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。现代操作系统和大多数编程语言都直接支持Unicode。最常用的是用两个字节（<code>0~65535</code>）表示一个字符（如果要用到非常偏僻的字符，就需要4个字节(<code>0~4294967295</code>)）</p>
<p>乱码问题解决了，但是新的问题是，如果统一采用<code>Unicode</code>编码，存储将会是<code>ASCII</code>编码的至少两倍。</p>
<p>本着节约的精神，又出现了把<code>Unicode</code>编码转化为“可变长编码”的<code>UTF-8</code>编码。</p>
<h1 id="utf-8-编码">UTF-8 编码</h1>
<p>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。</p>
<p>实际使用时，根据场景决定使用Unicode 还是 UTF-8，计算机内存中，统一使用Unicode编码（统一编码），当需要保存到硬盘或者需要传输的时候（节约空间），就转换为UTF-8编码。</p>
<h1 id="python-字符串">Python 字符串</h1>
<p>在Python 3版本中，把'xxx'和u'xxx'统一成Unicode编码，即写不写前缀u都是一样的。</p>
<p>在Python 3版本中，所有的字符串都是使用Unicode编码的字符串序列。</p>
<p>Python 3最重要的新特性之一是对字符串和二进制数据流做了明确的区分。文本总是 Unicode，由 str 类型表示，二进制数据则由 bytes 类型表示。</p>
<p>Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p>
<p>Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p>
<pre><code>str 转换成 bytes：

&gt;&gt;&gt; 'ABC'.encode('ascii')
b'ABC'     # 3个字节
&gt;&gt;&gt; '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'  # 6个字节


# 1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。


bytes 转换成 str：

&gt;&gt;&gt; b'ABC'.decode('ascii')
'ABC'
&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文

#  在bytes中，无法显示为ASCII字符的字节，用\x##显示 （\x## 是一个字节）

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小的Flask Web应用]]></title>
        <id>https://aturx.github.io/post/zui-xiao-de-flask-web-ying-yong</id>
        <link href="https://aturx.github.io/post/zui-xiao-de-flask-web-ying-yong">
        </link>
        <updated>2020-05-09T07:09:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装-flask">安装 Flask</h1>
<pre><code>pip3 install flask

或者

pipenv install flask

或者 [PyPI 网站](https://pypi.org/project/Flask/#files)下载源码包安装：

pip3 install Flask-1.1.2-py2.py3-none-any.whl 
</code></pre>
<h1 id="编写代码">编写代码</h1>
<pre><code>from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!'

# 运行
app.run()
</code></pre>
<p>一些常用的配置：</p>
<ol>
<li>端口设定</li>
</ol>
<pre><code>app.run(port=&quot;5001&quot;)
</code></pre>
<ol start="2">
<li>Debug 模式开启</li>
</ol>
<pre><code>app.run(port=&quot;5001&quot;, debug=True)
</code></pre>
<ol start="3">
<li>静态资源路径配置</li>
</ol>
<pre><code># 默认不设置则为当前路径下 template 和 static
app = Flask(__name__,template_folder=&quot;F:\\templates&quot;, static_folder=&quot;F:\\static&quot;)


</code></pre>
<ol start="4">
<li>所有IP可以访问(否则只能本机访问)</li>
</ol>
<pre><code>app.run(port=&quot;5001&quot;, debug=True, host=&quot;0.0.0.0&quot;)
</code></pre>
<h1 id="参考内容">参考内容</h1>
<p><a href="http://docs.jinkan.org/docs/flask/">Flask文档</a></p>
<p><a href="https://www.w3cschool.cn/flask/flask_deployment.html">Flask教程</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Works Show - 作品集]]></title>
        <id>https://aturx.github.io/post/works-show-zuo-pin-ji-ye-mian</id>
        <link href="https://aturx.github.io/post/works-show-zuo-pin-ji-ye-mian">
        </link>
        <updated>2020-05-08T02:57:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="️-预览">❤️ 预览</h1>
<p>😎<a href="https://susuwataricoder.github.io/">在线地址</a></p>
<hr>
<h1 id="项目功能">✅ 项目功能</h1>
<p>完成一个作品集页面，一些练习代码，功能页面的展示。<br>
该页面是完成了FreeCodeCamp 中的一个项目练习。</p>
<hr>
<h1 id="️-使用技术">♻️ 使用技术</h1>
<p>HTML / CSS</p>
<p>部署在GitHub上的静态页面</p>
<hr>
<h1 id="参考资料">➿  参考资料</h1>
<p><a href="https://learn.freecodecamp.one/">FreeCodeCamp</a></p>
<p><a href="https://github.com/SusuwatariCoder">参考仓库</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python的多进程使用]]></title>
        <id>https://aturx.github.io/post/python-de-duo-jin-cheng-shi-yong</id>
        <link href="https://aturx.github.io/post/python-de-duo-jin-cheng-shi-yong">
        </link>
        <updated>2020-04-23T07:39:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="multiprocessing-模块">multiprocessing 模块</h1>
<p>multiprocessing模块就是跨平台版本的多进程模块</p>
<p>multiprocessing模块提供了一个Process类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>
<pre><code>import hashlib
from time import sleep

# TODO  多进程
from multiprocessing import Process
import os
# 演示函数 1 ： 工作量证明
def proof_fo_work():
	&quot;&quot;&quot;
	简单的工作量证明:
         - 查找一个 p' 使得 hash(pp') 以4个0开头
         - p 是上一个块的证明,  p' 是当前的证明
        :param last_proof: &lt;int&gt;
        :return: &lt;int&gt;
	:return:
	&quot;&quot;&quot;
	originHash = hashlib.sha256(&quot;lsy&quot;.encode()).hexdigest()
	print(&quot;Origin Hash：&quot;, originHash)
	proof = 0
	hard = &quot;0&quot;
	while True:
		guessStr = f&quot;{originHash}{proof}&quot;.encode()
		guessHash = hashlib.sha256(guessStr).hexdigest()
		if guessHash[:1] == hard:
			print(&quot;***符合要求***: &quot;, guessHash)
			print(&quot;***Proof***: &quot;, proof)
			sleep(6)
			hard = hard + &quot;0&quot;
		else:
			print(guessHash)
			proof = proof + 1

# 演示函数 2 ： 打印
def t(name):
	print(f&quot;子进程： {name}, {os.getpid()}&quot;)

# 进程的使用： 启动进程分别执行 函数1,2
def use_process():
	print(f&quot;主进程: {os.getpid()}&quot;)
	# 创建test进程
	p = Process(target=t, args=('testProcess',))
	# 创建proof_fo_work 进程
	p2 = Process(target=proof_fo_work)
	p2.start()
	#p2.join()   # 使用之后，p进程将等待p2结束才执行
	print(&quot;启动测试进程&quot;)
	p.start()


</code></pre>
<p>其中 <code>p.join()</code> 表示进程结束后，才会继续执行后续过程。如果该经常死循环了，那么后面的执行步骤将永远不会执行。</p>
<h2 id="创建多个进程-进程池-pool">创建多个进程： 进程池 Pool</h2>
<p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<pre><code>def t(name):
	sleep(1)
	print(f&quot;子进程： {name}, {os.getpid()}&quot;)
	
# 进程池的使用
def pool_process():
	from multiprocessing import Pool
	#如果要启动大量的子进程，可以用进程池的方式批量创建子进程：
	p = Pool(4)  # 4为 CPU 核心数， 四核CPU 最多执行4 ， 大于4 也只执行4个进程
	for i in range(5):
		p.apply_async(t, args=(i,))
	print(&quot;完成全部进程的创建启动&quot;)
	p.close()
	p.join()
</code></pre>
<h2 id="进程通信-生产者消费者queue">进程通信： 生产者+消费者+Queue</h2>
<pre><code># 进程的通信： 多线程 生成者+消费者 Queue 实现
def message_process():
	from multiprocessing import Queue

	q = Queue()

	pw = Process(target=producer, args=(q,))   # 生产进程
	pr = Process(target=consumer, args=(q, &quot;P1&quot;))   # 消费进程 1
	pr2 = Process(target=consumer, args=(q, &quot;P2&quot;))  # 消费进程 2
	pr3 = Process(target=consumer, args=(q, &quot;P3&quot;))  # 消费进程 3
	pr4 = Process(target=consumer, args=(q, &quot;P4&quot;))  # 消费进程 4
	pr5 = Process(target=consumer, args=(q, &quot;P5&quot;))  # 消费进程 5

	pw.start()
	pr.start()
	pr2.start()
	pr3.start()
	pr4.start()
	pr5.start()

	# 等待pw结束:
	pw.join()
	# 队列消费完成 结束进程
	while True:
		if q.qsize() == 0:
			# pr,pr2进程里是死循环，无法等待其结束，只能强行终止:
			pr.terminate()
			pr2.terminate()
			pr3.terminate()
			pr4.terminate()
			pr5.terminate()
			print(&quot;队列数据： &quot;, q.qsize())
			break

 
# 往队列里生产数据
def producer(q):
	import random, time
	print('Hash生成进程: %s' % os.getpid())
	# 生产 100个
	for i in range(100):
		num = random.randint(0, 1000)
		value_hash = hashlib.sha256(str(num).encode()).hexdigest()
		print('生成地址：[ %s ] to queue...' % value_hash)
		q.put(value_hash)  # 数据写入队列


# 消费队列里的数据
def consumer(q,name):
	import random, time
	print('获取地址消费: %s ' % os.getpid())
	while True:
		value = q.get(True)
		print(f'**{name}-读取地址: [ {value} ] from queue.')
		time.sleep(random.random())

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker实践01 -- 图形管理工具Portainer的使用]]></title>
        <id>https://aturx.github.io/post/docker-shi-jian-01-tu-xing-guan-li-gong-ju-portainer-de-shi-yong</id>
        <link href="https://aturx.github.io/post/docker-shi-jian-01-tu-xing-guan-li-gong-ju-portainer-de-shi-yong">
        </link>
        <updated>2020-03-06T08:52:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-解决问题">一、 解决问题？</h1>
<p>Docker 在使用过程中，要在命令行中查看各种信息，非常的不方便，而且管理的效率不高，采用Portainer用来管理Docker和运行的项目足够了。</p>
<h1 id="二-安装并运行-portainer">二、安装并运行 Portainer</h1>
<p>Portainer 不用特意去安装，直接用Docker一行命令去运行就可以了。</p>
<h2 id="dockerhub">DockerHub</h2>
<p><a href="https://hub.docker.com/r/portainer/portainer">DockerHub</a> 上有很多镜像包可以直接使用，也包括Portainer的镜像。</p>
<p>执行命令，先把镜像获取到本地：</p>
<pre><code>docker pull portainer/portainer
</code></pre>
<p>运行 Portainer：</p>
<pre><code>
$ docker volume create portainer_data

//创建一个portainer_data文件夹存储你容器的相关数据
//一般它的地址是在： /var/lib/docker/volumes

$ docker run -d -p 9000:9000 -p 8000:8000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer


//其他参数暂时不用修改，就按照官方命令进行启动就可以了

</code></pre>
<h1 id="三-在线演示">三、在线演示</h1>
<p>你可以在线查看效果</p>
<p>访问地址:  http://demo.portainer.io/</p>
<p>用户名：<code>admin</code><br>
密码  ：<code>tryportainer</code></p>
<h1 id="参考">参考</h1>
<p><a href="https://portainer.readthedocs.io/en/latest/deployment.html">更多部署信息</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网站流量统计功能添加]]></title>
        <id>https://aturx.github.io/post/wang-zhan-liu-liang-tong-ji-gong-neng-tian-jia</id>
        <link href="https://aturx.github.io/post/wang-zhan-liu-liang-tong-ji-gong-neng-tian-jia">
        </link>
        <updated>2020-03-04T06:26:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-站长统计的选择">😁一、站长统计的选择</h1>
<p>想要查看网站的访问量，可以给网站进行网站统计。先对网站统计的工具选择：因为网站是国内访问，选择百度统计比较合适。</p>
<p>访问地址：<a href="https://tongji.baidu.com">百度流量统计</a></p>
<p>还有另一个，网站直接统计的js脚本也可以使用，需要添加到网页中，好处是可以显示用户访问量在页面。</p>
<p>访问地址： <a href="https://busuanzi.ibruce.info/">不蒜子访问量展示</a></p>
<h1 id="二-添加网站统计">😁二、添加网站统计</h1>
<h2 id="百度统计方式">百度统计方式</h2>
<p>基本过程是：</p>
<ol>
<li>
<p>首页注册登录</p>
</li>
<li>
<p>添加自己的网站域名</p>
</li>
<li>
<p>复制生成好的js代码片段</p>
</li>
<li>
<p>将代码添加到自己的网站页面中</p>
</li>
<li>
<p>20分钟后可查看页面的流量统计</p>
</li>
</ol>
<p>web4web.top 统计代码添加 :</p>
<pre><code>&lt;script&gt;
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement(&quot;script&quot;);
  hm.src = &quot;https://hm.baidu.com/hm.js?13ea7e585ad4fa34100390e5a6862c52&quot;;
  var s = document.getElementsByTagName(&quot;script&quot;)[0]; 
  s.parentNode.insertBefore(hm, s);
})();
&lt;/script&gt;

</code></pre>
<p>lisiyi.top 统计代码添加 ：</p>
<pre><code>&lt;script&gt;
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement(&quot;script&quot;);
  hm.src = &quot;https://hm.baidu.com/hm.js?5f536360cba2bd2691929ab1dfc08c55&quot;;
  var s = document.getElementsByTagName(&quot;script&quot;)[0]; 
  s.parentNode.insertBefore(hm, s);
})();
&lt;/script&gt;
</code></pre>
<h2 id="不蒜子方式">不蒜子方式</h2>
<p>参考：<br>
<a href="https://liam.page/2017/04/29/busuanzi-offset-setting/">数值初始化</a></p>
<p>不蒜子 参考代码片段：</p>
<pre><code>  &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;
&lt;span id=&quot;busuanzi_container_site_uv&quot; style='display:none'&gt;
本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt;| 
    Powered by &lt;a href=&quot;https://github.com/aturX&quot; target=&quot;_blank&quot;&gt;AturX&lt;/a&gt; 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Maven 的基础知识]]></title>
        <id>https://aturx.github.io/post/maven-de-ji-chu-zhi-shi</id>
        <link href="https://aturx.github.io/post/maven-de-ji-chu-zhi-shi">
        </link>
        <updated>2020-03-04T04:54:47.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="maven-基-本-操-作">🐶 Maven 基 本 操 作</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="maven-基-本-操-作">🐶 Maven 基 本 操 作</h1>
<!-- more -->
<h2 id="构建">构建</h2>
<p>要构建一个基于Maven的项目，打开控制台，进入到 pom.xml 文件所放的项目文件夹，并发出以下命令：</p>
<pre><code>mvn package
</code></pre>
<!-- more -->
<h2 id="清除">清除</h2>
<p>在基于Maven的项目中，很多缓存输出在“target”文件夹中。如果想建立项目部署，必须确保清理所有缓存的输出，从面能够随时获得最新的部署。</p>
<pre><code>mvn clean
</code></pre>
<p>要部署您的项目进行生产，它总是建议使用 “mvn clean package“, 以确保始终获得最新的部署。</p>
<!-- more -->
<h2 id="单元测试">单元测试</h2>
<p>要通过Maven运行单元测试，发出此命令：</p>
<pre><code>mvn test
</code></pre>
<p>这会在你的项目中运行整个单元测试。</p>
<!-- more -->
<h2 id="安装">安装</h2>
<p>在Maven中，可以使用“mvn install”打包项目，并自动部署到本地资源库，让其他开发人员使用它。</p>
<pre><code>mvn install
</code></pre>
<p>注意，<br>
当“install”在执行阶段，上述所有阶段 “validate“, “compile“, “test“, “package“, “integration-test“, “verify” 阶段, 包括目前的“install”阶段将被执行有序。</p>
<!-- more -->
<h1 id="maven-的-pom-文-件">🦊 Maven 的 POM 文 件</h1>
<h3 id="maven-项目唯一标识标签">Maven - 项目唯一标识标签：</h3>
<ul>
<li>
<p>groupId：项目或者组织的唯一标志 ，如cn.gov.customs生成的相对路径为：/cn/gov/customs</p>
</li>
<li>
<p>artifactId：项目的通用名称</p>
</li>
<li>
<p>version：项目的版本</p>
</li>
<li>
<p>packaging：打包机制，如pom,jar,maven-plugin,ejb,war,ear,rar,par</p>
</li>
<li>
<p>name：用户描述项目的名称，无关紧要的东西，非必要</p>
</li>
<li>
<p>url：开发团队官方地址 ，非必要</p>
</li>
<li>
<p>classifer：分类</p>
</li>
</ul>
<p><code>groupId,artifactId,version,packaging</code>作为项目唯一标识</p>
<p>例子：</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
   
   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
   // 1. groupId 这是项目组的编号，这在组织或项目中通常是独一无二的。
   // 例如:com.company.bank 某公司银行相关项目

   &lt;groupId&gt;com.baidu.project-group&lt;/groupId&gt;
   
   // 2.项目ID。这通常是项目的名称。例如，springboot-demo。 
   &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt;
   
   // 3. 版本号与groupId 结合使用
   &lt;version&gt;1.0&lt;/version&gt;
   // 4. 打包类型 
   &lt;packaging&gt;jar&lt;/packaging&gt;
   
   &lt;name&gt;springboot-demo&lt;/name&gt;
&lt;project&gt; 

</code></pre>
<!-- more -->
<h3 id="maven-依赖关系">Maven - 依赖关系：</h3>
<p>POM文件中的关系，主要有依赖，继承，合成等关系。</p>
<ul>
<li>
<p>scope：用来指定当前包的依赖范围</p>
</li>
<li>
<p>optional：设置指依赖是否可选，默认为false,即子项目默认都继承，为true,则子项目必需显示的引入，与dependencyManagement里定义的依赖类似</p>
</li>
<li>
<p>exclusions：如果X需要A,A包含B依赖，那么X可以声明不要B依赖，只要在exclusions中声明exclusion</p>
</li>
<li>
<p>parent：如果一个工程作为父类工程，那就必须添加pom,子系统要继承父类，也必须使用parent标签。对于子系统使用如下所示：</p>
</li>
<li>
<p>relativePath：为可选项，maven会首先搜索该地址，然后再搜索远程仓库。</p>
</li>
</ul>
<pre><code>&lt;parent&gt; 
    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; 
    &lt;artifactId&gt;my-parent&lt;/artifactId&gt; 
    &lt;version&gt;2.0&lt;/version&gt; 
    &lt;relativePath&gt;../my-parent&lt;/relativePath&gt; 
&lt;/parent&gt;
</code></pre>
<p>依赖引入：</p>
<pre><code>说明：properties 顾名思义就是配置文件，这里的 peoperties 是管理 jar 包的版本号的， 然后在后面的 dependencies 中 可以以 变量的形式调用 如： 
&lt;properties&gt;
 &lt;!-- 框架版本 --&gt;
	&lt;org.springframework.version&gt;3.2.4.RELEASE&lt;/org.springframework.version&gt;
 &lt;!-- Java版本 --&gt;
   &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
    	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
    	&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    	&lt;version&gt;${org.springframework.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ul>
<li>modules：多模块项目的标签，顺序不重要，MAVEN会自动拓展排序。使用如下所示：</li>
</ul>
<pre><code>&lt;!--子模块--&gt;
&lt;modules&gt;
    &lt;module&gt;ygb-service-config&lt;/module&gt;
    &lt;module&gt;ygb-service-bus&lt;/module&gt;
    &lt;module&gt;ygb-service-policy-center&lt;/module&gt;
    &lt;module&gt;ygb-service-letter-of-indemnity&lt;/module&gt;
    &lt;module&gt;ygb-service-authentication-center&lt;/module&gt;
&lt;/modules&gt;
</code></pre>
<!-- more -->
<h3 id="maven-构建设置">Maven - 构建设置:</h3>
<ul>
<li>build 这部分主要是对项目的构建过程进行配置，包括打包的方式、插件的安装等。配置如下所示：</li>
</ul>
<pre><code>&lt;!-- 构建管理 --&gt;
&lt;build&gt;
    &lt;!--构建工具插件管理--&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>常用POM 文件：</p>
<pre><code>完整 POM 参考：
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;
  &lt;groupId&gt;cn.seisys.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;kafka-demo&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
	&lt;name&gt;kafka-demo&lt;/name&gt;

  &lt;properties&gt;
   &lt;java.version&gt;1.8&lt;/java.version&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;

	  &lt;dependency&gt;
		  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
	  &lt;/dependency&gt;

	  &lt;dependency&gt;
		  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
		  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
		  &lt;optional&gt;true&lt;/optional&gt;
	  &lt;/dependency&gt;
	  &lt;dependency&gt;
		  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
		  &lt;scope&gt;test&lt;/scope&gt;
	  &lt;/dependency&gt;


	  &lt;dependency&gt;
		  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
		  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
		  &lt;optional&gt;true&lt;/optional&gt;
	  &lt;/dependency&gt;
	  &lt;!--引入第三方jar-Mas jar--&gt;
	  &lt;dependency&gt;
		  &lt;groupId&gt;org.apache.kafka.clients&lt;/groupId&gt;
		  &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
		  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
		  &lt;scope&gt;system&lt;/scope&gt;
		  &lt;systemPath&gt;${project.basedir}/src/main/resources/lib/kafka-clients-0.11.0.1.jar&lt;/systemPath&gt;
	  &lt;/dependency&gt;

	  &lt;dependency&gt;
		  &lt;groupId&gt;org.apache.kafka.clients&lt;/groupId&gt;
		  &lt;artifactId&gt;kafka&lt;/artifactId&gt;
		  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
		  &lt;scope&gt;system&lt;/scope&gt;
		  &lt;systemPath&gt;${project.basedir}/src/main/resources/lib/kafka_2.11-0.11.0.1.jar&lt;/systemPath&gt;
	  &lt;/dependency&gt;

	  &lt;!-- https://mvnrepository.com/artifact/commons-net/commons-net --&gt;
	  &lt;dependency&gt;
		  &lt;groupId&gt;commons-net&lt;/groupId&gt;
		  &lt;artifactId&gt;commons-net&lt;/artifactId&gt;
		  &lt;version&gt;3.6&lt;/version&gt;
	  &lt;/dependency&gt;
	  &lt;dependency&gt;
		  &lt;groupId&gt;commons-io&lt;/groupId&gt;
		  &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
		  &lt;version&gt;1.3.1&lt;/version&gt;
	  &lt;/dependency&gt;
	  &lt;dependency&gt;
		  &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
		  &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
		  &lt;version&gt;4.5.7&lt;/version&gt;
	  &lt;/dependency&gt;
	  &lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;
	  &lt;dependency&gt;
		  &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
		  &lt;artifactId&gt;gson&lt;/artifactId&gt;
		  &lt;version&gt;2.8.5&lt;/version&gt;
	  &lt;/dependency&gt;


	  &lt;dependency&gt;
		  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
		  &lt;artifactId&gt;druid&lt;/artifactId&gt;
		  &lt;version&gt;1.0.10&lt;/version&gt;
	  &lt;/dependency&gt;

	  &lt;dependency&gt;
		  &lt;groupId&gt;com.oracle&lt;/groupId&gt;
		  &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;
		  &lt;version&gt;11.2.0&lt;/version&gt;
	  &lt;/dependency&gt;

	  &lt;dependency&gt;
		  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
		  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
		  &lt;version&gt;2.0.0&lt;/version&gt;
	  &lt;/dependency&gt;

  &lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
				&lt;configuration&gt;
					&lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;


&lt;/project&gt;

</code></pre>
<!-- more -->
<h1 id="参-考-资-料">🐼 参 考 资 料</h1>
<p><a href="https://www.yiibai.com/maven">Maven教程</a></p>
<p><a href="https://www.jianshu.com/p/242f2349eef1">POM配置标签</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区块链周刊 - 第 2 期]]></title>
        <id>https://aturx.github.io/post/qu-kuai-lian-zhou-kan-di-2-qi</id>
        <link href="https://aturx.github.io/post/qu-kuai-lian-zhou-kan-di-2-qi">
        </link>
        <updated>2020-03-01T02:03:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是加密货币">😎 什么是加密货币？</h1>
<p>加密货币是一种通过加密技术保护的数字或虚拟货币，几乎不可能伪造或重复消费。许多加密货币基于区块链技术的分布式网络-即由不同的计算机网络构成的分布式账本。加密货币的特征是它们通常不是由任何中央机构发行的，因此从理论上讲其不受政府干预或操纵。</p>
<pre><code>重要要点:

1. 加密货币是一种基于网络的新型数字资产，该网络分布在大量计算机上。

2. 这种分散的结构使它们能够存在于政府和中央政府的控制之外。

3. “加密货币”一词源自用于保护网络的加密技术。
区块链是确保交易数据完整性的方法，是许多加密货币的重要组成部分。
</code></pre>
<p><strong>许多专家认为，区块链及相关技术将重塑许多行业，包括金融和法律。</strong></p>
<p>加密货币由于多种原因而受到批评，包括其用于非法活动，汇率波动以及其基础设施的脆弱性。但是，它们的便携性，可分割性，抗通胀性和透明性也受到赞誉。</p>
<h2 id="了解加密货币">了解加密货币</h2>
<p>加密货币是允许以虚拟“令牌（Token）”命名的在线安全支付的系统，虚拟“令牌（Token）”由系统内部的分类帐条目表示。“加密”是指保护这些条目的各种加密算法和加密技术，例如椭圆曲线加密，公私钥对和哈希函数。</p>
<h2 id="加密货币的类型">加密货币的类型</h2>
<p>第一个基于区块链的加密货币是比特币，它仍然是最受欢迎和最有价值的。如今，有成千上万种具有各种功能和规格的备用加密货币。其中一些是比特币的克隆或分叉，而另一些则是从头开始构建的新货币。</p>
<p>比特币由化名“中本聪”的个人或组织于2009年推出。截至2019年11月，流通中的比特币超过1800万枚，总市值约为1,460亿美元。</p>
<p>比特币的成功催生了一些竞争性的加密货币，称为“山寨币”，包括Litecoin，Peercoin和Namecoin以及以太坊，Cardano和EOS。如今，现有所有加密货币的总价值约为2140亿美元，比特币目前占总价值的68％以上。</p>
<p>今天，加密货币中使用的某些加密技术最初是为军事应用开发的。一方面，政府希望对密码术进行控制，类似像武器一样进行法律限制，但是出于言论自由的目的，最终确保了平民使用密码术的权利。</p>
<h2 id="特别注意事项">特别注意事项</h2>
<p>比特币和其他加密货币独具吸引力的核心功能是区块链技术，该技术用于保持曾经进行过的所有交易的安全不可篡改性，从而为该账本提供了一个非常安全的数据结构，并且可以通过共享并达成共识。由单个节点广播至整个网络。生成的每个新块都必须在确认之前被每个节点进行验证，这几乎不可能伪造交易历史记录。</p>
<p>许多专家认为，区块链技术在<strong>在线投票</strong>和<strong>众筹</strong>等应用中具有巨大潜力，而摩根大通（JPM）等主要金融机构则认为，其拥有通过<strong>简化付款流程来降低交易成本的潜力</strong>。 但是，由于加密货币是虚拟的并且没有存储在中央数据库中，因此，如果私钥没有备份副本，并且存储私钥的硬盘丢失或破坏，则所有的数字加密货币将丢失。但是，这样也保证了没有中央机构，政府或公司可以访问您的资金或个人信息。</p>
<h2 id="加密货币的优缺点">加密货币的优缺点</h2>
<h3 id="优点">优点</h3>
<p>加密货币有望使交易双方转移资金变得更加容易，而无需像银行或信用卡公司这样的受信任的第三方。相反，这些转移是通过使用公钥和私钥以及不同形式的激励系统（例如工作量证明或权益证明）来确保的。</p>
<p>在现代的加密货币系统中，用户的“钱包”或帐户地址具有公共密钥，而私钥仅是所有者已知的，并用于签署交易。资金转帐以最低的手续费完成，使用户可以避免银行和金融机构为电汇收取的高额费用。</p>
<h3 id="缺点">缺点</h3>
<p>加密货币交易的半匿名性质使其非常适合于许多非法活动，例如洗钱和逃税。但是，加密货币的倡导者经常高度重视其匿名性，理由是隐私的好处，例如保护生活在压制政府下的举报者或激进主义者。一些加密货币比其他加密货币更具私密性。</p>
<p>例如，由于对比特币区块链进行分析有助于当局逮捕和起诉罪犯，因此，比特币在网上开展非法业务是相对较差的选择。但是，确实存在更多面向隐私的硬币，例如Dash，Monero或ZCash，它们很难追踪。</p>
<h2 id="对加密货币的批评">对加密货币的批评</h2>
<p>由于加密货币的市场价格基于供求关系，因此加密货币可兑换为另一种货币的汇率可能会大幅波动，因为许多加密货币的设计可确保高度的稀缺性。</p>
<p>比特币经历了一些快速的飙升和价值崩溃，在2017年12月攀升至每比特币19,000美元，随后在接下来的几个月中跌至7,000美元左右。 因此，一些经济学家认为加密货币是昙花一现或投机泡沫。</p>
<p>加密货币区块链是高度安全的，但是加密货币生态系统的其他方面，包括交易所和钱包，是无法幸免于黑客攻击的。在比特币发展的10年历史中，数个在线交易所一直是黑客和盗窃的重点对象，有时会盗窃价值数百万美元的“硬币”。</p>
<p>尽管如此，许多观察家仍认为加密货币具有潜在的优势，例如可以保持价值抵御通货膨胀并促进交换，同时比贵金属更容易运输和分割，并且不受中央银行和政府的影响而存在。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linker 第 8 期  -  自由职业与数字货币]]></title>
        <id>https://aturx.github.io/post/linker-di-8-qi-zi-you-zhi-ye-yu-shu-zi-huo-bi</id>
        <link href="https://aturx.github.io/post/linker-di-8-qi-zi-you-zhi-ye-yu-shu-zi-huo-bi">
        </link>
        <updated>2020-02-22T03:15:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="国外网站">国外网站</h2>
<blockquote>
<p><a href="https://gitcoin.co/">Gitcoin</a><br>
通过GitHub登录，并完成开发任务，修复bug，完成开发需求，软件测试，代码review等都可以获取代币&gt;激励。我认为GitHub和数字货币结合有着天然的优势。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://nomadlist.com/">全球数字游民</a><br>
数字游民，有电脑，有网。世界哪里都是家。这里有更详细的信息，包括每个地方，舒适度，环境是否适宜&gt;办公，网络状态是否良好。或许还能相个亲。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://remoteok.io/remote-dev-jobs">远程OK</a><br>
一个提供远程办公的网站，有比较多远程办公需求提供。</p>
</blockquote>
<hr>
<h2 id="代币经济下的自由职业">代币经济下的自由职业</h2>
<blockquote>
<p>*<a href="https://freelanceforcoins.com">数字货币自由职业平台-FreelanceForCoins</a></p>
<p>*<a href="https://ethlance.com">以太坊自由职业平台-Ethlance</a></p>
<p>*<a href="https://www.cryptogrind.com/">比特币自由职业平台-CryptoGrind</a></p>
<p>*<a href="https://blocklancer.net/">区块链自由职业平台-Blocklancer</a></p>
<p>*<a href="https://www.cryptotask.org/">区块链任务接单平台-cryptotask</a></p>
</blockquote>
<p>以上五个网站，均通过数字货币进行结算。我只是抱着探索的态度，去尝试了一些。我个人认为，远程创作者 + 区块链代币激励 将会成为很好的一种模式促进自由职业与远程办公的发展。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区块链周刊 - 第 1 期]]></title>
        <id>https://aturx.github.io/post/qu-kuai-lian-zhou-kan-di-1-qi</id>
        <link href="https://aturx.github.io/post/qu-kuai-lian-zhou-kan-di-1-qi">
        </link>
        <updated>2020-02-15T09:06:47.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="defi去中心化金融是什么">😀 DeFi（去中心化金融）是什么？</h2>
<p>DeFi的愿景是一切资产都可以Token化，自由地在全球开放的市场上交易。</p>
<p>加密货币的承诺是使货币和支付变得普遍，任何人不管他们在世界上的任何地方。</p>
<p>去中心化金融（DeFi）或开放式金融运动使这一愿景更进一步。 想象一下，有一种全球性、开放的服务可以替代你目前使用的所有金融服务--储蓄、贷款、交易、保险等等--全世界只要有智能手机和互联网连接，任何人都可以使用。</p>
<p>这在智能合约区块链上是可能的，比如 Ethereum。</p>
<p>“智能合约”是运行在区块链上的程序，可以在满足某些条件时自动执行。 这些智能合约使开发人员能够构建比简单地发送和接收加密货币更复杂的功能。 这些程序就是我们现在所说的分散式应用，或者 dapps。</p>
<p>你可以认为Dapp是一个建立在分布式技术上的应用，而不是由一个单一的、集中的实体或由公司来建立和控制的。</p>
<p>尽管其中一些概念听起来可能有些遥不可及——在世界不同地区的两个陌生人之间直接协商自动化的贷款业务，但中间没有银行——许多这样的应用程序如今已经上线。 就是那些 DeFi Dapps。</p>
<p>它们允许你创建稳定账户(加密货币，其价值与美元挂钩)，借出资金并从你的加密账户获得利息，获得贷款，用一种资产交换另一种资产，做多或做空资产，以及实施自动化的高级投资策略。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="defi去中心化金融是什么">😀 DeFi（去中心化金融）是什么？</h2>
<p>DeFi的愿景是一切资产都可以Token化，自由地在全球开放的市场上交易。</p>
<p>加密货币的承诺是使货币和支付变得普遍，任何人不管他们在世界上的任何地方。</p>
<p>去中心化金融（DeFi）或开放式金融运动使这一愿景更进一步。 想象一下，有一种全球性、开放的服务可以替代你目前使用的所有金融服务--储蓄、贷款、交易、保险等等--全世界只要有智能手机和互联网连接，任何人都可以使用。</p>
<p>这在智能合约区块链上是可能的，比如 Ethereum。</p>
<p>“智能合约”是运行在区块链上的程序，可以在满足某些条件时自动执行。 这些智能合约使开发人员能够构建比简单地发送和接收加密货币更复杂的功能。 这些程序就是我们现在所说的分散式应用，或者 dapps。</p>
<p>你可以认为Dapp是一个建立在分布式技术上的应用，而不是由一个单一的、集中的实体或由公司来建立和控制的。</p>
<p>尽管其中一些概念听起来可能有些遥不可及——在世界不同地区的两个陌生人之间直接协商自动化的贷款业务，但中间没有银行——许多这样的应用程序如今已经上线。 就是那些 DeFi Dapps。</p>
<p>它们允许你创建稳定账户(加密货币，其价值与美元挂钩)，借出资金并从你的加密账户获得利息，获得贷款，用一种资产交换另一种资产，做多或做空资产，以及实施自动化的高级投资策略。</p>
<!-- more -->
<h2 id="这些defi-dapps与传统银行或华尔街的同行有何不同">😄这些DeFi dapps与传统银行或华尔街的同行有何不同？</h2>
<ul>
<li>
<p>这些企业的核心业务不是由机构及其员工来管理，而是用代码(或上文提到的智能合约)来编写规则。 一旦将智能合约部署到区块链，DeFi dapps 就可以自己运行，几乎不需要人工干预(尽管实际上开发人员经常通过升级或错误修复来维护 dapps)</p>
</li>
<li>
<p>代码是透明的封锁在区块链上，可以受到任何人的审计。这在用户中建立了一种不同的信任，因为任何人都有机会理解合约的功能或发现它的缺陷。 所有交易活动也是公开的，任何人都可以查看。 虽然这可能会引起隐私问题，但交易在默认情况下是假名的，也就是说并不直接与你的真实身份联系在一起。</p>
</li>
<li>
<p>Dapps被设计为从运行的第一天开始—无论你是在美国还是中国，身处何处，都可以访问相同的DeFi服务和网络。当然，需要遵守当地法规，但从技术上来讲，大多数具有互联网连接的人都可以使用大多数DeFi应用。</p>
</li>
<li>
<p>“无需许可”即可参与，任何人都可以创建DeFi应用，任何人都可以使用它们。与当今的金融不同，没有监管机构或冗长的账户。用户直接通过其加密货币钱包与智能合约进行交互。</p>
</li>
<li>
<p>灵活的用户体验。不喜欢特定dapp的界面吗？没问题-您可以使用第三方界面，也可以构建自己的界面。智能合约就像一个开放的API，任何人都可以为其构建应用程序。</p>
</li>
<li>
<p>互向关联。新DeFi应用程序可以建立或由其他DeFi产品组合而成，如堆积木块-例如stablecoins，去中心社交，与市场预测可以结合起来，形成全新的产品。</p>
</li>
</ul>
<p>Defi 现在是密码领域增长最快的部分之一。 业内观察人士用一种独特的新指标——“ ETH locked in DeFi”来衡量吸引力。 目前，用户已经在这些智能合同中存入了价值超过6亿美元的加密货币。</p>
<p>好奇吗？ 让我们来仔细看看几个流行的 DeFi dapps，你今天就可以尝试一下。 你需要一个内置 dapp 浏览器的加密货币钱包(比如 Coinbase Wallet)来连接这些 dapps。</p>
<p>现在Dapps 尚在发展初期，所以DeFi 用户应该对新产品和新服务进行研究。 像任何计算机代码一样，智能合约可能会出现意想不到的编程错误和恶意攻击的攻击。</p>
<!-- more -->
<h2 id="去中心化银行-makerdao">😁去中心化银行: MakerDAO</h2>
<p>Maker 是一个稳定收益项目，其中每个稳定收益(DAI)与美元挂钩，并以加密形式的抵押品作为担保。 Stablecoin 提供了加密的可编程性，币值稳定，你能够看到“传统”加密货币比如比特币或以太币。</p>
<p>你可以尝试在 Maker Oasis dapp （绿洲） 上创建自己的 DAI 稳定代码。 Maker不仅仅是一个稳定的投资项目，它还渴望成为一家去中心的储备银行。 持有独立但相关的象征性货币 MKR 的人，可以对稳定费(Stability Fee)等重要决定进行投票(类似于美联储(Federal Reserve)的联邦公开市场委员会(Federal Open Market Committee)对联邦基金利率进行投票的方式)。</p>
<p>另一个具有不同体系结构的稳定币是 USD Coin (USDC) ，其中每个 USDC 令牌都由经审计的银行账户中所持有美元1:1锚定。</p>
<!-- more -->
<h2 id="借与贷-compound">😆借与贷: Compound</h2>
<p>Compound 是一种基于区块链的借贷 dapp-你可以借出你的数字货币并从中获得利息。 或者你可能需要一些钱来支付房租或者购买食品杂货，但是你的资金却被你的加密投资占用了？ 您可以将您的加密货币存入智能合约作为抵押品，并以此作为借款凭证。 复合合同自动匹配借款人和贷款人，并根据供给和需求动态调整利率。</p>
<p>其他流行的借/贷应用还有Dharma 和 dYdX。 LoanScan可以跟踪各种 dapps 的借贷利率，这样你就可以货比三家找到最好的利率。</p>
<!-- more -->
<h2 id="自动代币交换-uniswap">🤣自动代币交换: Uniswap</h2>
<p>Uniswap 是一个完全基于智能合约运行的加密货币交换服务，让你直接从钱包交易受欢迎的代币。 这与 Coinbase 这样的交易所不同，Coinbase 为你存储加密货币，并保存您的私钥以便妥善保管。 Uniswap使用了一种被称为自动做市的创新机制来自动结算接近市场价格的交易。<br>
其他流行的去中心的交换平台包括0x、 AirSwap、 Bancor、 Kyber、 IDEX、 Paradex 和 Radar Relay。 它们的体系结构都略有不同。</p>
<!-- more -->
<h2 id="预测市场-augur">😌预测市场: Augur</h2>
<p>Augur是一个去中心的预测市场协议。 使用 Augur，你可以对事件的结果进行投票。 像 Augur 和 Guesser 这样的预测市场平台还处于起步阶段，但是它们提供了一个展望未来的视角，用户可以利用大众的智慧做出更好的预测。</p>
<!-- more -->
<h2 id="组合资产-synthetix">😙组合资产: Synthetix</h2>
<p>Synthetix是一个平台，用户可以创建和交换黄金、白银、加密货币和欧元等传统货币的组合版本。 这些组合资产由多余的抵押品作为担保，这些抵押品被锁定在 Synthetix 合约中。</p>
<!-- more -->
<h2 id="无损储蓄游戏-pooltogether">😜无损储蓄游戏: PoolTogether</h2>
<p>Defi 的可组合性为无限的新可能性提供了条件。 Pooltogether 是一个无损失的游戏，参与者将 DAI 的固定资产存放在一个共同的罐子里。 每个月末，一个幸运的参与者赢得所有的利息，每个人都能拿回他们的初始存款。</p>
<!-- more -->
<h2 id="那么-defi-的下一步计划是什么呢">😒那么 DeFi 的下一步计划是什么呢？</h2>
<p>自人类文明开始以来，货币和金融就以这样或那样的形式存在着。 加密货币只是最新的数字化身。 在接下来的几年里，我们可能会看到我们在今天的金融系统中使用的每一个金融服务被重建为加密生态系统。 我们已经看到了为加密技术而建立的资产发行和交换、借款、贷款、托管和衍生产品。 下一步是什么？</p>
<p>第一代 DeFi Dapps 严重依赖抵押品作为安全保障。 也就是说，你需要已经拥有加密货币，并提供它作为抵押品，以借用更多的加密货币。 更多传统的无担保借贷将需要依赖于一个身份系统，这样借款人就可以建立信用并增加他们的借贷能力。 然而，与今天的身份和信用系统不同，去中心化的身份必须具有普遍性和隐私保护性。</p>
<p>我们也看到了保险领域的创新。 今天的许多 DeFi 贷款都是过度抵押的(这意味着贷款看起来本质上是安全的，因为它们拥有充足的储备资产)。 但是 DeFi 的黑天鹅是智能合约的漏洞。 如果一个黑客发现并利用 dapp 开源代码中的一个漏洞，数百万美元可能会在一瞬间耗尽。 像 Nexus Mutual 这样的团队正在建立一种分散的保险体系，这种体系将使用户变得安全。</p>
<p>我们看到的另一个趋势是更好的用户体验。 第一代的 dapps 是由区块链爱好者为区块链爱好者建造的。 这些 dapps 在展示令人兴奋的新 DeFi 可能性方面做得很好，但是在可用性方面还有待改进。 最新的 DeFi 应用程序正在优化设计和易用性，以便将开放金融服务推向更广泛的受众。</p>
<p>在未来，我们期待加密钱包将成为你所有数字资产活动的入口，就像今天的互联网浏览器是你获取世界新闻和信息的入口一样。 设想一个仪表板，它不仅显示您拥有哪些资产，还显示您在不同的开放金融协议(贷款、资金池和保险合同)中锁定了多少资产。</p>
<p>在整个 DeFi 生态系统中，我们也看到了向分散治理和决策的转变。 尽管 DeFi 中使用了“去中心化”这个词，但是今天的许多项目都有主密钥供开发人员关闭或禁用 dapps。 这样做是为了方便升级，并在代码出现问题时提供紧急关闭阀。 然而，随着代码变得更具实战性，我们预计开发人员将放弃这些后门开关。 DeFi 社区正在试验允许利益相关者对决策进行投票的方法，包括通过使用基于区块链的分散自治组织(DAOs)。</p>
<p>在开放的金融系统中，一些神奇的事情正在发生--加密技术正在把钱带到网上，我们看到了货币功能方面的一个巨大飞跃。 这是一个难得的机会，可以看到一个全新的行业从零开始。 Defi 空间将首先迎头赶上今天的金融服务业。 但是随着时间的推移，当建立金融服务的能力大众化给任何一个会编写代码的人时，我们甚至很难了解什么样的创新会出现。</p>
]]></content>
    </entry>
</feed>