<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lianqiujun.co</id>
    <title>链 求 君 | 区 块 链</title>
    <updated>2021-01-06T08:01:37.728Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lianqiujun.co"/>
    <link rel="self" href="https://lianqiujun.co/atom.xml"/>
    <subtitle>实践更多区块链项目，探索更多Web3可能性！</subtitle>
    <logo>https://lianqiujun.co/images/avatar.png</logo>
    <icon>https://lianqiujun.co/favicon.ico</icon>
    <rights>All rights reserved 2021, 链 求 君 | 区 块 链</rights>
    <entry>
        <title type="html"><![CDATA[常用工具手册]]></title>
        <id>https://lianqiujun.co/post/chang-yong-gong-ju-shou-ce</id>
        <link href="https://lianqiujun.co/post/chang-yong-gong-ju-shou-ce">
        </link>
        <updated>2021-01-06T07:57:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="命令">命令</h1>
<ul>
<li>
<p><a href="#">Git 命令</a></p>
</li>
<li>
<p><a href="#">IDEA 快捷键</a></p>
</li>
<li>
<p><a href="#">Linux 命令</a></p>
</li>
<li>
<p><a href="#">Mac 命令</a></p>
</li>
<li>
<p><a href="#">Vim 命令</a></p>
</li>
<li>
<p><a href="#">Markdown 语法</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程要素：函数和数据]]></title>
        <id>https://lianqiujun.co/post/bian-cheng-yao-su-han-shu-he-shu-ju</id>
        <link href="https://lianqiujun.co/post/bian-cheng-yao-su-han-shu-he-shu-ju">
        </link>
        <updated>2021-01-06T07:13:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://docs.python.org/zh-cn/3.8/library/index.html">Python 官方文档</a><br>
| <a href="http://composingprograms.com/pages/12-elements-of-programming.html">教程文档</a></p>
<h2 id="函数和数据">函数和数据</h2>
<p>计算机编程语言的作用，除了让计算机执行一些任务以外。更大的作用是整理计算过程，并且表达出编程者思想以供其他人阅读。<br>
所以，<strong>程序主要是写给人看的，恰好还能够让机器执行。</strong></p>
<p>“将简单的想法，通过组合成更复杂的想法，是编程语言的核心”  --- 抽象</p>
<p>任何一门功能强大的编程语言，都具有以下三种机制：</p>
<ul>
<li>“基本表达式”和“语句”： 表示语言提供的最简单的语法</li>
<li>“组合”手段： 通过这些手段可以从简单的元素构建复合元素</li>
<li>“抽象”手段： 通过该手段可以将复合元素命名给变量并进行操作</li>
</ul>
<h3 id="11-什么是表达式">1.1 什么是&quot;表达式&quot;？</h3>
<p>每一门语言都有它最原始的表达式，比如数字。</p>
<pre><code># 数字
&gt;&gt;&gt; 42 
42

&gt;&gt;&gt; 1 + 1 
2 

# 运算符和标记符号 
+ - * / &gt; &lt;  
{} [] ''  &quot;&quot;
# 保留字
if  for  while 


</code></pre>
<h3 id="12-什么是调用表达式">1.2 什么是&quot;调用表达式&quot;?</h3>
<p>复合表达式中，最重要的一种是：调用表达式<br>
它将一个函数对某些参数进行一些特定的处理。</p>
<pre><code>a = max(4,5)  # a = 5
b = min(3,9)  # b = 3 
c = str(3)    # c = '3'
</code></pre>
<h3 id="13-库函数">1.3 库函数</h3>
<ul>
<li>库函数，就是许多函数被组合在各种模块中，然后这些模块共同构成了Python的库</li>
<li>Python标准库， 就是安装Python时一起被安装的库函数，可以直接import然后使用</li>
<li>第三方库， 根据需求不同，自行下载导入的第三方写好的库函数包。</li>
</ul>
<p>详细的内容可以参考：<br>
<a href="https://docs.python.org/zh-cn/3.8/library/index.html">Python 官方文档</a></p>
<h3 id="21-变量与环境">2.1 变量与环境</h3>
<p>编程语言中，如果要对一些值进行计算操作，会使用变量作为值的引用。给定一个值的变量名，就是将这个值绑定给这个变量了。</p>
<pre><code>&gt;&gt;&gt; radius = 10
&gt;&gt;&gt; radius
10

&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; pi * 71 / 223
1.0002380197528042
</code></pre>
<p>= ,即赋值号。是最简单的“抽象”方式，可以通过赋值号，将一系列复合运算的结果值与某个变量绑定，完成一次简化的过程。</p>
<p>通过上述的方式： 计算机完成将变量的值绑定在变量上，然后通过访问这些变量来获取其对应的值。<br>
这意味着，解释器/编译器必须维护某些内存，以保证维持“变量”与“值”直接这样的绑定关系，这就是程序的运行“环境”。</p>
<h3 id="22-解析表达式与表达树">2.2 解析表达式与表达树</h3>
<p>多个基础的表达式，通过嵌套组合成复杂表达式，再由复杂的表达式，逐层拆解为基础表达式，这个过程类似一颗倒立的树木。<br>
表达树：<br>
max(min(a,b), max(c,d))</p>
<p>↓</p>
<p>max() → min(a,b), max(c,d)</p>
<p>↓</p>
<p>min() → a,b 和 max() → c,d</p>
<p>↓</p>
<p>a,b,c,d</p>
<p>直到不可拆分，就达到了树的节点，也就是最基础的表达式了。</p>
<pre><code>x = 3

sum(x,1)
</code></pre>
<p>每一行代码，只会执行得的两种结局： 1.执行过程 2.解析表达式</p>
<pre><code>x = 3 # 此时单纯的“赋值” ， 对“环境” 中的值不做影响， 不产生任何新的结果

y = sum(x,1) # 表达式解析后，对“环境”中的“值”： x 对应的值3 进行 加法运算，加1后，新的结果值从函数中返回并绑定给变量名y
</code></pre>
<h3 id="23-纯功能函数">2.3 纯功能函数</h3>
<p>纯函数就是有一些输入值，经过函数处理后，返回一些输出值。而且使用同样的值调用同一个函数两次，返回的值都是相同的。<br>
纯函数更加容易测试，而且可以更加稳定的构建复合表达式。</p>
<h3 id="24-非纯功能函数">2.4 非纯功能函数</h3>
<p>非纯函数就是除了会返回值以外，还会有其他的行为，比如“打印”或者“文件生成”，总之可能会造成计算机状态发生变化的行为。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程要素：入门]]></title>
        <id>https://lianqiujun.co/post/bian-cheng-yao-su-ru-men</id>
        <link href="https://lianqiujun.co/post/bian-cheng-yao-su-ru-men">
        </link>
        <updated>2021-01-06T07:03:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://pythontutor.com/composingprograms.html#mode=edit">在线环境</a> |<br>
<a href="https://docs.python.org/zh-cn/3.8/">Python文档</a></p>
<h3 id="1-抽象是什么">1. 抽象是什么？</h3>
<p>抽象就是人对世间万物的一种感受，通过符号表达出来的过程。就像&quot;红色&quot;就是一个抽象的概念，你脑海中不存在&quot;色彩&quot;这种概念的时候，它就是一个很抽象的东西，当我们第一次接触&quot;红色&quot;这个词语时，并不清楚，&quot;红色&quot;是甜的，酸的，软的，硬的？还是说是一种&quot;颜色&quot;，这是通过我们在生活中不断的从周围的环境中慢慢感知出来的。</p>
<p><strong>简单来说，抽象就是将内心的感受使用一种特定的符号表示出来的”过程“。</strong></p>
<p><strong>数学</strong> 就是一门抽象的学科， 0,1,2,3,4,+,-,*,=,&gt;,&lt; 这些符号本身是没有意义的，他们是一种抽象的表现，就像我们前面提到的“红色”。 人有2只眼睛，1个嘴巴，这里的“数量” 是人类对生活的观察和感受，“2”，“1”则是人类对“数量”的抽象符号表示。</p>
<h3 id="2-数学为什么是抽象的">2. 数学为什么是抽象的？</h3>
<p>数学的发展史告诉我们，数学起源于“算”，即起源于物体个数、田亩面积、物体长度等的计算。要计算就要有计算方法，当各种计算方法积累到一定数量的时候，数学家就进行分类，抽象出某类问题的计算公式、法则、原理，统称为算法。所以数学的童年时期叫做算术，它表现为一种经验知识。</p>
<h3 id="3-计算机和编程与抽象的关系">3. 计算机和编程与抽象的关系</h3>
<p>通过理解了抽象是什么，应该明白：<strong>“编程语言”不应该是你要学习的东西，而是用来理解表达你经验知识的工具。</strong><br>
计算机，则是你掌握和控制这些抽象概念的一个机器。<br>
如果做比喻的话:</p>
<ul>
<li>“1,2,3,4” 经过人脑的转换，被理解成人脑海中所理解的“数量”</li>
<li>“编程语言” 经过计算机的转换，变成了计算机执行的一系列“操作”</li>
</ul>
<p>而“编程”就是，人类将自己对于世界的感受，用自己能够理解的方式整理之后（算法+数据结构），然后通过语言符号和基本规则（a,b,c,d,1,2,3,4，+，-，%）抽象成计算机能够理解和执行的程序代码。</p>
<h3 id="4-编程语言">4.  编程语言</h3>
<p>不同的编程语言，有着自己的规范或是规则。但是它们的本质是一样的，就是对数学计算的抽象。我们采用的编程语言Python，就是一种“简单”的编程语言，为什么说它简单，就是因为Python的抽象更加接近人类理解的语言“英语”。</p>
<ul>
<li>注意：人类的语言“汉语”，“英语”也是一种抽象的表现。</li>
</ul>
<p>“红” 和 “red” 只是两个不同的符号，但它们的意义是一样的。<br>
就像Java中的“true” 和 Python中的“True”，代表的意义没什么不同。</p>
<h3 id="5-实践">5. 实践</h3>
<pre><code>from urllib.request import urlopen    # (2)

# 计算机程序只干两件事：
# (1) 计算一些值    
# (2) 执行一些动作

# 后面用符号标记每行代码的功能： （1），（2）

tianqi = urlopen('http://t.weather.sojson.com/api/weather/city/101020100')  # (2)

# 一、 什么是函数（function） ？
# 函数就是将处理数据的过程封装起来，“抽象”成一个符号来代替这些过程。
# urlopen() 就是Python库中的一个函数，url网址是一条数据，返回的结果
# 是另外一条数据,也就获得了内容，简化： B = urlopen(A)  
# 这就用了简单的一句话完成了一些动作，而复杂的过程存在于函数中。
# 这里将这些复杂过程抽象成一个函数名“urlopen”

data = set(tianqi.read().decode().split(',')) # (1)

# 二、 什么是对象（object）？
# set() 函数中经过 read() decode() split() 等一系列函数的复杂计算
# 最终得到data （对象），将“数据”和“处理数据的逻辑”紧密的联系在一起
# 最终简化： C = set(B)    B是开始的数据，C是“抽象”处理后的数据。


result = [w for w in data if len(w) &gt; 0]    # (2)

# 三、 计算机如何理解程序？解释器 （Interpreters）
# 语法中的表达式： result是经过了语言特定的表达式，获得的数据。
# 而在不同的编程语言，可能会有着各自的语法规则（特色）
# 那么计算机是如何理解不同的编程语言的？ 解释器/编译器
# Python、Java、Go、C# 每种语言都有自己特定的解释器。


# 最后， 我们将发现所有这些核心概念都是紧密相关的：
# 函数就是对象，对象就是函数，解释器是两者的实现表达的过程。
# 这些概念的清晰理解对于掌握编程技术至关重要。

</code></pre>
<h3 id="6-学习">6. 学习</h3>
<ul>
<li>实例1  双指针法</li>
</ul>
<pre><code>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1:
给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。
示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}


class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        # 先排序
        nums.sort()
        i = 0
        while i &lt; len(nums) - 1:
            if nums[i] == nums[i + 1]:
                nums.remove(nums[i])
            else:
                i = i + 1
        return len(nums)


</code></pre>
<ul>
<li>实例2  哈希表遍历</li>
</ul>
<pre><code>&quot;&quot;&quot;
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum

&quot;&quot;&quot;

class Solution:
    def twoSum(self, nums: list, target: int) -&gt; list:
        nl = []
        k = {}
        if len(nums) &lt; 2:
            return []
        elif (len(nums) == 2) and (target == nums[0] + nums[1]):
            return [0, 1]

        for i in range(len(nums)):
            k[nums[i]] = i

        for i in range(len(nums)):
            c = target - nums[i]  # 差值
            if (c in nums) and (k[c] != i):
                # 添加下标
                nl.append(k[c])
                nl.append(i)
        nl = list(set(nl))
        return nl

nums = [3, 2, 3]
target = 6
# [0, 2]
r = Solution().twoSum(nums, target)
print(r)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 编程要素]]></title>
        <id>https://lianqiujun.co/post/python-bian-cheng-yao-su</id>
        <link href="https://lianqiujun.co/post/python-bian-cheng-yao-su">
        </link>
        <updated>2021-01-06T07:01:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目录">目录</h1>
<h2 id="1-入门">1. <a href="#">入门</a></h2>
<h2 id="2-函数和数据">2. <a href="#">函数和数据</a></h2>
<h2 id="3-定义新功能">3. <a href="#">定义新功能</a></h2>
<h2 id="4-设计功能">4. <a href="#">设计功能</a></h2>
<h2 id="5-控制">5. <a href="#">控制</a></h2>
<h2 id="6-高阶函数">6. <a href="#">高阶函数</a></h2>
<h2 id="7-递归函数">7. <a href="#">递归函数</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 快速上手]]></title>
        <id>https://lianqiujun.co/post/golang-kuai-su-shang-shou</id>
        <link href="https://lianqiujun.co/post/golang-kuai-su-shang-shou">
        </link>
        <updated>2021-01-06T06:41:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="参考">参考</h2>
<ul>
<li>
<p><a href="https://draveness.me/golang-101/">如何写出优雅的 Go 语言代码</a></p>
</li>
<li>
<p><a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">Go 语言设计与实现</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/go/go-tutorial.html">Go 语言教程</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 常见问题汇总]]></title>
        <id>https://lianqiujun.co/post/golang-chang-jian-wen-ti-hui-zong</id>
        <link href="https://lianqiujun.co/post/golang-chang-jian-wen-ti-hui-zong">
        </link>
        <updated>2021-01-06T06:37:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="语法问题">语法问题</h1>
<ol>
<li>变量定义简写</li>
</ol>
<p><code>:=</code> 只能在函数内部使用，如果声明全局变量需要使用<code>var</code>关键字,否则会出现报错，例如 <code>syntax error: non-declaration statement outside function bod</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开发利器：快速构建 Flow Dapp]]></title>
        <id>https://lianqiujun.co/post/kai-fa-li-qi-kuai-su-gou-jian-flow-dapp</id>
        <link href="https://lianqiujun.co/post/kai-fa-li-qi-kuai-su-gou-jian-flow-dapp">
        </link>
        <updated>2020-12-15T14:26:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="decentology介绍">Decentology介绍</h2>
<p>Decentology是一个帮助开发者快速进行Dapp构建的网站，可以在10分钟内构建一套全栈Dapp应用程序。</p>
<p>当我们开始学习一个新的，可扩展的应用程序时，都会想获得一些“快速可见的效果”。也就是说，我想进行一些细微的细微更改，以查看该应用程序是否正常运行，并且期望并查看我的操作是如何进行的。结果通常是需要花费不少时间，才能将应用程序正常的运行起来。但是，正确的学习方法，应该是尽可能的缩短反馈周期，进行一些小的更改并获得这些“快速的胜利”不可避免地会帮助我们学习并拥有更多的理解。</p>
<p>这正是我推荐的Decentology要尝试帮助我们做的事情：</p>
<ul>
<li><a href="https://dappstarter.decentology.com/">Decentology</a></li>
</ul>
<h2 id="flow-dapp-的快速构建">Flow Dapp 的快速构建</h2>
<p>该网站已经免费提供了基于Flow的项目生成，步骤十分简单：</p>
<ul>
<li>第1步，智能合约栈</li>
</ul>
<p>DappStarter是用于区块链的全栈开发环境。它支持您选择的区块链和区块链语言，并在您选择客户端框架时提供集成的前端用户体验。</p>
<figure data-type="image" tabindex="1"><img src="https://lianqiujun.co/post-images/1608042585291.jpg" alt="" loading="lazy"></figure>
<ul>
<li>第2步，智能合约功能</li>
</ul>
<p>您选择的功能将为您提供定制的智能合约，以获取应用程序所需的一切。</p>
<figure data-type="image" tabindex="2"><img src="https://lianqiujun.co/post-images/1608042597635.jpg" alt="" loading="lazy"></figure>
<ul>
<li>第3步，Dapp定制</li>
</ul>
<p>量身定制适合你业务的区块链应用</p>
<figure data-type="image" tabindex="3"><img src="https://lianqiujun.co/post-images/1608042610399.jpg" alt="" loading="lazy"></figure>
<ul>
<li>第4步，生成应用仓库</li>
</ul>
<p>最终全栈源码会被生成在Github 仓库， 开发者可以自行下载至本地，运行开发。</p>
<figure data-type="image" tabindex="4"><img src="https://lianqiujun.co/post-images/1608042677675.jpg" alt="" loading="lazy"></figure>
<p>项目仓库：<br>
<em>Github： https://github.com/DappStarter</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[译] 面向资源编程：更好的数字所有权模型]]></title>
        <id>https://lianqiujun.co/post/yi-mian-xiang-zi-yuan-bian-cheng-geng-hao-de-shu-zi-suo-you-quan-mo-xing</id>
        <link href="https://lianqiujun.co/post/yi-mian-xiang-zi-yuan-bian-cheng-geng-hao-de-shu-zi-suo-you-quan-mo-xing">
        </link>
        <updated>2020-12-15T13:48:03.000Z</updated>
        <content type="html"><![CDATA[<p>软件工程师们经常使用“所有权”一词，用来表示，某块代码负责管理某种数据结构或系统资源。这种隐喻在编程环境中最为普遍，在这种环境中，内存管理并非是从程序员那里抽象出来的，所谓的代码“拥有”一个对象，就是说代码有权管理并释放分配给该对象的内存。</p>
<p>但是，当我们在其他任何情况下谈论“所有权”时，通常是在谈论具有持久价值的资产，而不是短暂的数据结构。尽管可以使用现有的编程环境来跟踪资产的所有权，但是它们通常用于反映所有权，而不是直接定义资产的所有权。公链区块链的独特之处在于，它们明确设计用于管理真正稀缺和完全访问控制的数字资产所有权。诸如比特币或Flow之类的公链区块链上的数字资产应表现得像有形资产：不得复制或伪造，只能转让。</p>
<p>随着区块链的发展，代表所有权的机制也发生了变化。比特币是使用“未用交易输出”或称之为 UTXO 的所有权模型构建的。虽然 UTXO 模型非常高效，但它很复杂并且会创建一些异常的边缘情况，因此以太坊采用了更灵活的分类账模型。不幸的是，以太坊模型几乎没有针对编程出现的错误进行保护措施，导致程序的错误造成加密货币社区损失了超过1亿美元的资金。</p>
<p>理想情况下，旨在管理数字所有权的编程语言应包括数字资产的本身的表示形式，并具有防止破坏价值的错误的内置保护措施。</p>
<h2 id="cadence-介绍一种高级的面向资源的编程语言">Cadence 介绍，一种高级的面向资源的编程语言</h2>
<p>去年，在对更好的智能合约语言进行学术研究之后，Flow团队正在研究在区块链环境中使用线性类型。而几乎在同一时间，Libra 团队发布了最初的公告，其中包括MoveVM的技术细节。</p>
<p>Libra 团队基于线性类型的启发，构建了新所有权模型：<strong>资源（Resource）</strong>，为 Move 定义了新的编程模型。资源是一种直接用编程语言表示资产所有权和启用加密数字资产属性的新方法。</p>
<p>关于Move的简介：</p>
<p>Move 的主要功能是能够定义自定义资源类型。资源类型用于对具有丰富可编程性的安全数字资产进行编码。</p>
<p>资源导向编程的强大功能令我们震惊，它是 Cadence 的核心功能之一，而 Cadence 正是我们为 Flow 开发的智能合约编程语言。</p>
<p>作为第一种高级的面向资源的编程语言，Cadence 具有舒适的，符合人体工程学的语法，非常易于阅读。它使用强大的静态类型系统来最大程度地减少运行时错误，并允许所有方法，接口和事务包含前置条件和后置条件以强制执行预期的行为。我们认为，这将导致一种语言，比任何其他替代方法更易于学习，更易于审核，最终最终将提高生产力。</p>
<p>您可以在<a href="https://play.onflow.org/">Flow Playground</a> 上体验 Cadence。</p>
<h2 id="面向资源的编程如何工作">面向资源的编程如何工作？</h2>
<p>资源提供了比 EVM 或 WASM 更丰富的可组合性选项，并且非常适合数字资产。将某物标记为“资源”可以告诉编程环境，该数据结构代表某种有形的价值，并且与该数据结构交互的所有代码都需要遵循一系列特殊规则，以保持该数据结构的价值。</p>
<p>那么，这些规则是什么？</p>
<ul>
<li>
<p>每个资源在任何给定时间都恰好存在于一个地方。</p>
</li>
<li>
<p>不能通过编程错误或恶意代码来复制或意外删除资源。</p>
</li>
<li>
<p>资源的所有权由其存储位置定义。无需参考中央分布式帐本的方式来确定所有权。</p>
</li>
<li>
<p>对资源上方法的访问仅限于所有者。例如，只有CryptoKitty的所有者才能发起繁殖操作，从而导致新Kitty的诞生。</p>
</li>
<li>
<p>仅仅由编译器强制执行资源（Resource）对象的特殊状态是不够的。这些代码还必须在链上执行时强制执行。如果没有链上运行时的支持，攻击者很容易使用被篡改过的编译器绕过确保资源安全的规则。</p>
</li>
</ul>
<p>然而，如果确实的正确执行了这些规则，则可以确保将区块链网络中最重要的资产，安全地存储在由用户提交的代码控制的数据结构中。这样做的确很强！</p>
<h2 id="我们来看个例子">我们来看个例子！</h2>
<p>理解资源（Resource）的最简单方法是通过使用诸如谜恋猫（CryptoKitty） 之类的非同质化通证（NFT）作为示例思考。每个谜恋猫（CryptoKitty） 是不可分割的，不可复制的，并且可以有一个直接所有者，该所有者直接与 Resource 数据结构相匹配。</p>
<p>在以太坊等账本模型中，所有 CryptoKitties 都作为一个巨型列表存储在单个智能合约中。通过将每个所有者的帐户ID存储在中央区块链帐本中来跟踪每个Kitty的所有权，而更改 Kitty 所有权的唯一方法是发起调用合约请求，并要求其更新与该 Kitty 相关的帐户ID。</p>
<p>在资源模型中，Kitty 本身表示为一个Resource对象，它直接存储在拥有它的帐户中。就像在现实世界中一样，所有权是通过拥有它来表示的。您无需查看中央账本，即可查看您是否拥有某物，可以将其存储在帐户中，也可以不用。而且，如果您拥有它，则可以转移它或以其他方式对其进行控制，如果您没有，则无法捕获或更改它。</p>
<p><em>注意：为了专注于账本模型和资源模型之间的差异，以上两个示例都忽略了访问控制，定义每个变量以及实时代码需要担心的其他因素等问题。</em></p>
<h2 id="为什么资源很重要">为什么资源很重要</h2>
<p>资源可以便于管理所有权的抽象，并且防止错误的同时提高智能合约开发人员的生产力，但是使用资源还有一些其他的好处，每个好处本身都非常重要：</p>
<ul>
<li>费用管理</li>
</ul>
<p>可扩展的智能合约平台需要某种方式来收取“租金”，因为每一份计算资源的使用都需要支付费用，存储在区块链上的数据若不支付则会被删除。</p>
<p>使用账本模型，很难知道应该由谁支付租金。例如，CryptoKitties 合约代表着数以万计的玩家，拥有近200万只 Kitty 和超过 111MB 的链上数据。以太坊无法向所有 Kitty 所有者公平地收取租金。</p>
<p>使用通过资源类型的直接所有权模型，每只猫咪都将与该人的其他资产一起存储在其所有者的帐户内。谁需要为此存储付费，责任很明确。此外，单个用户（在其客户端软件的帮助下）可以归档未使用的资产，以降低成本并减少网络负载。</p>
<ul>
<li>灵活的所有权</li>
</ul>
<p>将账本模型用于所有权会限制所有者与其他拓展方案的兼容。例如，ERC-721为NFT定义了一种所有权模型，该模型假定只有以太坊地址才能拥有NFT。但是，资产本身拥有其他资产的想法（例如，拥有一副漂亮的太阳镜的CryptoKitty）在某些用例中非常有趣，并且需要创建新的规范（ERC-998）。ERC-998非常强大，但它也比ERC-721复杂得多。正确实施它非常困难，由于以太坊智能合约的不变性，将其功能追溯应用到现有ERC-721资产实际上是不可能的。</p>
<p>资源模型允许将使用“资源类型”建模的任何资产安全地存储在系统中的任何位置，包括在其他资产“内部”（如果适用）。所有安全性和价值保证都可以由运行时系统维护，同时为开发人员提供了创造性和灵活性，而又不会带来过多的复杂性。</p>
<ul>
<li>基于功能的安全性</li>
</ul>
<p>资源类型是提供了基于功能的安全模型，其中具备实现“功能”概念所需的所有保证。功能是定义安全系统的强大机制，可以遵守最小特权原则（安全系统中的一种常见最佳做法）更加容易，该原则要求安全系统的所有部分都没有绝对的特权。是他们完成工作所必需的）。<br>
基于功能的安全模型通常被认为更容易推理（增强了安全性），同时具有更大的灵活性。</p>
<ul>
<li>消除重入错误</li>
</ul>
<p>以太坊历史上最著名的智能合约错误是由于重入问题而引起的，Solidity开发人员需要时刻保持警惕，以防止引入容易受到重入攻击的逻辑流。<br>
幸运的是，在Resource对象上定义的方法不能成为任何可重入漏洞利用的受害者。<br>
这似乎是一个大胆的改变！遵循资源的定义方式：每个资源都有一个所有者，只有资源的所有者才能在其上调用方法。如果Resource方法是“堆栈上的”，则我们知道对该对象的单个所有权引用已经被明确分配；我们从该方法内部调用的任何代码（无论是间接调用）根本不可能再次获得对该对象的引用以进行可重入方法调用。</p>
<p>当然，直接使用全局共享状态（绕过Resource对象的使用）仍然可以创建易受重入错误影响的代码。这就是为什么惯用的Cadence 编程范式是对所有共享状态使用Resources的原因；精通面向资源编程的合约开发者，将无需再考虑可重入的bug！</p>
<hr>
<p><a href="https://medium.com/dapperlabs/resource-oriented-programming-bee4d69c8f8e">翻译自 Dieter Shirley 原文</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Visual Studio Code 进行 Cadence 开发]]></title>
        <id>https://lianqiujun.co/post/shi-yong-visual-studio-code-jin-xing-cadence-kai-fa</id>
        <link href="https://lianqiujun.co/post/shi-yong-visual-studio-code-jin-xing-cadence-kai-fa">
        </link>
        <updated>2020-12-15T08:12:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="cadence-编程语言简介">Cadence 编程语言简介</h2>
<p>Cadence 编程语言是一种用于智能合约开发的新型高级编程语言。</p>
<p>该编程语言的重要特性如下：</p>
<ul>
<li>
<p>安全：它提供了强大的静态类型系统，按合约进行设计（前提条件和后置条件）和资源（受线性类型启发）。</p>
</li>
<li>
<p>可审核：关注其可读性，使验证代码的工作变得容易，并使程序表达的意图明确，而花费的时间成本很小。</p>
</li>
<li>
<p>简单：专注于开发人员的生产力和可用性，简化编写代码的过程，并提供良好的开发工具。</p>
</li>
</ul>
<h2 id="cadence-开发">Cadence 开发</h2>
<p>在Flow官网可以看到Cadence的在线 Playground ，开发者可以轻松学习开发Cadence 在 Flow 的链上完成货币、收藏品和集市等智能合约的编写与测试。</p>
<p><em>Playground :  https://play.onflow.org/</em></p>
<p>对于更复杂多样的功能，开发者需要在本地进行开发时，首先可以选择用 Visual Studio Code 开发Cadence。 那么，需要先安装 Visual Studio Code，并且要为它安装开发插件才能支持 Cadence的开发，</p>
<p>Visual Studio Code  Cadence插件是与Flow CLI 捆绑在一起，而Flow CLI是用于处理Flow指令的命令行工具。所以我们必须先要安装  <code>flow-cli</code>：</p>
<ul>
<li>Windows 安装 <code>flow-cli</code></li>
</ul>
<pre><code>iex &quot;&amp; { $(irm 'https://storage.googleapis.com/flow-cli/install.ps1') }&quot;
</code></pre>
<ul>
<li>Linux 或 macOS 安装 <code>flow-cli</code></li>
</ul>
<pre><code>sh -ci &quot;$(curl -fsSL https://storage.googleapis.com/flow-cli/install.sh)&quot;
</code></pre>
<p><em>Github： https://github.com/onflow/flow-cli</em></p>
<p>使用如下命令，查看一下 <code>flow</code> 版本，检测是否安装成功了。</p>
<pre><code>flow version
</code></pre>
<p>成功安装后，再来安装 <code>Cadence</code> 的 <code>Visual Studio Code 插件</code>, 请在 <code>macOS / Linux</code> 上的终端或 Windows 上的 <code>PowerShell</code> 中运行以下命令：</p>
<pre><code>flow cadence install-vscode-extension
</code></pre>
<p>重新启动 Visual Studio Code 以完成插件的安装。</p>
<h2 id="运行区块链模拟器">运行区块链模拟器</h2>
<p>可以直接从 Visual Studio Code 运行模拟器。</p>
<p>请打开命令面板（在<code>macOS和Linux / Windows</code>上按），然后按 <code>Shift+Command+P</code> 或 <code>Shift+Ctrl+P</code> 后，输入  <code>run emulator</code> 启动本地区块链模拟器。</p>
<figure data-type="image" tabindex="1"><img src="https://lianqiujun.co/post-images/1608021954016.jpg" alt="" loading="lazy"></figure>
<p>这将打开一个新终端并启动 Flow 区块链的仿真版本。</p>
<p>另外，模拟器也可以在命令行上运行。</p>
<p>在<code>macOS / Linux</code>上的终端或<code>Windows</code>上的<code>PowerShell</code>中，运行：</p>
<pre><code>flow emulator start --init
</code></pre>
<p>模拟器运行后，您可以开始部署代码和提交事务。</p>
<ul>
<li>活跃账户</li>
</ul>
<p>当模拟器在 VSCode 中运行时，活动帐户显示在编辑器的右下角。这表明要部署到哪个帐户合约，哪个帐户是提交交易的签名者。</p>
<ul>
<li>变更账户</li>
</ul>
<p>要更改帐户，请单击屏幕右下角的活动帐户按钮。这将显示一个帐户列表供您选择。单击其中一个帐户，该帐户将被选为活动帐户。显示的第一个帐户是服务帐户，这是Flow的特殊帐户。不要将代码部署到该帐户，否则它将使模拟器混乱。切换到帐户1部署您的第一个合约。</p>
<figure data-type="image" tabindex="2"><img src="https://lianqiujun.co/post-images/1608022320831.jpg" alt="" loading="lazy"></figure>
<h2 id="部署合约">部署合约</h2>
<p>当模拟器运行时，您可以将合约部署到活动帐户。您应该在编辑器的合约定义上方看到一个按钮，显示。单击该按钮以部署合约。这将覆盖以前部署到该帐户的所有合约。</p>
<figure data-type="image" tabindex="3"><img src="https://lianqiujun.co/post-images/1608023177804.jpg" alt="" loading="lazy"></figure>
<pre><code>Deploy contract to account 0xf3fcd2c1a78f5eee
</code></pre>
<p><em>VScode 插件 Github： https://github.com/onflow/vscode-flow</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dapp简介]]></title>
        <id>https://lianqiujun.co/post/dapp-jian-jie</id>
        <link href="https://lianqiujun.co/post/dapp-jian-jie">
        </link>
        <updated>2020-12-02T05:46:11.000Z</updated>
        <content type="html"><![CDATA[<p>去中心化应用程序（dapp）是在分散式网络上构建的应用程序，它结合了智能合约和前端用户界面。请注意，在以太坊中，智能合约是公开可访问且透明的（例如开放的API），因此您的dapp甚至可以包含其他人编写的智能合约。</p>
<h2 id="预备知识">预备知识</h2>
<p>在学习dapp之前，您应该了解区块链<a href="">基础知识</a>，并了解以太坊网络及其去中心化方式。</p>
<h2 id="dapp的定义">DAPP的定义</h2>
<p>dapp的后端代码在部署在点对点网络上运行。将其与在集中式服务器上运行后端代码的应用程序进行对比，两者是不同的。</p>
<p>dapp可以具有自己的前端代码和用户界面，可以调用任何后端语言（就像应用程序一样）编写的后台程序，同样可以调用部署在区块链上的智能合约。此外，它的前端可以托管在去中心存储（例如IPFS）上。</p>
<ul>
<li>
<p>去中心化的管理使他们独立，没有人可以控制他们。</p>
</li>
<li>
<p>确定性的，即它们执行相同的功能，而不管它们执行的环境如何。</p>
</li>
<li>
<p>图灵兼容，这意味着只要有必要的资源，dapp就可以执行任何操作。</p>
</li>
<li>
<p>隔离，这意味着它们在称为以太坊虚拟机（EVM）的虚拟环境中执行，因此，如果某个智能合约碰巧有错误，则不会妨碍区块链网络的正常运行。</p>
</li>
</ul>
<h2 id="关于智能合约">关于智能合约</h2>
<p>要引入dapp，我们需要引入智能合约，即dapp的后端。有关详细的概述，请转到<a href="">智能合约</a>部分。</p>
<p>智能合约是部署在以太坊区块链上的代码，完全按照编程的逻辑运行。一旦将它们部署在网络上，就无法更改它们。Dapps可以是去中心化的，因为它们受合同中写入的逻辑（而不是个人或公司）的控制。这也意味着您需要非常仔细地设计合同并进行全面测试。</p>
<h2 id="dapp开发的好处">DAPP开发的好处</h2>
<ul>
<li>
<p>零停机时间 – 一旦在应用程序核心和区块链上部署了智能合约，整个网络将始终能够为希望与合约进行交互的客户提供服务。因此，恶意行为者无法针对单个dapp发起拒绝服务攻击。</p>
</li>
<li>
<p>隐私 – 您无需提供真实身份即可部署dapp或与dapp交互。</p>
</li>
<li>
<p>抵制审查 – 网络上没有任何一个实体可以阻止用户提交交易，部署dapp或从区块链读取数据。</p>
</li>
<li>
<p>完整的数据完整性 – 借助密码原语，存储在区块链上的数据是不变且无可争议的。恶意行为者无法伪造已公开的交易或其他数据。</p>
</li>
<li>
<p>不可信的计算/可验证的行为 – 智能合约可以进行分析，并保证以可预测的方式执行，而无需信任中央机构。在传统模型中情况并非如此；例如，当我们使用在线银行系统时，我们必须相信金融机构不会滥用我们的财务数据，篡改记录或被黑。</p>
</li>
</ul>
<h2 id="dapp开发的问题">DAPP开发的问题</h2>
<ul>
<li>
<p>维护 – dapps难以维护，因为发布到区块链的代码和数据更难修改。开发人员一旦部署dapp（或dapp存储的基础数据）就很难进行更新-即使在旧版本中发现了错误或安全风险。</p>
</li>
<li>
<p>性能开销 – 巨大的性能开销，扩展真的很困难。为了达到以太坊所追求的安全性，完整性，透明性和可靠性水平，每个节点都要运行并存储每个事务。最重要的是，工作量证明也需要时间。包络计算使开销大约为当前标准计算的1,000,000倍。</p>
</li>
<li>
<p>网络拥塞 – 至少在当前模型中，一个dapp会使用过多的计算资源，将数据备份至整个网络。目前，该网络每秒只能处理大约10个事务。如果发送交易的速度快于此速度，则未经确认的交易池会迅速膨胀。</p>
</li>
<li>
<p>用户体验 – 可能难以设计出用户友好的体验：普通最终用户可能会发现建立以真正安全的方式与区块链进行交互所必需的工具栈太困难了。</p>
</li>
<li>
<p>集中化 – 无论如何，建立在以太坊基础层之上的用户友好型和开发人员友好型解决方案最终看起来都像集中式服务：例如，此类服务可能存储密钥或其他敏感信息服务器端，使用集中式服务于前端服务器，或在写入区块链之前在集中式服务器上运行重要的业务逻辑。这消除了区块链相对于传统模型的许多（如果不是全部）优势。</p>
</li>
</ul>
<h2 id="dapp工具">DAPP工具</h2>
<ul>
<li>
<p>Rimble UI- 适用于分散式应用程序的自适应组件和设计标准。</p>
<p>https://rimble.consensys.design/</p>
<p><a href="https://github.com/ConsenSysMesh/rimble-ui">GitHub</a></p>
</li>
</ul>
<hr>
<ul>
<li>一键式Dapp -FOSS工具，用于从ABI生成dapp前端。</li>
</ul>
<p>https://oneclickdapp.com/</p>
<p><a href="https://github.com/One-Click-Dapp/one-click-dApp">GitHub</a></p>
<hr>
<ul>
<li>Etherflow -Ethereum开发人员的FOSS工具，用于测试其节点以及编写和调试来自浏览器的RPC调用。</li>
</ul>
<p>https://etherflow.quiknode.io/</p>
<p><a href="https://github.com/abunsen/etherflow">GitHub</a></p>
]]></content>
    </entry>
</feed>