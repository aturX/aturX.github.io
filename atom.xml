<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lianqiujun.co</id>
    <title>链 求 君 | 区 块 链</title>
    <updated>2020-11-18T06:12:12.769Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lianqiujun.co"/>
    <link rel="self" href="https://lianqiujun.co/atom.xml"/>
    <subtitle>实践更多区块链项目，探索更多Web3可能性！</subtitle>
    <logo>https://lianqiujun.co/images/avatar.png</logo>
    <icon>https://lianqiujun.co/favicon.ico</icon>
    <rights>All rights reserved 2020, 链 求 君 | 区 块 链</rights>
    <entry>
        <title type="html"><![CDATA[区块链开发 - 以太坊开发教程]]></title>
        <id>https://lianqiujun.co/post/qu-kuai-lian-kai-fa-yi-tai-fang-kai-fa-jiao-cheng</id>
        <link href="https://lianqiujun.co/post/qu-kuai-lian-kai-fa-yi-tai-fang-kai-fa-jiao-cheng">
        </link>
        <updated>2020-11-18T06:08:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="以太坊开发教程"><a href="https://lianqiujun.co/tag/pJWTDQOmu/">以太坊开发教程</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以太坊简介]]></title>
        <id>https://lianqiujun.co/post/yi-tai-fang-jian-jie</id>
        <link href="https://lianqiujun.co/post/yi-tai-fang-jian-jie">
        </link>
        <updated>2020-11-18T06:06:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是区块链">什么是区块链？</h2>
<p>最好将区块链描述为一个公共数据库，该数据库在网络中的许多计算机之间进行更新和共享。</p>
<p>“区块” 是指数据和状态以连续的批次或“块”的形式存储。如果你将 ETH 发送给其他人，则交易数据需要添加到区块中才能成功。</p>
<p>“链” 是指每个块以密码学的方式引用其父对象的结果，即上一个区块产生的结果。所以修改一个块的数据，会造成后续块的全部更改，这一过程需要整个网络的共识，并没有那么容易实现。</p>
<p>网络中的每个节点共同决定每个新块的产生和整个链的延续。这样为了确保每个人都有相同的数据。为此，区块链需要一种共识机制。</p>
<p>以太坊目前使用工作量证明共识机制。这意味着任何想要向链中添加新块的人都必须解决一个难题，即您需要大量的计算能力才能进行工作。解决难题“证明”您已经花费了计算资源。这样做被称为采矿。挖掘可以是反复试验的，但是成功添加一个区块会得到Eth的奖励。另一方面，考虑到您在生产该区块上花费的资源，提交欺诈性的区块并不是一个轻松选择。</p>
<p>新块将会广播到网络中的其他节点，进行检查和验证，为每个人更新状态。</p>
<p>综上所述，当您向某人发送ETH时，必须进行交易并包含在新区块中。然后，更新后的状态将与整个网络共享。</p>
<h2 id="什么是以太坊">什么是以太坊？</h2>
<p>在以太坊世界中，有一台规范的计算机（称为以太坊虚拟机或EVM），以太坊网络上每个人的状态都一致。参与以太坊网络的每个人（每个以太坊节点）都保留此计算机状态的副本。此外，任何参与者都可以广播此计算机执行任意计算的请求。每当广播此类请求时，网络上的其他参与者就会验证，确认并执行（“执行”）计算。这会导致EVM发生状态更改，该状态更改会在整个网络中提交并传播。</p>
<p>计算请求称为事务请求；所有交易的记录以及EVM的当前状态都存储在区块链中，而区块链又被所有节点存储并达成共识。</p>
<p>加密机制确保一旦交易被验证为有效并添加到区块链中，便不会在以后被篡改。相同的机制还可以确保所有交易都以适当的“权限”进行签名和执行（除了你自己之外，任何人都不能从你的帐户发送数字资产）。</p>
<h2 id="什么是ether">什么是Ether？</h2>
<p>以太币（加密货币）的目的是为网络中的参与者提供经济上的激励，使其可以验证/执行交易请求并向网络提供计算资源。</p>
<p>广播交易请求的任何参与者还必须向网络提供一定数量的以太币，以奖励最终从事验证交易，执行交易，将交易提交到区块链并将其广播到网络的工作的任何人。 。</p>
<p>所支付的以太币是作为计算资源的度量。这还可以防止恶意参与者通过请求执行无限循环或资源密集型脚本来故意阻塞网络，因为这些行为者将不断消耗计算资源。</p>
<h2 id="什么是dapp">什么是DAPP？</h2>
<p>在实践中，参与者并不是每次想要在EVM上请求计算时都编写新代码。而是，应用程序开发人员将程序（可重复使用的代码段）上载到EVM存储中，然后用户请求使用不同的参数来执行这些代码段。我们将程序上载到网络智能合约并由其执行。</p>
<p>从最基本的层面上讲，您可以将智能合约视为一种自动售货机：一个脚本，当使用特定参数调用该脚本时，如果满足特定条件，该脚本便会执行某些操作或计算。例如，如果呼叫者将以太币发送给特定的接收者，那么简单的卖方智能合约就可以创建并分配数字资产的所有权给收款方。</p>
<p>任何开发人员都可以创建智能合约，并使用区块链作为其数据层将其公开给网络，但要支付给网络相应的以太币。然后，任何用户都可以调用智能合约来执行其代码，但需要再次向网络支付费用。</p>
<p>因此，借助智能合约，开发人员可以构建和部署任意复杂的面向用户的应用程序和服务：市场，金融工具，游戏等。</p>
<h2 id="术语">术语</h2>
<ul>
<li>区块链</li>
</ul>
<p>网络历史中已提交给以太坊网络的所有块的顺序链接形成的数据结构。之所以这么称呼，是因为每个块都包含对前一个块的引用，这有助于我们在所有块（从而在精确的历史记录）上保持排序。</p>
<ul>
<li>ETH</li>
</ul>
<p>以太坊的原生加密货币。用户向其他用户付费以使其代码执行请求得到满足。</p>
<ul>
<li>EVM</li>
</ul>
<p>以太坊虚拟机是全球性的虚拟机，它声明以太坊网络上的每个参与者都存储并同意。任何参与者都可以请求在EVM上执行任意代码；代码执行会更改EVM的状态。</p>
<ul>
<li>节点数</li>
</ul>
<p>实际机器正在存储EVM状态。节点相互通信以传播有关EVM状态和新状态更改的信息。任何用户还可以通过广播来自节点的代码执行请求来请求代码执行。以太坊网络本身是所有以太坊节点及其通信的集合。</p>
<ul>
<li>账户</li>
</ul>
<p>存放ETH的地方。用户可以初始化帐户，将以太币存入帐户，以及将以太币从其帐户转移到其他用户。帐户和帐户余额存储在EVM中的一个大表中；它们是整个EVM状态的一部分。</p>
<ul>
<li>交易次数</li>
</ul>
<p>“交易请求”是在EVM上执行代码的请求的正式术语，“交易”是已履行的交易请求以及EVM状态中的相关更改。任何用户都可以从节点向网络广播交易请求。为了使事务请求实际影响商定的EVM状态，必须由其他某个节点对其进行验证，执行和“提交给网络”。任何代码的执行都会导致EVM中的状态改变；承诺后，此状态更改将广播到网络中的所有节点。一些交易示例：</p>
<ol>
<li>
<p>将X个 ETH 从A的帐户发送到B的帐户。</p>
</li>
<li>
<p>将一些智能合约代码发布到EVM内存中。</p>
</li>
<li>
<p>使用参数Y在EVM中的地址X处执行智能合约的代码。</p>
</li>
</ol>
<ul>
<li>智能合约</li>
</ul>
<p>开发人员将其发布到EVM内存中的可重用代码段（程序）。任何人都可以通过发出交易请求来请求执行智能合约代码。因为开发人员可以通过发布智能合约将任意可执行应用程序写入EVM（游戏，市场，金融工具等），所以这些通常也称为dapps或Decentralized Apps。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[克服拖延症：框时工作法]]></title>
        <id>https://lianqiujun.co/post/ke-fu-tuo-yan-zheng-kuang-shi-gong-zuo-fa</id>
        <link href="https://lianqiujun.co/post/ke-fu-tuo-yan-zheng-kuang-shi-gong-zuo-fa">
        </link>
        <updated>2020-11-18T02:00:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="目标-克服拖延症提高专注力">目标： 克服拖延症，提高专注力</h2>
<p>在管理任务方面，框时工作是非常有用的技巧。当我需要完成一项任务时，我主要在两种不同的情形下利用此技巧。</p>
<hr>
<h3 id="1-确定最终结果及过程的任务"><strong>1. 确定最终结果及过程的任务</strong></h3>
<p>🐱即： 限定目标</p>
<p>给自己框定明确时间量，绝不超出特定时长，只在这段时间内尽最大努力工作，如果进度落后，你就必须砍除某些功能， 确保该目标必须完成。</p>
<p><strong>简单讲， 就是定好目标，不论如何都要完成。</strong></p>
<p>😁例子： 每天坚持俯卧撑 50， 突然某天来不及做了，  请不要中断： <strong>做 1 个</strong><br>
即便如此，你也完成了你的【每日俯卧撑任务】</p>
<hr>
<h3 id="2-不明确最终结果及实现过程的任务"><strong>2. 不明确最终结果及实现过程的任务</strong></h3>
<p>🐱即： 限定时间</p>
<p>遇到想完成的任务或项目，但自己并不确定该从何开始时。或这份工作似乎在做出有意义结果前，需要花去很长时间。或者这份工作可能非常枯燥，会有拖延倾向。此时就用框时工作方式，直接承诺在当前任务上只工作限定的时长，以便取得些进展。<br>
<strong>简单讲， 就是限定时间，不论结果如何，任务能否按时完成，先行动起来。</strong></p>
<p>😁例子：用新的编程语言学习开发一个Blog网站， 你不知道如何开始，也不知道会用时多久，那么不要考虑这些，直接开始定时 30分钟， 随便去学去尝试，至少30分钟内你是在行动的。（一般30分钟后，你会取得一些进展，并知道下一步该如何做了）</p>
<hr>
<p><code>框时工作能够绕开完美主义陷阱，避免拖延行为。这使之成为极其有用的时间管理技巧。</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区块链周刊 - Web3项目系列文章]]></title>
        <id>https://lianqiujun.co/post/qu-kuai-lian-zhou-kan-web3-xiang-mu-xi-lie-wen-zhang</id>
        <link href="https://lianqiujun.co/post/qu-kuai-lian-zhou-kan-web3-xiang-mu-xi-lie-wen-zhang">
        </link>
        <updated>2020-11-17T16:14:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="web3项目系列文章"><a href="https://lianqiujun.co/tag/pJWTDQOmu/">Web3项目系列文章</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flow Go SDK 开发实践]]></title>
        <id>https://lianqiujun.co/post/flow-go-sdk-kai-fa-shi-jian</id>
        <link href="https://lianqiujun.co/post/flow-go-sdk-kai-fa-shi-jian">
        </link>
        <updated>2020-11-17T09:07:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="flow-go-sdk">Flow Go SDK</h1>
<p>Flow Go SDK 提供相关开发包帮助 Golang 开发者完成在 Flow network 上进行应用的构建和开发。</p>
<p><em>注意: 这个 SDK 通过 <a href="https://github.com/onflow/flow/blob/master/docs/emulator.md">Flow Emulator</a>完成实现，并且可以被用于本地开发。</em></p>
<h2 id="英文"><a href="/README.md">英文</a> | <a href="#">中文（简体）</a></h2>
<h2 id="什么是-flow">什么是 Flow ?</h2>
<p>Flow is a new blockchain for open worlds. Read more about it <a href="https://github.com/onflow/flow">here</a>.</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#getting-started">开始</a>
<ul>
<li><a href="#installing">安装</a></li>
<li><a href="#generating-keys">生成密钥</a>
<ul>
<li><a href="#supported-curves">支持的曲线</a></li>
</ul>
</li>
<li><a href="#creating-an-account">创建一个帐户</a></li>
<li><a href="#signing-a-transaction">签名一个交易</a>
<ul>
<li><a href="#how-signatures-work-in-flow">Flow中的签名是如何在工作的</a>
<ul>
<li><a href="#single-party-single-signature">一人一签</a></li>
<li><a href="#single-party-multiple-signatures">多人签名</a></li>
<li><a href="#multiple-parties">多方</a></li>
<li><a href="#multiple-parties-two-autorizers">多方参与，两个自动执行器</a></li>
<li><a href="#multiple-parties-multiple-signatures">多方参与，多个签名</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sending-a-transaction">发起一笔交易</a></li>
<li><a href="#querying-transaction-results">查询交易结果</a></li>
<li><a href="#querying-blocks">查询块</a></li>
<li><a href="#executing-a-script">执行一个脚本</a></li>
<li><a href="#querying-events">查询事件</a>
<ul>
<li><a href="#event-query-format">事件查询格式</a></li>
<li><a href="#event-results">事件的结果</a></li>
</ul>
</li>
<li><a href="#querying-accounts">查询账户</a></li>
</ul>
</li>
<li><a href="#examples">例子</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="开始">开始</h2>
<h3 id="安装">安装</h3>
<p>开始使用 SDK, 首先安装 Go 1.13+ 版本， 并且运行 <code>go get</code>:</p>
<pre><code class="language-sh">go get github.com/onflow/flow-go-sdk
</code></pre>
<h3 id="生成密钥">生成密钥</h3>
<p>Flow 使用 <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a><br>
去控制用户的账户权限。 每一个密钥都使用了 <code>SHA2-256</code> 或者 <code>SHA3-256</code> 哈希算法实现了。</p>
<p>这里有关于如何生成 ECDSA，采用P-256 (secp256r1) 曲线及私钥的相关方法:</p>
<pre><code class="language-go">import &quot;github.com/onflow/flow-go-sdk/crypto&quot;

// 种子 短语
// 注意: 这只是一个例子, 请使用安全的方式随机生成种子
seed := []byte(&quot;elephant ears space cowboy octopus rodeo potato cannon pineapple&quot;)

privateKey, err := crypto.GeneratePrivateKey(crypto.ECDSA_P256, seed)
</code></pre>
<p>这个私钥可以被编码成  bytes 类型 (i.e. for storage):</p>
<pre><code class="language-go">encPrivateKey := privateKey.Encode()
</code></pre>
<p>可以为一个私钥创建一个对应的公钥:</p>
<pre><code class="language-go">publicKey := privateKey.PublicKey()
</code></pre>
<h4 id="支持的曲线">支持的曲线</h4>
<p>例子部分使用了 ECDSA 密钥， 采用的曲线算法是 P-256 (secp256r1) 。<br>
Flow 也支持 Bitcoin 和 Ethereum 所使用的 secp256k1 曲线算法</p>
<p>这里展示如何采用secp256k1 曲线生成一个 ECDSA 私钥:</p>
<pre><code class="language-go">privateKey, err := crypto.GeneratePrivateKey(crypto.ECDSA_secp256k1, seed)
</code></pre>
<p>这里是支持的签名哈希算法的完整列表:<a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms">Flow 签名 &amp; 哈希算法</a></p>
<h3 id="创建一个帐户">创建一个帐户</h3>
<p>一旦你完成了 <a href="#generating-keys">生成一个密钥对</a>, 您可以使用它的公钥，创建一个新帐户。</p>
<pre><code class="language-go">import (
    &quot;github.com/onflow/flow-go-sdk&quot;
    &quot;github.com/onflow/flow-go-sdk/crypto&quot;
    &quot;github.com/onflow/flow-go-sdk/templates&quot;
)

ctx := context.Background()

// 为账户生成一个新的私钥
// 注意: 这只是一个例子, 请使用安全的方式随机生成种子
seed := []byte(&quot;elephant ears space cowboy octopus rodeo potato cannon pineapple&quot;)
privateKey, _ := crypto.GeneratePrivateKey(crypto.ECDSA_P256, seed)

// 得到公钥
publicKey := privateKey.PublicKey()

// 从公钥中构建一个用户密钥
accountKey := flow.NewAccountKey().
    SetPublicKey(publicKey).
    SetHashAlgo(crypto.SHA3_256).        // SHA3_256 哈希算法生成的密钥对
    SetWeight(flow.AccountKeyWeightThreshold) // 授予这个密钥签名权重

// 生成一个帐户创建脚本
// 这将创建一个帐户，该帐户只有一个公钥，没有代码
script, _ := templates.CreateAccount([]*flow.AccountKey{accountKey}, nil)

// 连接到本地运行的模拟器
c, err := client.New(&quot;localhost:3569&quot;)
if err != nil {
    panic(&quot;failed to connect to emulator&quot;)
}

payer, payerKey, payerSigner := examples.ServiceAccount(c)

tx := flow.NewTransaction().
    SetScript(script).
    SetGasLimit(100).
    SetProposalKey(payer, payerKey.Index, payerKey.SequenceNumber).
    SetPayer(payer)

err = tx.SignEnvelope(payer, payerKey.Index, payerSigner)
if err != nil {
    panic(&quot;failed to sign transaction&quot;)
}

err = c.SendTransaction(ctx, *tx)
if err != nil {
    panic(&quot;failed to send transaction&quot;)
}

result, err := c.GetTransactionResult(ctx, tx.ID())
if err != nil {
    panic(&quot;failed to get transaction result&quot;)
}

var myAddress flow.Address

if result.Status == flow.TransactionStatusSealed {
    for _, event := range result.Events {
        if event.Type == flow.EventAccountCreated {
            accountCreatedEvent := flow.AccountCreatedEvent(event)
            myAddress = accountCreatedEvent.Address()
        }
	}
}
</code></pre>
<h3 id="签名一个交易">签名一个交易</h3>
<p>下面是一个简单的例子使用 <code>crypto.PrivateKey</code> 签名一个交易.</p>
<pre><code class="language-go">import (
    &quot;github.com/onflow/flow-go-sdk&quot;
    &quot;github.com/onflow/flow-go-sdk/crypto&quot;
)

var (
    myAddress    flow.Address
    myAccountKey flow.AccountKey
    myPrivateKey crypto.PrivateKey
)

tx := flow.NewTransaction().
    SetScript([]byte(&quot;transaction { execute { log(\&quot;Hello, World!\&quot;) } }&quot;)).
    SetGasLimit(100).
    SetProposalKey(myAddress, myAccountKey.Index, myAccountKey.SequenceNumber).
    SetPayer(myAddress)
</code></pre>
<p>交易签名通过 <code>crypto.Signer</code> 接口完成.  <code>crypto.Signer</code> 最安全、最简单的接口实现方法是 <code>crypto.InMemorySigner</code>.</p>
<p>使用这样的签名，可以更安全地生成密钥存储在硬件设备中，如 <a href="https://en.wikipedia.org/wiki/Hardware_security_module">HSM</a>.  <code>crypto.Signer</code><br>
就是这样的签名接口的简单实现。</p>
<pre><code class="language-go">// 通过你的私钥构造一个签名器，通过哈希算法完成签名
mySigner := crypto.NewInMemorySigner(myPrivateKey, myAccountKey.HashAlgo)

err := tx.SignEnvelope(myAddress, myAccountKey.Index, mySigner)
if err != nil {
    panic(&quot;failed to sign transaction&quot;)
}
</code></pre>
<h4 id="flow-中的签名是如何在工作的">Flow 中的签名是如何在工作的</h4>
<p>Flow 引入了新的概念，允许在创建和签署事务时具有更大的灵活性。</p>
<p>在尝试下面的示例之前，我们建议您阅读<a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#signing-a-transaction">事务签名文档</a>.</p>
<hr>
<h5 id="一人一签"><a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#single-party-single-signature">一人一签</a></h5>
<ul>
<li>Proposer, payer, authorizer是同一个account (<code>0x01</code>)</li>
<li>只要交易必须签名</li>
<li>提案密钥必须有充分的签名权重。</li>
</ul>
<table>
<thead>
<tr>
<th>Account</th>
<th>Key ID</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x01</code></td>
<td>1</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">account1, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;01&quot;))

key1 := account1.Keys[0]

// 安全的通过私钥创建一个签名器
key1Signer := getSignerForKey1()

tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction { 
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetGasLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetPayer(account1.Address).
    AddAuthorizer(account1.Address)

// 账户1 使用 key 1 进行交易的签名
err := tx.SignEnvelope(account1.Address, key1.Index, key1Signer)
</code></pre>
<p><a href="/examples#single-party-single-signature">完整的可运行的例子</a></p>
<hr>
<h5 id="多人签名"><a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#single-party-multiple-signatures">多人签名</a></h5>
<ul>
<li>
<p>Proposer, payer, authorizer是同一个account (<code>0x01</code>)</p>
</li>
<li>
<p>只要交易必须签名</p>
</li>
<li>
<p>每个密钥的权重为0.5，因此需要两个签名者。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Account</th>
<th>Key ID</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x01</code></td>
<td>1</td>
<td>0.5</td>
</tr>
<tr>
<td><code>0x01</code></td>
<td>2</td>
<td>0.5</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">account1, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;01&quot;))

key1 := account1.Keys[0]
key2 := account1.Keys[1]

//  安全的通过私钥创建两个签名器
key1Signer := getSignerForKey1()
key2Signer := getSignerForKey2()

tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction { 
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetGasLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetPayer(account1.Address).
    AddAuthorizer(account1.Address)

//  账户1 使用 key 1 进行交易的签名
err := tx.SignEnvelope(account1.Address, key1.Index, key1Signer)

//  账户1 使用 key 2 进行交易的签名
err = tx.SignEnvelope(account1.Address, key2.Index, key2Signer)
</code></pre>
<p><a href="/examples#single-party-multiple-signatures">完整的可运行的例子</a></p>
<hr>
<h5 id="多方"><a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties">多方</a></h5>
<ul>
<li>
<p>Proposer和authorizer是同一个账号(<code>0x01</code>)</p>
</li>
<li>
<p>Payer是一个单独的帐户(<code>0x02</code>).</p>
</li>
<li>
<p>帐户<code>0x01</code>对有效支付签名。</p>
</li>
<li>
<p>帐户<code>0x02</code>在交易上签名。</p>
</li>
<li>
<p>帐户<code>0x02</code>必须最后签名，因为它是付款人。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Account</th>
<th>Key ID</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x01</code></td>
<td>1</td>
<td>1.0</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>3</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">account1, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;01&quot;))
account2, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;02&quot;))

key1 := account1.Keys[0]
key3 := account2.Keys[0]

// 安全的通过私钥创建两个签名器
key1Signer := getSignerForKey1()
key3Signer := getSignerForKey3()

tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction { 
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetGasLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetPayer(account2.Address).
    AddAuthorizer(account1.Address)

// 账户1 使用 key 1 进行交易的签名
err := tx.SignPayload(account1.Address, key1.Index, key1Signer)

// 账户2 使用 key 3 进行交易的签名
// 注意: 付款者总是最后一个签名
err = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)
</code></pre>
<p><a href="/examples#multiple-parties">完整的可运行的例子</a></p>
<hr>
<h5 id="多方参与两个自动执行器"><a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties">多方参与，两个自动执行器</a></h5>
<ul>
<li>
<p>Proposer和authorizer是同一个账号(<code>0x01</code>)</p>
</li>
<li>
<p>Payer是一个单独的帐户(<code>0x02</code>)</p>
</li>
<li>
<p>帐户<code>0x01</code>对支付签名。</p>
</li>
<li>
<p>帐户<code>0x02</code>在交易上签名。</p>
</li>
</ul>
<p>-帐户<code>0x02</code>必须最后签名，因为它是付款人。</p>
<p>-帐户<code>0x02</code>也是一个授权器，用于展示如何将两个authaccount包含到一个事务中</p>
<table>
<thead>
<tr>
<th>Account</th>
<th>Key ID</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x01</code></td>
<td>1</td>
<td>1.0</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>3</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">account1, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;01&quot;))
account2, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;02&quot;))

key1 := account1.Keys[0]
key3 := account2.Keys[0]

// 安全的通过私钥创建两个签名器
key1Signer := getSignerForKey1()
key3Signer := getSignerForKey3()

tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction {
            prepare(signer1: AuthAccount, signer2: AuthAccount) {
              log(signer.address)
              log(signer2.address)
          }
        }
    `)).
    SetGasLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetPayer(account2.Address).
    AddAuthorizer(account1.Address).
    AddAuthorizer(account2.Address)

//  账户1 使用 key 1 进行交易的签名
err := tx.SignPayload(account1.Address, key1.Index, key1Signer)

//  账户2 使用 key 3 进行交易的签名
//  注意: 付款者总是最后一个签名
err = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)
</code></pre>
<p><a href="/examples#multiple-parties-two-authorizers">完整的可运行的例子</a></p>
<hr>
<h5 id="多方参与多个签名"><a href="https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#multiple-parties-multiple-signatures">多方参与，多个签名</a></h5>
<ul>
<li>
<p>Proposer和authorizer是同一个账号(<code>0x01</code>)</p>
</li>
<li>
<p>Payer是一个单独的帐户(<code>0x02</code>)</p>
</li>
<li>
<p>帐户<code>0x01</code>对有效付款签名。</p>
</li>
<li>
<p>帐户<code>0x02</code>在交易上签名。</p>
</li>
<li>
<p>帐户<code>0x02</code>必须最后签名，因为它是付款人。</p>
</li>
<li>
<p>两个账户都必须签名两次(每个密钥签名一次)。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Account</th>
<th>Key ID</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x01</code></td>
<td>1</td>
<td>0.5</td>
</tr>
<tr>
<td><code>0x01</code></td>
<td>2</td>
<td>0.5</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>3</td>
<td>0.5</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>4</td>
<td>0.5</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">account1, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;01&quot;))
account2, _ := c.GetAccount(ctx, flow.HexToAddress(&quot;02&quot;))

key1 := account1.Keys[0]
key2 := account1.Keys[1]
key3 := account2.Keys[0]
key4 := account2.Keys[1]

// 安全的通过私钥创建4个签名器
key1Signer := getSignerForKey1()
key2Signer := getSignerForKey1()
key3Signer := getSignerForKey3()
key4Signer := getSignerForKey4()

tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction { 
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetGasLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetPayer(account2.Address).
    AddAuthorizer(account1.Address)

// 账户1 使用 key 1 进行交易的签名
err := tx.SignPayload(account1.Address, key1.Index, key1Signer)

// 账户1 使用 key 2 进行交易的签名
err = tx.SignPayload(account1.Address, key2.Index, key2Signer)

// 账户2 使用 key 3 进行交易的签名
// 注意: 付款者总是最后一个签名
err = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)

// 账户2 使用 key 4 进行交易的签名
// 注意: 付款者总是最后一个签名
err = tx.SignEnvelope(account2.Address, key4.Index, key4Signer)
</code></pre>
<p><a href="/examples#multiple-parties-multiple-signatures">完整的可运行的例子</a></p>
<h3 id="发起一笔交易">发起一笔交易</h3>
<p>You can submit a transaction to the network using the Access API client.</p>
<pre><code class="language-go">import &quot;github.com/onflow/flow-go-sdk/client&quot;

// 连接本地服务
c, err := client.New(&quot;localhost:3569&quot;)
if err != nil {
    panic(&quot;failed to connect to emulator&quot;)
}

ctx := context.Background()

err = c.SendTransaction(ctx, tx)
if err != nil {
    panic(&quot;failed to send transaction&quot;)
}
</code></pre>
<h3 id="查询交易结果">查询交易结果</h3>
<p>提交交易后，您可以通过ID查询交易状态:</p>
<pre><code class="language-go">result, err := c.GetTransactionResult(ctx, tx.ID())
if err != nil {
    panic(&quot;failed to fetch transaction result&quot;)
}
</code></pre>
<p>结果包括一个“Status”字段，该字段将是以下值之一:</p>
<ul>
<li>
<p><code>UNKNOWN</code> - 该交易尚未被网络看到。</p>
</li>
<li>
<p><code>PENDING</code> - 交易尚未包含在一个块中。</p>
</li>
<li>
<p><code>FINALIZED</code> - 交易已包含在一个区块中。</p>
</li>
<li>
<p><code>EXECUTED</code> - 交易已执行，但结果尚未打包。</p>
</li>
<li>
<p><code>SEALED</code> - 事务已经被执行并且结果被打包在一个块中。</p>
</li>
</ul>
<pre><code class="language-go">if result.Status == flow.TransactionStatusSealed {
  fmt.Println(&quot;Transaction is sealed!&quot;)
}
</code></pre>
<p>结果还包含一个“Error”，该“Error”包含失败事务的错误信息。</p>
<pre><code class="language-go">if result.Error != nil {
    fmt.Printf(&quot;Transaction failed with error: %v\n&quot;, result.Error)
}
</code></pre>
<h3 id="查询区块">查询区块</h3>
<p>你可以使用' GetLatestBlock '方法来获取最新的打包或未打包的区块:</p>
<pre><code class="language-go"> 
isSealed := true
latestBlock, err := c.GetLatestBlock(ctx, isSealed)
if err != nil {
    panic(&quot;failed to fetch latest sealed block&quot;)
}

 
isSealed := false
latestBlock, err := c.GetLatestBlock(ctx, isSealed)
if err != nil {
    panic(&quot;failed to fetch latest unsealed block&quot;)
}
</code></pre>
<p>一个块包含以下字段:</p>
<ul>
<li>
<p><code>ID</code> - 块的ID(散列)</p>
</li>
<li>
<p><code>ParentBlockID</code> - 链中前一个块的ID。</p>
</li>
<li>
<p><code>Height</code> - 链条中区块的高度。</p>
</li>
<li>
<p><code>collectionguarantee</code> - 集合中包含的集合列表。</p>
</li>
</ul>
<h3 id="执行一个脚本">执行一个脚本</h3>
<p>可以使用“ExecuteScriptAtLatestBlock”方法根据最新的密封执行状态执行只读脚本。</p>
<p>此功能可用于从区块链读取状态。</p>
<p>脚本必须采用以下形式:</p>
<ul>
<li>具有单一返回值的单一<code>main</code>函数</li>
</ul>
<p>这是一个有效脚本的例子:</p>
<pre><code>fun main(): Int { return 1 }
</code></pre>
<pre><code class="language-go">import &quot;github.com/onflow/cadence&quot;

script := []byte(&quot;fun main(): Int { return 1 }&quot;)

value, err := c.ExecuteScript(ctx, script)
if err != nil {
    panic(&quot;failed to execute script&quot;)
}

ID := value.(cadence.Int)

// 转换成  Go int 类型
myID := ID.Int()
</code></pre>
<h3 id="查询事件">查询事件</h3>
<p>你可以查询事件与' GetEventsForHeightRange '函数:</p>
<pre><code class="language-go">import &quot;github.com/onflow/flow-go-sdk/client&quot;

blocks, err := c.GetEventsForHeightRange(ctx, client.EventRangeQuery{
    Type:       &quot;flow.AccountCreated&quot;,
    StartHeight: 10,
    EndHeight:   15,
})
if err != nil {
    panic(&quot;failed to query events&quot;)
}
</code></pre>
<h4 id="事件查询格式">事件查询格式</h4>
<p>一个事件查询包括以下字段:</p>
<p><strong>Type</strong></p>
<p>要筛选的事件类型。事件类型由声明它们的帐户和合约命名。</p>
<p>例如, 一个 <code>Transfer</code> 被定义在一个 <code>Token</code> 合约中，该合约被部署在账户 <code>0x55555555555555555555</code> 中， 将会得到一个类型 <code>A.0x55555555555555555555.Token.Transfer</code>.</p>
<p>阅读 <a href="https://github.com/onflow/cadence/blob/master/docs/language.md#events">语言文档</a> 关于 Cadence 语言.</p>
<p><strong>StartHeight, EndHeight</strong></p>
<p>要过滤的块。事件将从“StartHeight”到“EndHeight”范围内的块返回。</p>
<h4 id="事件的结果">事件的结果</h4>
<p>函数的作用是: 返回按块分组的事件。</p>
<p>每个块包含一个按执行顺序匹配查询的事件列表。</p>
<pre><code class="language-go">for _, block := range blocks {
    fmt.Printf(&quot;Events for block %s:\n&quot;, block.BlockID)
    for _, event := range block.Events {
        fmt.Printf(&quot; - %s&quot;, event)
    }
}
</code></pre>
<!--
#### Decoding an Event

TODO: 事件解码示例
-->
<h3 id="查询账户">查询账户</h3>
<p>您可以查询帐户的状态用 <code>GetAccount</code> 函数:</p>
<pre><code class="language-go">import &quot;github.com/onflow/flow-go-sdk&quot;

address := flow.HexToAddress(&quot;01&quot;)

account, err := c.GetAccount(ctx, address)
if err != nil {
    panic(&quot;failed to fetch account&quot;)
}
</code></pre>
<p>A <code>flow.Account</code> contains the following fields:</p>
<ul>
<li><code>Address: flow.Address</code> - The account address.</li>
<li><code>Balance: uint64</code> - The account balance.</li>
<li><code>Code: []byte</code> - The code deployed at this account.</li>
<li><code>Keys: []flow.AccountKey</code> - A list of the public keys associated with this account.</li>
</ul>
<h2 id="例子">例子</h2>
<p><a href="/examples">examples</a>目录包含使用SDK与控件交互的代码示例</p>
<p><a href="https://github.com/onflow/flow/blob/master/docs/emulator.md">Flow Emulator</a>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以太坊开发简介]]></title>
        <id>https://lianqiujun.co/post/yi-tai-fang-kai-fa-jian-jie</id>
        <link href="https://lianqiujun.co/post/yi-tai-fang-kai-fa-jian-jie">
        </link>
        <updated>2020-11-02T07:48:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="以太坊开发一览">以太坊开发一览</h1>
<p>本文档旨在帮助你使用以太坊进行构建程序。它涵盖了以太坊概念，解释了以太坊技术栈，并记录了更复杂的应用程序和用例的高级主题。</p>
<p>如果这是你首次尝试以太坊开发，建议从头开始，像书一样逐步学习。</p>
<h2 id="1-基础知识">1. 基础知识</h2>
<ul>
<li><a href="#">以太坊简介</a></li>
</ul>
<p>关于以太坊知识的快速概览</p>
<ul>
<li><a href="#">Web2 vs Web3</a></li>
</ul>
<p>基于区块链的应用程序与传统应用程序的根本区别</p>
<ul>
<li><a href="#">dapp简介</a></li>
</ul>
<p>去中心化应用程序的简单介绍</p>
<ul>
<li><a href="#">以太坊虚拟机（EVM）</a></li>
</ul>
<p>EVM处理以太坊网络上的所有计算过程，关于EVM的简单介绍</p>
<ul>
<li><a href="#">区块</a></li>
</ul>
<p>区块链中确保数据状态同步的关键环节“区块”，可以保证所有参与者之间同步数据，形成一条链</p>
<ul>
<li><a href="#">帐户</a></li>
</ul>
<p>以太坊的账户是网络中可以保持余额并发送交易的实体</p>
<ul>
<li><a href="#">交易</a></li>
</ul>
<p>导致以太坊状态改变或资产转移以及其他行为的总称</p>
<ul>
<li><a href="#">区块浏览器</a></li>
</ul>
<p>一种读取有关交易，账户，区块和网络数据的工具</p>
<ul>
<li><a href="#">Gas 气体</a></li>
</ul>
<p>处理交易所需的任何计算都需要消耗Gas气体，由交易发送方以ETH支付相应的Gas 费用</p>
<ul>
<li><a href="#">挖矿</a></li>
</ul>
<p>帮助以太坊系统进行处理交易和创建区块的方式</p>
<ul>
<li><a href="#">以太坊网络</a></li>
</ul>
<p>以太坊包含主网和多个测试网络</p>
<ul>
<li><a href="#">节点和客户端</a></li>
</ul>
<p>参与网络的个人以及他们运行以验证交易的软件</p>
<h2 id="2-以太坊技术栈">2. 以太坊技术栈</h2>
<ul>
<li><a href="#">技术栈介绍</a></li>
</ul>
<p>以太坊/ web3 技术栈相关概述</p>
<ul>
<li><a href="#">智能合约</a></li>
</ul>
<p>部署在以太坊上，交易触发时运行相关功能的程序</p>
<ul>
<li><a href="#">编程语言</a></li>
</ul>
<p>参与以太坊开发可以使用的编程语言</p>
<ul>
<li><a href="#">JavaScript 客户端库</a></li>
</ul>
<p>让web应用与以太坊上智能合约进行方便交互的库</p>
<ul>
<li><a href="#">安全</a></li>
</ul>
<p>以太坊开发的安全规范</p>
<ul>
<li><a href="#">存储</a></li>
</ul>
<p>以太坊开发的数据存储</p>
<ul>
<li><a href="#">开发框架</a></li>
</ul>
<p>简化以太坊开发的工具</p>
<ul>
<li><a href="#">开发环境</a></li>
</ul>
<p>编写dapp代码的最佳环境</p>
<h2 id="3-高级知识">3. 高级知识</h2>
<ul>
<li>
<p><a href="#">代币标准</a></p>
</li>
<li>
<p><a href="#">Oracle 预言机</a></p>
</li>
<li>
<p><a href="#">Layer 2 拓展</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是智能合约及其运作方式？]]></title>
        <id>https://lianqiujun.co/post/shi-me-shi-zhi-neng-he-yue-ji-qi-yun-zuo-fang-shi</id>
        <link href="https://lianqiujun.co/post/shi-me-shi-zhi-neng-he-yue-ji-qi-yun-zuo-fang-shi">
        </link>
        <updated>2020-10-10T04:29:15.000Z</updated>
        <content type="html"><![CDATA[<p>智能合约是执行一组指令的计算机代码。Dapps是去中心的应用程序，与智能合约相互结合在一起，让人们可以与之交互。</p>
<h2 id="简单介绍">简单介绍</h2>
<ul>
<li>
<p>智能合约是表示为一段代码的合约，旨在执行一组指令。</p>
</li>
<li>
<p>“智能合约”一词是在1990年代由Nick Szabo撰写的学术论文中提出的。</p>
</li>
<li>
<p>Dapps或去中心化应用程序本质上是一系列的智能合约交互。</p>
</li>
</ul>
<p>我们都熟悉应用程序和应用程序商店。你通常是浏览各种软件，下载所需的应用程序，然后就离开了。</p>
<p>在精美的UX和UI界面后面，这些应用程序正在执行其创建者制定的一组特定指令或程序。它可能是一款游戏，日历或商店服务等。</p>
<p>智能合约的执行有与之非常相似的功能。但智能合约是指以一段代码表示的合约，旨在执行一组指令。</p>
<p>Vitalik Buterin和以太坊社区相信这是区块链的未来。如果说比特币是商业世界的黄金，那么智能合约就是商业世界赖以生存的石油。</p>
<h2 id="智能合约如何工作">智能合约如何工作？</h2>
<p>因此，如果你想在没有智能合约的情况下在线购买汽车。为此，你需要：</p>
<ol>
<li>
<p>找到一个汽车销售网站，列出或保存你想要查看的所有汽车的信息。</p>
</li>
<li>
<p>与卖家沟通的购买支付方式等，确认了使用何种支付系统，可让你在见到车后进行支付。如果汽车不是你想要的，则有一定的退款能力。</p>
</li>
<li>
<p>你还需要向当局注册汽车所有权。</p>
</li>
</ol>
<p>所有这些点都要求你<strong>信任你正在访问的站点或服务，而且在很多时候，该过程的每个部分都由不同的公司或个人控制</strong>。</p>
<p>行为不良的个人或组织无需花费太多时间即可更改上述任何一项的正常运作，从而使整个过程无效。</p>
<p>签订智能合约可以消除在购买商品时解决多方信任的问题。</p>
<p>为什么？智能合约的特点是：</p>
<p>🔒安全 - 他们使用加密技术来阻止人们更改记录。</p>
<p>🔍透明 - 每个人都可以在区块链上看到智能合约的含义以及它的用途。</p>
<p>🙏不再需要中间商 - 智能合约不需要第三方进行验证。区块链为你做到这一点。</p>
<p>🤖自治 - 它们会自动工作，因此你不必等待有人主动去执行。</p>
<p>✅准确  - 因为智能合约是用代码编写的，所以它们不依赖于语言的灰色区域以及单词的含义。如果发生这种情况，请执行以下操作。</p>
<p>智能合约的核心往往是一种机制（用计算机代码表示），“如果发生这种情况，那就这样做”。</p>
<p>现在已经能够发现许多的自动化场景。假设你要使用借记卡或信用卡支付费用。你的银行所运行的软件将执行“如果发生这种情况，则执行此操作”：</p>
<p>💸 如果银行帐户中的金额大于要求的金额，请释放资金</p>
<p>💵 如果银行帐户中的金额少于要求的金额，请勿释放资金</p>
<p><strong>智能合约的区别在于，该决定权属于区块链，而不是由银行（或任何第三方）来控制</strong>。</p>
<p>因此，上述示例将其应用于基于区块链的智能合约中，将看到以下内容：</p>
<p>💸 如果数字钱包中的金额较大且尚未用完，请释放资金。</p>
<p>💵 如果数字钱包中的金额较小或已用完，请勿释放资金。</p>
<p><strong>关于智能合约的令人兴奋的一点是，它意味着任何人都可以与任何其他人达成协议，而区块链会记录整个事情</strong>。</p>
<h2 id="dapp如何使用智能合约">Dapp如何使用智能合约？</h2>
<p>最好将Dapps或去中心化应用程序视为捆绑在一起的一堆智能合约。</p>
<p>单独的智能合约只能用于一种类型的交易。但是，dapp可以将多个智能合约捆绑在一起以执行更复杂的事情。</p>
<p>就像今天的应用程序一样，dapp也可以在合约之上放置友好的界面。</p>
<p>一些著名的DAPP：</p>
<p>📉 Augur - 一个市场预测工具，它允许任何人去预测事件并获得奖励。</p>
<p>🏦 MakerDAO - 一种去中心化金融（DeFi） dapp，使用户无需中间人就可以借出和借用加密货币。</p>
<p>🦄 Uniswap - 基于以太坊的去中心化交易所，无门槛，允许任何人去交换ERC20代币。</p>
<p>🐱 CryptoKitties  - 独特的NFT为基础的加密收藏品可以使用智能合同，创造独一无二的加密宠物。</p>
<p>👛 Argent - 一个使用智能合约管理地址和私钥的以太坊的钱包。</p>
<h2 id="谁创建了智能合约">谁创建了智能合约？</h2>
<p>就像用于支持大多数加密货币的区块链技术一样，智能合约是从不太完善的早期技术中衍生出来的。当下的智能合约，它们源自较早的电子指令执行程序，该程序使用if / else语句或使用其他条件逻辑，根据提供的信息自动产生结果。</p>
<p>“智能合约”一词本身是在1990年代由著名的计算机科学家和密码学家Nick Szabo撰写的一篇学术论文中创造的，该科学家还是负责开发比特币的最早先驱之一，即Bit Gold。Szabo最初出于各种基本目的描述了智能合同，但后来在1996年的论文中详细阐述了该技术在数字现金，智能财产等方面的潜在用例。</p>
<p>以太坊在其区块链上实施了图灵完备的语言，从而可以在其智能合约中实现了更复杂的逻辑。</p>
<p>智能合约并不总是完美的，尽管智能合约通常被认为是执行协议和逻辑的“无需信任”的方式，但并非完全没有问题。</p>
<p>一方面，智能合约在许多区块链上都是不可变的。这意味着一旦启动它们，就不能对其进行更改或升级，如果代码存在根本问题，则可能导致灾难性的后果。这可能是2016年以太坊The DAO黑客事件中最突出的一点原因，该黑客利用The DAO 合约功能中的漏洞，偷走了数百万以太坊（ETH）。</p>
<p>未知和新颖的攻击媒介也经常被利用，通常以投资者亏本而告终。在2020年9月，随着Yearn Finance的Andre Cronje的一个项目Eminence的测试版本的崩溃。当时大量投资者将资金投入其中之后，它被一个未知的黑客盗取了1500万美元。</p>
<p>同样，简单的错误代码很可能会使智能合约变得无用。这可以从2020年8月DeFi产量农业项目YAM的崩溃中看出，该项目使用未经审计的智能合约，并因严重的错误而崩溃，导致其治理功能毫无作用。</p>
<h2 id="智能合约的未来">智能合约的未来</h2>
<p>如今，大多数区块链都具有智能合约功能，活跃的开发者社区使用Cosmos，NEO和Hyperledger等区块链上的智能合约来创建dapp。智能合约的功能 范围从比特币或莱特币之类的非常简单的货币到以太坊，Tron和Polkadot等具有Dapp功能的更高级的区块链上。</p>
<p>它们现在用于各种各样的任务，包括数字身份，供应链管理，保险，数据存储等等。</p>
<p>我们仍处在可以使用智能合约和dapp的初期。但是已经有公司甚至政府在尝试其潜力。</p>
<p>🏦 政府 - 爱沙尼亚等国家已经开始使用区块链来管理国家。</p>
<p>🔗 供应链 - 像Provenance这样的初创公司正在帮助制造公司使用区块链来购买和运送商品。</p>
<p>📓 保险 - 像Etherisc这样的新兴公司正在帮助为航空和农业行业创建保险平台。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是以太坊2.0及其重要性？]]></title>
        <id>https://lianqiujun.co/post/shi-me-shi-yi-tai-fang-20-ji-qi-chong-yao-xing</id>
        <link href="https://lianqiujun.co/post/shi-me-shi-yi-tai-fang-20-ji-qi-chong-yao-xing">
        </link>
        <updated>2020-10-09T06:27:24.000Z</updated>
        <content type="html"><![CDATA[<p>以太坊网络升级成以太坊2.0是一个长期计划。旨在解决当前网络的可扩展性和安全性问题。在以太坊2.0完成后，它将转换成为采用权益证明共识机制的区块链“世界计算机”。</p>
<h2 id="简单介绍">简单介绍</h2>
<ul>
<li>
<p>按市值计算的第二大加密货币以太坊正在计划对其网络进行重大更新。</p>
</li>
<li>
<p>以太坊2.0升级旨在解决网络的可扩展性和安全性。</p>
</li>
<li>
<p>升级的第一阶段将于2020年进行，以太坊将转向权益证明共识机制(PoS)。</p>
</li>
</ul>
<h2 id="什么是以太坊20">什么是以太坊2.0？</h2>
<p>以太坊2.0分多个阶段启动，首次升级预计将在2020年底启动。</p>
<p>以太坊2.0与以太坊最大的不同在于，它将采用“权益证明（PoS）”机制替换当前采用的“工作量证明（PoW）”机制。</p>
<h2 id="权益证明与工作证明有何不同">权益证明与工作证明有何不同？</h2>
<p>对于以太坊等区块链，需要以去中心化的方式验证交易。与比特币一样，以太坊目前使用一种称为工作量证明（PoW）的共识机制。</p>
<p>在该系统中，矿工使用计算机硬件的计算能力来解决复杂的数学难题并验证新交易。第一个解决难题的矿工将新交易添加到组成区块链的所有交易的记录中。然后用加密货币奖励他们。但是，此过程可能会消耗大量能源，效率并不乐观。</p>
<p>权益证明（PoS）的不同之处在于，用交易验证程序代替矿工，向加密货币提供验证交易的权利。选择这些验证器以根据其持有的数量和持有的时间长短来选择一个区块。</p>
<p>然后，其他验证者可以证明他们看到了一个验证结果。当有足够的证明时，可以将一个区块添加到区块链中。然后，验证者将因成功提出区块建议而获得奖励。此过程称为“锻造”或“铸造”。</p>
<p>PoS的主要优点是，它比PoW的能源效率高得多，因为它将能源密集型计算机处理与共识算法分离开来。这也意味着你不需要大量的计算能力即可保护区块链。</p>
<h2 id="以太坊20如何比以太坊10更好地扩展">以太坊2.0如何比以太坊1.0更好地扩展？</h2>
<p>升级到以太坊2.0的主要原因之一是可拓展性。使用以太坊1.0，网络每秒只能支持大约30个事务。这会导致延误和拥堵。以太坊2.0承诺每秒最多交易100,000次。这种增加将通过实施分片技术来实现。</p>
<p>当前的以太坊是由单个链和连续块组成的区块链。这是安全的，但是非常慢并且效率不高。随着分片链的引入，该区块链被拆分，从而使交易可以并行链而不是连续链进行处理。这样可以加快网络速度，并且可以更轻松地扩展。</p>
<h2 id="以太坊20如何更安全">以太坊2.0如何更安全？</h2>
<p>以太坊2.0的设计考虑了安全性。大多数权益证明网络都只有少量的验证器，这会使系统更集中并且网络安全性降低。以太坊2.0至少需要16,384个验证器，使其更加分散，因此更加安全。</p>
<p>以太坊2.0代码的安全审核由包括区块链安全公司Least Authority在内的组织进行。</p>
<p>以太坊基金会正在为以太坊2.0建立专门的安全团队，以研究加密货币中可能存在的网络安全问题。以太坊2.0研究人员贾斯汀·德雷克（Justin Drake）在一条推文中表示，这项研究将包括“模糊测试，赏金悬赏，加密经济建模，应用密码分析，形式验证等”。</p>
<h2 id="以太坊20升级将如何进行">以太坊2.0升级将如何进行？</h2>
<p>在Topaz，Medalla，Spadina和Zinken一系列测试网络发布之后，以太坊2.0的全面推出将分三个阶段进行：阶段0，阶段1和阶段2（开发人员希望从零开始计数）。阶段0的目标是在2020年启动，其他阶段则在接下来的几年中进行。</p>
<p>阶段0，存储和管理验证者的注册表，并为以太坊2.0部署权益证明（PoS）共识机制。原始的以太坊PoW链将与此同时运行，因此数据连续性不会中断。</p>
<p>阶段1，将于2021年进行，将整合权益分片链的证明。该网络预计将以64个分片启动（吞吐量是以太坊1.0的64倍），尽管在启动时它们尚不支持帐户或智能合约。并且，将于2021年进行一次临时更新，它将使以太坊主网正式过渡到权益证明。</p>
<p>阶段2，计划于2021/22推出，将使分片变得功能齐全并与智能合约兼容。它还涉及添加以太坊帐户并启用转账和提款，实施跨分片转账以及签订合同。它将为基于以太坊2.0的可扩展应用程序构建执行环境。</p>
<h2 id="以太坊20未来发展">以太坊2.0未来发展</h2>
<p>2020年9月，有消息称Spadina测试网在启动时遇到了问题，迫使至少在发布前要再进行一次“彩排”。Spadina是旨在测试以太坊2.0的创世纪或第一个区块的创建的短期测试网。它与较大的Medalla测试网不同，后者是一个通用的沙箱，代表了网络的运行版本。Spadina测试网存在的问题主要包含用户参与度低，“混乱”和“无效存款”。</p>
<p>更多的改进还在继续中，这种加密货币的未来将如何发展？</p>
<p>以太坊联合创始人Vitalik Buterin制定了路线图，说明未来五到十年如何才能实现以太坊2.0。他说，在过去的两年中，试图了解可能的发展方向，到具体的研究与开发，试图优化我们知道可以实施的特定原语，以太坊已经发生了有效的转变。”</p>
<p>他说，现在的挑战主要是“越来越多地围绕以太坊进行的应用在快速的发展，而发展的速度将随着时间的推移而继续增长，而以太坊2.0尚未准备好。”。</p>
<p>2020年6月，Buterin指出，在实施分片链之前，以太坊2.0至少还需要依赖ZK-rollups等当前可行的扩展方法。</p>
<p>ZK-rollups可以与当前的以太坊网络配合使用，并允许其处理更多交易。他们从实际的区块链上处理交易，然后每隔一段时间上传一次。这是一种快速增加以太坊交易数量的方式，而不会引起网络上的巨大膨胀。</p>
<p>但是使用ZK-rollups存在潜在的缺陷，根据以太坊2.0路线图，建立ZK-rollups依赖于一个集中的参与者—通常是开发者。该路线图指出：“这会诱使开发人员操纵代码或提供漏洞信息，从而破坏了权力下放并增加了社交工程遭到黑客攻击的风险。”</p>
<p>因此，从某种意义上说，这并不是一个完美的解决方案。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是Decentraland？]]></title>
        <id>https://lianqiujun.co/post/shi-me-shi-decentraland</id>
        <link href="https://lianqiujun.co/post/shi-me-shi-decentraland">
        </link>
        <updated>2020-09-29T09:31:08.000Z</updated>
        <content type="html"><![CDATA[<p><code>Decentraland是一个建立在以太坊区块链上的虚拟世界，人们可以在这里进行购买，出售，社交等活动。</code></p>
<p>《模拟城市》，《文明》，《我的世界》。游戏开发人员花费了数年时间来制作世界级的游戏，使人们能够建造建筑物，城市或殖民整个世界。但是，除了您击败的数字敌人之外，您在制作这些出色作品中还能更多的展示什么呢？不多。如果您将真实的货币价值赋予所创造的东西，然后将其出售给出价最高的人，将会发生什么？这就是Decentraland的承诺，Decentraland是一款由区块链驱动的世界构建游戏。</p>
<p>Decentraland可以帮助创造新的世界和新的财富类型，还是仅仅在利用旧的财富？</p>
<h2 id="什么是decentraland">什么是Decentraland？</h2>
<p>土地所有者控制在其土地上发布的内容，该内容被编码为智能合约。这些内容可以是图像、应用、游戏等任何内容。用户可以以与现实世界类似的方式探索，旅行和访问场所。该平台还是用户交互的点对点网络。</p>
<p>借助Decentraland，我们正在创建一个生态系统，将在加密货币上实现的许多解决方案与即将被大量采用的VR系统结合在一起。其结果是一个带有原始经济网络的社会3D世界。</p>
<h2 id="如何在decentraland购买土地">如何在Decentraland购买土地？</h2>
<p>你知道吗？Decentraland上的土地包裹已经卖了数千万美元。在2017年12月的一次交易所中，一块土地以60,000美元的价格售出！</p>
<h2 id="你可以用mana做什么">你可以用MANA做什么？</h2>
<p>加密货币MANA是一种实用通证，例如LAND，将在Decentraland的世界中使用。代币将用于支付土地，化身，物品，收藏品以及赌博等娱乐活动。赚取MANA的能力是对开发人员创建和管理优质内容的一种激励。MANA还是ERC-20代币，可以在加密货币交易所购买和交易。</p>
<p>MANA有固定的供应，当购买LAND来换取MANA时，MANA将被销毁掉了。</p>
<h2 id="谁创造了decentraland">谁创造了Decentraland？</h2>
<p>Decentraland由Esteban Ordano创立，注册为Metaverse Holdings Ltd，总部位于中国北京。Ordano是在一个软件工程师BitPay和相信共同打造领先的Bitcoin基础设施库，Bitcore。他还从事Copay的工作，并领导了创建Streamium应用程序的团队。Ordano与其他Decentraland团队成员一起在阿根廷共同创建了一个面向区块链的黑客空间，名为Voltaire。</p>
<ul>
<li>
<p>2015年–成立了Decentraland</p>
</li>
<li>
<p>2017年8月-首次代币发行（ICO）筹集了2000万美元</p>
</li>
<li>
<p>2017年12月–举行了第一次“土地”拍卖，开发商在这里挑选了主要的虚拟财产位置</p>
</li>
<li>
<p>2018年3月–在因需求而成为优先事项之后，开设了Decentraland土地市场</p>
</li>
<li>
<p>2018年6月–开发人员开始制作作品，该月的LAND销量是CryptoKitties销量的两倍。</p>
</li>
<li>
<p>2019年4月–带有护照的可定制化身揭幕，并将很快推出。</p>
</li>
</ul>
<p>从2018年1月21日到2018年10月22日，Decentraland记录了近39,000笔交易，代表MANA花费了2,350万美元。</p>
<h2 id="未来发展">未来发展</h2>
<p>Decentraland仍在开发中。它已经经历了几个阶段的发展，恰当地称为“石器时代”和“铜器时代”，其路线图中还有更多。在每个阶段中，都会添加新功能，例如创建应用程序，聊天应用程序等的功能。</p>
<p>最终的目标是让Decentraland拥有自己的经济，在那里人们可以将土地出租给其他人，在产品和服务的广告广告牌上放置广告，并在游戏内创建聚集场所供用户度过。</p>
<p>Decentraland的巨大承诺是，就像常规游戏一样，区块链可以变得有趣且引人入胜，而且还可以帮助人们以只有区块链才能实现的方式获得财产所有权。</p>
<p>会成功吗？时间会证明一切。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git功能分支工作流实践]]></title>
        <id>https://lianqiujun.co/post/git-gong-neng-fen-zhi-gong-zuo-liu-shi-jian</id>
        <link href="https://lianqiujun.co/post/git-gong-neng-fen-zhi-gong-zuo-liu-shi-jian">
        </link>
        <updated>2020-09-23T10:08:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="工作流">工作流</h2>
<p><strong>核心思路</strong>:  所有的功能开发应该在一个专门的分支，而不是在master分支上。</p>
<p>这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。 另外，也保证了master分支的代码一定不会是有问题的，极大有利于集成环境。</p>
<pre><code>1. git checkout -b new-featureA master


2. dev

3. git push -u origin new-featureA

4. git merge new-featureA
 

</code></pre>
<h2 id="功能分支实践">功能分支实践</h2>
<p>功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用Pull Requests的方式讨论变更。</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7967781"><label class="task-list-item-label" for="task-item-7967781"> 1. 现有远程主分支master</label></li>
</ul>
<pre><code>coderA 拉取到本地

git clone ssh://user@host/path/to/repo.git

</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4670114"><label class="task-list-item-label" for="task-item-4670114"> 2. coderA  开发新功能</label></li>
</ul>
<p>coderA 将代码拉取到本地，将要开发新功能featureA</p>
<pre><code>git checkout -b new-featureA master


dev ing...

git status
git add &lt;some-file&gt;
git commit

</code></pre>
<p>将新的功能push分支到中央仓库是很好的做法，这样可以方便地备份，如果和其它开发协作，也让他们可以看到coderA的提交。</p>
<pre><code>git push -u origin new-featureA
</code></pre>
<p>这条命令push new-featureA分支到中央仓库（origin），-u选项设置本地分支去跟踪远程对应的分支。 设置好跟踪的分支后，coderA就可以使用git push命令省去指定推送分支的参数。</p>
<pre><code>之后就可以在 new-featureA 分支下完成开发，最后推送到远程的分支上， 并可以向master 发起 Pull Request 

git push 
</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8868633"><label class="task-list-item-label" for="task-item-8868633"> 3. 接受 Pull Request</label></li>
</ul>
<p>adminCoder 看到 coderA 开发的新功能，可以review并在该分支上进行修改，讨论，最后接受Pull Request</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3439055"><label class="task-list-item-label" for="task-item-3439055"> 4. 分支合并到master</label></li>
</ul>
<pre><code>方法一：
git checkout master
git pull
git pull origin new-featureA
git push

方法二：
git merge new-featureA
</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2612492"><label class="task-list-item-label" for="task-item-2612492"> 5. 其他补充操作</label></li>
</ul>
<pre><code>查看分支:
$ git branch

切换分支：
$ git checkout master

删除分支：
git branch -d (branchname)

简化步骤:
git commit -am &quot;可以提交跟踪过的文件&quot;

版本回退至上个版本:
$ git reset --hard HEAD^     

退到/进到 指定commit的sha码:
$ git reset --hard commit_id 

强推到远程：
$ git push origin HEAD --force

查看命令历史：
$ git reflog 
</code></pre>
]]></content>
    </entry>
</feed>